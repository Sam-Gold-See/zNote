# Java

## 基础知识储备

### CMD 界面常见命令

|      操作      | 说明                              |
| :------------: | :-------------------------------- |
|    盘符名称    | 盘符切换。E:回车，表示切换到E盘。 |
|      dir       | 查看当前路径下的内容。            |
|    cd 目录     | 进入单级目录。                    |
|     cd ..      | 回退到上一级目录。                |
| cd 目录1\目录2 | 进入多级目录。                    |
|      cd \      | 回退到盘符目录。                  |
|      cls       | 清屏。                            |
|      exit      | 退出命令提示符窗口。              |
|     strat      | 打开文件                          |
|    ipconfig    | 查看本地IP地址                    |
|    ping IP     | 检查网络是否连接                  |

进入的目录带有中文、空格需要将目录使用双引号标记 cd "目录"

### Java 路径

绝对路径：

一定从盘符开始

相对路径：

相对当前项目，JAVA中相对路径是**相对JVM的启动路径**的，对于简单的JAVA项目，其JVM是在项目名称下启动的

### Java 基础命令

在命令行环境中
先后输入以下指令来完成 编译+运行

```
javac + 文件名 + 后缀(编译java文件)
java + 文件名(运行编译后的java文件)
```

### Java的三大平台

JavaSE、JavaME、JavaEE

#### JavaSE

是另两个版本的基础，主要用于开发桌面应用

#### JavaME

Java语言的小型版本，用于嵌入式消费类电子设备或者小型移动设备的开发

#### JavaEE

用于Web方向的网站开发（主要从事后台服务器的开发）
服务器领域，Java是龙头老大

### Java的主要特性

- 面向对象
- 安全性
- 多线程
- 简单易用
- 开源
- 跨平台

### JRE和JDK

JVM（Java Virtual Machine），Java虚拟机

JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）

JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具

### IDEA

IDEA全称为Intellij IDEA，是用于Java语言开发的集成环境（IDE：把代码编写、编译、执行、调试等多种功能综合到一起的开发工具）

#### IDEA中层级结构介绍

- 结构分类
  - Project（项目、工程）
		淘宝、京东等网站都属于一个个项目，IDEA中就是一个个的Project
  - module（模块）
		一个项目可以存放多个模块，不同的模块可以存放项目中不同的业务功能代码，如一个网站分成论坛模块，报名咨询模块等等
  - package（包）
		一个模块中有很多的细分业务，如一个论坛模块就包含了发帖、评论等不同的业务
  - class（类）
		真正的写代码地方

- 层级关系：project - module - package - class



## Java基础语法

### 注释

注释是对代码的解释和说明文字，分为单行注释、多行注释和文档注释

- 单行注释

```
// 这是单行注释文字
```

- 多行注释

```
/*
这是多行注释文字
这是多行注释文字
这是多行注释文字
*/
```

- 文档注释

```
/**

*/
```

### 关键字

被Java赋予了特定涵义的英文单词

- 特点：
1. 关键字的字母**全部小写**
2. 在常用的代码编辑器，有特殊高亮标记

#### class

用于（创建/定义）一个类，类是Java最基本的组成单元

### 字面量（常量）

字面量类型：

- 整数类型 int
- 小数类型 double
- 字符串类型 string
- 字符类型
- 布尔类型
- 空类型(null)

### 变量

在程序执行过程中，有可能变化的值

定义格式:

```
    数据类型 变量名 = 数据值;
```

### 数据类型

- 基本数据类型：

| 数据类型 | 关键字  | 内存占用 |                 取值范围                  |
| :------: | :-----: | :------: | :---------------------------------------: |
|   整数   |  byte   |    1     |    负的2的7次方 ~ 2的7次方-1(-128~127)    |
|          |  short  |    2     | 负的2的15次方 ~ 2的15次方-1(-32768~32767) |
|          |   int   |    4     |        负的2的31次方 ~ 2的31次方-1        |
|          |  long   |    8     |        负的2的63次方 ~ 2的63次方-1        |
|  浮点数  |  float  |    4     |        1.401298e-45 ~ 3.402823e+38        |
|          | double  |    8     |      4.9000000e-324 ~ 1.797693e+308       |
|   字符   |  char   |    2     |                  0-65535                  |
|   布尔   | boolean |    1     |                true，false                |

定义long类型的数据，需要在数据值后方加一个L作为后缀
定义float类型的数据，需要在数据值后方加一个F作为后缀

### 标识符

标识符：就是给类，方法，变量等起的名字

- 必须由数字、字母、下划线_、美元符号$组成。
- 数字不能开头
- 不能是关键字
- 区分大小写的。

小驼峰命名法用于：方法、变量

大驼峰命名法用于：类名

### 键盘录入

1. 导入`Scanner`这个类
```
import java.util.Scanner;
```

2. 创建对象
```
Scanner sc = new Scanner(System.in);
```

3. 接收数据
```
int i = sc.nextInt();
```

4. 关闭对象
```
sc.close();
```

方法：

1. next(), nextLine(): 可以接受任何数据，但是都会返回一个字符串

2. nextInt()：只能接受一个整数

3. nextDouble()：能接受整数和小数，但是都会看做小数返回

细节：

1. next（），nextInt（），nextDouble（）在接收数据的时候，会遇到空格，回车，制表符其中一个就会停止接收数据，但是这些符号 + 后面的数据还在内存中并没有接收。如果后面还有其他键盘录入的方法，会自动将这些数据接收。

2. nextLine（）方法是把一整行全部接收完毕。

使用方法：

键盘录入分为两套：

- next（）、nextInt（）、nextDouble（）这三个配套使用。

	如果用了这三个其中一个，就不要用nextLine（）。

- nextLine（）单独使用。

	如果想要整数，那么先接收，再使用Integer.parseInt进行类型转换。

### 运算符和表达式

运算符：就是对常量或者变量进行操作的符号。

表达式：用运算符把常量或者变量连接起来的，符合Java语法的式子就是表达式。

#### 算术运算符

```
+ - * / %
```

1. 隐式转换：

- 取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算。
- byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算。

取值范围大小（从小到大）：

byte -> short -> int -> long -> float -> double

2. 强制转换：

书写格式：
```
goalType variableName = (goalType) value;
```

会导致精度丢失

#### 字符串的 + 操作

- 当+操作中出现字符串时，此时就是字符串的连接符，会将前后的数据进行拼接，并产生一个新的字符串。
- 当连续进行+操作时，从左到右逐个执行的。

#### 自增自减运算符

```
++ 自增运算符
-- 自减运算符
```

#### 赋值运算符

```
=
+=
-=
*=
/=
%=
```

#### 关系运算符

```
==
!=
>
>=
<
<=
```

#### 逻辑运算符

```
&  -> &&(短路)
|  -> ||(短路)
^
!
<< 左移，低位补0
>> 右移，除符号位都补0
>>> 无符号右移，高位补0
```

#### 三元运算符

```
关系表达式 ? 表达式1 : 表达式2 ;
```

### 判断和循环

#### 流程控制语句

1. 分类

- 顺序结构
- 判断和选择结构
- 循环结构

2. 顺序结构

按照代码的先后顺序依次执行

3. 判断结构

```
if (关系表达式) {
    语句体 ;
}

if (关系表达式) {
    语句体1 ;
} else {
    语句体2 ;
}

if (关系表达式1) {
    语句体1 ;
} else if (关系表达式2) {
    语句体2 ;
}
...
else {
    语句体n+1;
}
```

4. 选择结构

```
switch (表达式) {
	case 1:
		语句体1;
		break;
	case 2:
		语句体2;
		break;
	...
	default:
		语句体n+1;
		break;
}
```

- default的位置和省略情况

    default可以放在任意位置，也可以省略

- case穿透

    不写break会引发case穿透现象

5. 循环结构

```
for (初始化语句;条件判断语句;条件控制语句) {
	循环体语句;
}

while(条件判断语句){
	循环体;
	条件控制语句;
}

do{
    循环体;
    条件控制语句;
}while(条件判断语句);
```

### 数组

数组：指的是一种容器，可以同来存储同种数据类型的多个值。

定义格式：

```
数据类型[] 数组名 -> int[] array
数据类型 数组名[] -> int array[]
```

#### 静态、动态初始化数组

格式：
```
//静态
数据类型[] 数组名 = new 数据类型[]{元素1，元素2，元素3，元素4...};
->
int[] array = new int[]{1,2,3,4};

//动态
数据类型[] 数组名 = new 数据类型[数组的长度];
->
int[] array = new int[3];
```

解释：

- 数据类型：限定了数组以后能存什么类型的数据。
- 方括号：表示现在定义的是一个数组。
- 数组名：在起名字的时候遵循小驼峰命名法。
- new：给数组在内存中开辟一个空间
- 数据类型：限定数组能存什么类型的数据，前后数据类型要保持一致

#### 地址值（指针）

对于一个名为 array 的数组进行打印操作
```
System.out.println(array);//address
```
输出的是数组的地址值，即表示数组在内存中的位置

#### 数组元素访问、索引、长度

```
数组名[索引];   ->数组的内容

数组名.length;  ->数组的长度
```

#### 数组的内存

```
int[] arr = new int[2];
sout(arr);//arr这个数组在堆内存中的地址值
sout(arr[0]);
```

### 方法

方法是程序中最小的执行单元，必须先创建才可以使用，该过程称为方法定义

#### 方法的定义和调用

- 无参数方法定义和调用
```
定义：
public static void methodName (){
	// 方法体
}

调用：
methodName();
```
- 带参数方法定义和调用

```
public static void methodName (values){
	方法体;
}
```

- 带返回值方法的定义和调用

```
public static valueType methodName (value){
	return newValue;
}
```

#### 形参和实参

1. 形参：方法定义中的参数

2. 实参：方法调用中的参数

#### 方法重载

方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载

- 多个方法在同一个类中
- 多个方法具有相同的方法名
- 多个方法的参数不相同，类型不同或者数量不同

重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关
**不能通过返回值来判定两个方法是否相互构成重载**

#### 方法的值传

传递基本数据类型时，传递的是真实数据，形参的改变不影响实际参数的值

传递引用数据类型时，传递的是地址值，形参的改变影响实际参数的值

## 面向对象

### 类和对象

客观存在的事物皆为对象

- 类
	- 类的理解
		- 类是对现在生活中一类具有共同属性和行为的事物的抽象
		- 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合
		- 类是对现实事物的一种描述
	- 类的组成
		- 属性：指事物的特征
		- 行为：指事物能执行的操作

- 类和对象的关系
	- 类：对现实生活中一类具有共同属性和行为的事物的抽象
	- 对象：是能够看得到摸得着的真实实体
	- **类是对事物的一种描述，对象则为具体存在的事物**

### 类的定义

类的组成是由属性和行为两部分组成

- 属性：在类中通过成员变量来体现
- 行为：在类中通过成员方法来体现

```
public class className{
	// 成员变量
	valueType value1;
	valueType value2;
	...
	// 成员方法
	...
}
```

### 对象的使用

- 创建对象的格式
```
className objectName = new className();
```

- 调用对象的格式：
```
objectName.memberName;
objectName.memberFunction();
```

### 类的类型

- **javabean类**：用来描述一类事物的类（不写main方法）
- **测试类**：编写main方法的类
- **工具类**：私有化构造方法，静态化方法，使用类名调用方法

### 注意事项

- 类名首字母建议大写，需要见名知意，驼峰模式
- 一个java文件中可以定义多个class类，且只能一个类是public修饰，同时public修饰的类名必须成为代码名

### 封装

封装：**告诉用户如何正确设计对象的属性和方法**
对象代表什么，就得封装相应数据，并提供数据相应的行为

### private关键字

**private**是一个权限修饰符，可以修饰成员（变量和方法），被其修饰的成员只能在本类中才能被访问

### this关键字

由于变量遵循就近原则，使用this可以区分局部变量和成员变量

this的本质：所在方法调用者的地址

```
this.value
```

### 成员变量和局部变量

* 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）
* 内存中位置不同：成员变量（堆内存）局部变量（栈内存）
* 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）
* 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）

### 构造方法

格式：
```
public class ClassName{
	修饰符 ClassName(value){

	}
}
```

功能：主要是完成对象数据的初始化

- 特点：
	- 方法名与类名相同，大小写也要一致
	- 没有返回值类型，连void都没有
	- 没有具体的返回值

### 标准类制作

- 类名需要见名知意
- 成员变量使用private修饰
- 提供至少两个构造方法 
  1. 无参构造方法
  2. 带全部参数的构造方法
- get和set方法 
​	提供每一个成员变量对应的setXxx()/getXxx()
- 如果还有其他行为，也需要写上

### 对象内存图

Java内存分配分为：栈、堆、方法区、本地方法栈、寄存器

方法区：存储可以运行的class文件

栈内存：方法运行时所进入的内存，方法进栈运行，运行完毕出栈

堆内存：new出来的东西会在堆内存中开辟空间并产生地址

本地方法栈：JVM在使用操作系统功能的时候使用

寄存器：给CPU使用，和开发无关

#### 一个对象的内存图

![测试代码](img/Java_1.png)

![内存存储展示](img/Java_2.png)

随着栈内存的方法逐渐使用完毕逐个pop出

#### 多个对象的内存图

![测试代码](img/Java_3.png)

![内存存储展示](img/Java_4.png)
其中的两个对象的`study()`方法都已经运行完成pop出栈

#### 两个引用指向同一个对象

```
Student stu1 = new Student();
Student stu2 = stu1;

此时相当于两个指针（stu1,stu2）同时指向了一个地址值
```

### 基本数据类型和引用数据类型

基本数据类型：数据值是存储在自己的空间中，赋值给其他变量也是赋的真实的值

引用数据类型：数据值是存储在其他空间中，自己空间中存储的是地址值，赋值给其他变量赋的是地址值

### static 关键字

- 静态成员变量
	`static`关键字在Java开发中非常的重要，对于理解面向对象非常关键
	用来修饰的成员变量和成员方法是属于类的，放在静态区中
	没有被static修饰的成员变量和方法则是属于对象的

	被static修饰的成员变量，说明该变量是属于类的，直接使用类名访问即可，该变量称为**类变量**或者**静态成员变量**，直接使用类名访问即可，因为类只有一个，所以静态成员变量也只存在一份，使用**类名.变量名称**

- 实例变量
	无static修饰的成员变量属于每个对象，必须创建类的对象才可以访问，使用**对象.变量名称**

- 静态方法
	staitc修饰成员方法，说明该方法属于类，称为**类方法**或者**静态方法**，直接使用类名访问，所有对象都可以共享这个方法,使用**类名.方法名称**即可

- 实例方法
	无static修饰的成员方法属于每个对象，该方法也叫做实例方法，所以必须创建对象才可以访问，使用**对象.实例方法**访问

对于static修饰的成员变量或者成员方法，即静态变量和静态方法，该类的每一个对象都**共享**同一个类和静态变量和静态方法，任何对象都可以更改静态变量的值或者访问静态方法

无static修饰的成员变量或者成员方法，即实例变量和实例方法，必须创建对象才能访问

static修饰的变量、方法存储在静态区，随着类的加载而加载，且只加载一次，所以只有一份，节省内存，优先于对象存在

无static修饰的成员，是属于对象，对象有多少个他们就有多少份，且必须由对象调用

### 继承

多个类中存在相同属性和行为时，我们可以将这些内容内容单独抽取一个类，那么多个类无需再定义这些属性和行为，只需要**继承**那一个类就可以

其中，多个类可以称为**子类**，单独被继承的那一个类被称为**父类**、**超类**或者**基类**

- 定义：
	继承：就是子类继承父类的属性和行为，使得子类对象可以直接具有与父类相同的属性、相同的行为，子类可以直接访问父类中的**非私有**的属性和行为

- 特点：
	1. 提高了**代码的复用性**，减少代码冗余，相同代码重复利用
	2. 使类与类之间产生了关系
	3. Java只支持单继承，不支持多继承
	4. 一个类可以有多个子类
	5. 可以多层继承

- 格式：
	```
	class 父类{
		...
	}
	class 子类 extends 父类{
		...
	}
	```

Java是单继承的，一个类只能继承一个直接父类

继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用

子类不能继承父类的**构造方法**，但是子类可以继承父类的私用成员，只是无法直接访问，需要通过getter/setter方法来访问父类的private成员变量

- 成员变量

	子类和父类中的成员变量出现重名，此时的访问是有影响的，子类会优先访问自己对象中的成员变量，如果想要访问父类的同名成员变量，可以使用**super**关键词

	同**shit**，**super**代表的是父类对象的引用，**this**代表的是当前对象的引用

- 成员方法

	子类父类中出现重名的成员方法，则创建子类的对象调用该方法的时候，子类对象会优先调用自己的方法

- 方法重写
	
	子类出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写，**声明不变，重新实现**，子类方法覆盖父类方法，必须保证权限大于等于父类权限，返回值类型、函数名和参数列表必须一模一样

- @Override重写注解

	在重写方法前面加上该注解，一方面可以提高代码的可读性，一方面可以防止重写出错

- 构造方法

	继承后，子类工作方法器特点：子类所有构造方法的第一行都会默认先调用父类的无参构造方法，子类构造方法的第一行都隐含了`super()`去调用父类无参数构造方法，`super()`可省略

-`super()和this()`

```
	this.成员变量
	super.成员变量

	this.成员方法名()
	super.成员方法名()

	this(...)
	super(...)
```

**super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现**

使用`super(...)`可以调用父类构造方法初始化继承自父类的成员变量的数据
使用`this(...)`可以调用本类中其他的构造方法

### 多态

**多条是继封装、继承之后，面向对象的第三大特性**
**多态出现于继承或者实现关系中**

多态体现的格式：
```
父类类型 变量名 = new 子类/实现类构造器;
变量名.方法名()
```

**多态的前提**：有继承关系，子类对象是可以赋值给父类类型的变量。

使用多态后，对于方法的形参可以定义为共同的父类

```
class Person{}
class Student extends Person{}
class Teacher extends Person{}
...
public void register(Person p){
	p.show();
} 
...
register(Person p);
register(Student s);
register(Teacher t);
```

#### 多态的定义和前提

**多态**：是指同一行为，具有多个不同表现形式。

前提：
1. 有继承或实现关系
2. 方法的重写（不重写没有意义）
3. 父类引用指向子类对象

>父类类型：指子类对象继承的父类类型，或者实现的父接口类型

#### 多态的运行特点

调用成员变量/成员方法：编译看左边，运行看右边

#### 多态的弊端

多态的编译阶段是看左边父类类型的，若子类独有（非从父类处重写），此时多态的写法无法访问子类独有功能。

#### 引用类型转换

**多态写法无法访问子类独有功能**

多态的转型氛围**向上转型（自动转型）** 和 **向下转型（强制转型）**

- 向上转型：
	多态本身是子类类型向父类类型向上转换的过程

	父类类型相对于子类来说是大范围的类型，子类范围小的可以直接自动转型给父类类型的变量

- 向下转型：
	一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式

	所以，为了调用子类特有的方法，必须进行向下转型

#### instanceof关键字

```
变量名 instanceof 数据类型
```
如果变量属于该数据类型或者其子类类型，返回true
如果变量不属于该数据类型或者其子类类型，返回false

在JDK14时提出新特性，将判断和强制转换合并效果

### 包

包在操作系统中其实就是一个文件夹。**包是用来分门别类的管理技术，不同技术类放在不同的包下**，方便管理和维护

命名规范：
```
路径名.路径名.xxx.xxx
```

- 需要导包的情况

在使用Java中提供的非核心包中的类时，使用自己写的其他包中的类，此时需要导包

- 不需要导包的情况

在使用Java核心包(Java.lang)中的类时，使用自己写的同一个包中的类时，此时不需要导包

### 权限修饰符

- public：公共的，所有地方都可以访问。

- protected：本类 ，本包，其他包中的子类都可以访问。

- 默认（没有修饰符）：本类 ，本包可以访问。

  注意：默认是空着不写，不是default

- private：私有的，当前类可以访问。
  `public > protected > 默认 > private`

- 成员变量使用`private` ，隐藏细节。
- 构造方法使用`public` ，方便创建对象。
- 成员方法使用`public` ，方便调用方法。

### final关键字

Java提供了`final`关键字，表示修饰的内容不可变

- **final**：不可改变，可以用于修饰类、方法和变量
  - 类：被修饰的类不能被继承
  - 方法：被修饰的方法不能被重写
  - 变量：被修饰的变量有且仅能被赋值一次

```
final class 类名{
}

修饰符 final 返回值类型 方法名(参数列表){
}

final 基本类型 变量名 = 值;
```

被final修饰的常量名称，一般都有书写规范，所有字母都**大写**

## 抽象类

把没有方法体的方法称为抽象方法。
Java语法规定，包含抽象方法的类就是抽象类。

- 抽象方法：没有方法体的方法
- 抽象类：包含抽象方法的类

### abstract关键字

用于修饰方法和类，修饰的方法是抽象方法，修饰的类是抽象类

- 抽象方法
	`修饰符 abstract 返回值类型 方法名 (参数列表);`

- 抽象类
	`abstract class 类名字{}`

### 抽象类使用方法

要求：继承抽象类的子类**必须重写父类所有的抽象方法**，否则子类也得声明为抽象类。

子类对父类抽象方法的完成时吸纳，将这种方法重写的操作，叫做**实现方法**

### 抽象类的特征

**有得有失**
有得：抽象类得到了拥有抽象方法的能力
有失：抽象了失去了创建对象的能力

### 抽象类的袭击

- 抽象类不能**创建对象**，只能创建其非抽象子类的对象
>假设创建了抽象类的的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义
- 抽象类可以有构造方法，是供子类创建对象时，初始化父类成员
>子类的构造方法中，有默认的super()，需要访问父类的构造方法
- 抽象类中不一定包含抽象方法，但有抽象方法的类必定是抽象类
>未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类的结构设计
- 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则子类也必须定义为抽象类，编译无法通过而报错
>假设不重写所有的抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象方法，没有意义
- 抽象类存在的意义就是被子类继承
>抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现

## 接口

接口是**更加彻底**的抽象，在JDK7及其之前，接口中全部都是抽象方法。
接口同样是不能创建对象的

定义格式：
```
public interface 接口名称{
	// 抽象方法
}
```

成分特点：接口中只有抽象方法和常量

### 接口中的抽象方法

接口中的抽象方法默认会自动加上`public abstract`修饰
按照规范：以后接口中的抽象方法建议不要写`public abstract`

### 接口中的常量

在接口中的常量的成员变量默认会加上：`public static final`，也就是说接口中定义的成员变量实际上是一个常量，被修饰后，变量值不可以被修改；同时静态化的变量可以直接用接口名访问
常量必须要给初始值，建议字母圈大写，单词间下划线链接

### 基本实现

类与接口的关系为实现关系，即**类实现接口**，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用`implements`关键字

#### 实现接口的格式

```
接口的实现：
在Java中接口是被实现的，实现接口的类被称为实现类
class 类名 implements 接口1，接口2，接口3...{

}
```
#### 类实现接口的要求和意义

1. 必须重写实现的全部接口中所有抽象方法
2. 如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类必须定义成抽象类
3. 意义：接口实现体现得是一种**规范**，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类，这是一种**强制性的规范**

- 接口与接口的多继承

一个接口可以同时继承多个接口：

- 类与接口是实现关系
- 接口与接口是继承关系

接口继承接口就是，把其他接口的抽象方法与本接口进行了合并

```
public interface A extends B,C{
}
```

#### 接口的细节

1. 当两个接口中存在相同的抽象方法时候，怎么办？
>只要重写一次就可以，此时的重写，既表示重写接口1的，也表示重写接口2的
2. 实现类能不能继承A类的时候，同时实现其他接口呢？
>实现类可以继承一个抽象类的同时，在实现其他多个接口，只不过要把里面所有的抽象方法全部重写
3. 实现类能不能继承一个抽象类的时候，同时实现其他接口呢？
>实现类可以继承一个抽象类的同时，在实现其他多个接口，只不过要把里面所有的抽象方法全部重写
4. 实现类Zi，实现了一个接口，还继承了一个Fu类。假设再接口中有一个方法，父类有一个同样的方法，子类应该如何操作
>一：如果父类中的方法体可以满足业务需求，在子类中可以不用重写
>二：如果父类中的方法体不可以满足业务需求，在子类中需要重写
5. 如果一个接口中有10个抽象方法，但我在实现类只需要使用一个，该怎么办？
>可以在接口和实现类中间，新建一个中间类（适配器类）
>让这个适配器类趋势线接口，对接口里面所有的方法做空重写
>让子类继承这个适配器类，想要用到那个方法就重写哪个方法
>中间类没有实际意义，一般定义为抽象类，不让外界创建对象

## 内部类

讲一个类A定义在另一个类B里面，里面的那个类A就称为**内部类**，B则为**外部类**
当事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用（人体内有心脏，汽车内有发动机）

### 分类

按照定义的位置来份

1. 成员内部类，类定义在了成员位置（类中方法外称为成员位置，无static修饰的内部类）
2. 静态内部类，类定义在了成员位置（类中方法外称为成员位置，有static修饰的内部类）
3. 局部内部类，定义在了方法内
4. 匿名内部类，没有名字的内部类，可以在类内任意地方

### 成员内部类

特点：
- 无static修饰的内部类，属于外部类对象的
- 宿主：外部对象

使用格式：`外部类.内部类`

获取成员内部类对象的两种方式：

1. 外部直接创建成员内部类的对象

`外部类.内部类 变量 = new 外部类(). new 内部类()`

2. 外部类中定义一个方法提供内部类对象

```
public class Outer{
	private class Inner{}
	public Inner getInner{
		return new Inner();
	}
}

public class Demo{
	public static void main(String[] args){
		Outer o = new Outer();
		Inner i = o.getInner();
	}
}
```

细节：

1. 成员内部类可以被一些修饰符所修饰，如：`private`，`public`，`protected`
>若内部类被`private`修饰，外界无法直接获取内部类的对象，只能通过外部类的相关函数获得；若是其他修饰词，一般直接使用直接引用获取对象
2. 成员内部类里面，JDK16及其之后才能定义静态变量
3. 创建内部类对象时，对象中有一个隐含的`外部类名.this`记录外部类对象的地址值（在内部类调用外部类）
>你不累如果想要访问外部类的成员变量，外部类的变量必须使用final修饰（JDK8后默认加上）

### 静态内部类

特点：
- 静态内部类是一种特殊的成员内部类
- 有static修饰，属于外部类本身
- 静态类内部类与其他类使用方法一样，只是访问时需要使用`外部类.内部类`
- 静态内部类可以直接访问外部类的静态成员
- 静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象

使用格式：
`外部类.内部类`

静态内部类的创建格式：
`外部类.内部类 变量 = new 外部类.内部类构造器;`

调用方法的格式：
- 调用非静态方法的格式：先创建对象，用对象调用
- 调用静态方法的格式：外部类名.内部类名.方法名()

### 局部内部类

定义在方法中的类

### 匿名内部类

**匿名内部类**：是内部类的简化写法，他是一个隐含了名字的内部类

格式：
```
new 类名或者接口名(){
	重写方法
};
```

包含了继承或者实现关系、方法重写、创建对象

若希望定义一个只要使用一次的类，就可以考虑到匿名内部类，匿名内部类的本质作用是为了简化代码。

匿名内部类必须**继承一个父类**或者**实现一个父接口**

匿名内部类格式：

```
new 父类名或者接口名(){
	//方法重写
	@Override
	public void method(){
		//执行语句
	}
}
```

特点：
1. 定义一个没有名字的内部类
2. 这个类实现了父类，或者父类接口
3. 匿名内部类会创建这个没有名字的类的对象

### GUI

GUI(Graphical User Interface)图形用户接口

采取图形化的方式显示操作界面

相关内容存储在Swing包（AWT包过老不利于兼容）

## 正则表达式

`regex`：正则表达式就是用来验证各种字符串的规则。它内部描述了一些规则，我们可以验证用户输入的字符串是否匹配这个规则、在一段文本中查找满足要求的字符串

- 字符类：
1. [abc]：代表a或者b，或者c字符中的一个。
2. [^abc]：代表除a,b,c以外的任何字符。
3. [a-z]：代表a-z的所有小写字符中的一个。
4. [A-Z]：代表A-Z的所有大写字符中的一个。
5. [0-9]：代表0-9之间的某一个数字字符。
6. [a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。
7. [a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。 

- 预定义字符：
1. "." ： 匹配任何字符。（`"."`表示任意字符，`\\.`表示仅匹配 . ）
2. "\d"：一个任何数字[0-9]的简写；
3. "\D"：任何非数字[^0-9]的简写；
4. "\s"： 一个空白字符：[\t\n\x0B\f\r] 的简写
5. "\S"： 非空白字符：[^\s] 的简写
6. "\w"：单词字符：[a-zA-Z-0-9]的简写
7. "\W"：非单词字符：[^\w]

- 逻辑运算符
1. &&：并且
2. |：或者
3. \：转义字符

- 数量词
1. X?		一次或0次
2. X*		零次或多次
3. X+		一次或多次
4. X{n}		正好n次
5. X{n,}	至少n次
6. X{n,m}	至少n次但不超过m次

特殊标志、非捕获分组：
1. `(?i)`表示从此开始的后面组内，不区分大小写匹配
2. `(?=)`问号代指前面的匹配内容，等号后面跟上需要匹配的内容，但是不输出
3. `(?:)`问号代指前面的匹配内容，冒号后面跟上需要匹配的内容，保持输出
4. `(?!)`问号代指前面的匹配内容，感叹号后面跟上不能匹配的内容
5. `\\组号`在正则表达式内部，表示把第x组内容再拿出来用一次
6. `$组号`在正则外部使用，表示把第x组内容再拿出来用一次

贪婪爬取和非贪婪爬取：
1. 默认贪婪匹配
2. 非贪婪匹配：在数量词后面加`?`

使用括号进行分组

```
//判断是否满足正则表达式的规则
public String[] matches(String regex);
//按照正则表达式的规则替换
public String replaceAll(String regex, String newStr);
//按照正则表达式的规则切割字符串
public String[] split(String regex);
```

### 爬取数据

```
java.util.regex.Pattern
java.util.regex.Matcher

Pattern p = Pattern.compile(regex:"");
Matcher m = p.matcher(str);

while(m.find()){		//.find()返回boolean
	String s = m.group();	
}
```

## Lambda

函数式编程思想，JDK 8后开始的新语法

可以简化匿名内部类的书写，只能简化函数式接口的匿名内部类

删除其他，保留参数列表
`(T o1, T o2)->{}`

函数式接口：有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加`@FunctionalInterface`注解

## 集合

集合的体系结构：单列集合、双列集合（每次添加数据的个数划分）

单列集合：

- Collection

  - List
    - ArrayList
    - LinkedList

  - Set
    - TreeSet
    - HashSet
      - LinkedHashSet

List系列的特点：

- 有序
- 可重复
- 有索引

Set系列的特点：

- 无序
- 不重复
- 无索引

```
\\添加元素
boolean add(E e)
\\从集合中移除指定的元素
boolean remove(Object o)
\\根据条件进行移除
boolean removeIf(Object o)
\\清空集合中的元素
void clear()
\\判断集合中是否存在指定的元素
boolean contains(Object o)
\\判断集合是否为空
boolean isEmpty()
\\集合的长度，也就是集合中元素的个数
int size()
```

contains方法的底层是以来equals方法进行判断的，如果集合存储的是自定义对象，需要在javabean类中重写equals方法

### 数据结构

- 栈：后进先出、先进后出
- 队列：先进先出，后进后出
- 数组：查询快、增删慢
- 链表：查询慢、增删快；节点是独立的对象，在内存中不连续，节点包含数据值和下一个节点的地址

### Iterator 迭代器

Collection集合获取迭代器

`Iterator<T> it = iterator()`返回迭代器对象，默认只想当前集合的0索引

迭代器遍历的时候禁止使用集合的方法增删改，使用`Iterator<T>.remove()`来进行删除

Iterator的常用方法

```
//判断当前位置是否有元素，有元素返回true，没有元素返回false
boolean hasNext()
//获取当前位置的元素，并将迭代器对象移向下一个位置
Iterator<T>.next()
```

### Collection

Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的

- 迭代器遍历

- 增强for遍历

>所有的单列集合和数组才能用增强for遍历
>修改在增强for中的变量不会改变集合中原本的数据

- lambda方法遍历

	`Collection.forEach((value)->{});`

#### List

```
//在此集合中的指定位置插入指定的元素
void add(int index,E element)
//删除指定索引处的元素，返回被删除的元素
E remove(int index)
//修改指定索引处的元素，返回被修改的元素
E set(int index,E element)
//返回指定索引处的元素
E get(int index)
```

当方法被调用时候出现了重载现象，优先调用实参和形参类型一致的那个方法

列表迭代器遍历

```
ListIterator<T> it = list.listIerator();

it.add();//列表迭代器专属
it.remove();
```

#### ArrayList

底层原理：
  1. ArrayList是数组结构
  2. 空参创建的集合，在底层创建一个默认长度为0的数组
  3. 添加第一个元素时，底层会创建一个新的长度为10的数组
  4. `size()`既表示元素的个数也表示下个存入数据的索引
  5. 存满时会扩容1.5倍（1个个填入）
  6. 若一次添加多个元素，1.5倍仍放不下，则新创建数组的长度以实际为准

#### LinkedList

底层数据结构是双向链表，查询慢、增删快，但只对首尾操作，速度极快

```
\\在该列表开头插入指定的元素
public void addFirst(E e)
\\将指定的元素追加到此列表的末尾
public void addLast(E e)
\\返回此列表中的第一个元素
public E getFirst()
\\返回此列表中的最后一个元素
public E getLast()
\\从此列表中删除并返回第一个元素
public E removeFirst()
\\从此列表中删除并返回最后一个元素
public E removeLast()
```

底层原理：
  1. 刚开始创建的时候，底层创建了两个变量：一个记录头结点first，一个记录尾结点last，默认为null
  2. 添加第一个元素时，底层创建一个结点对象，first和last都记录这个结点的地址值
  3. 添加第二个元素时，底层创建一个结点对象，第一个结点会记录第二个结点的地址值，last会记录新结点的地址值

迭代器分析：

```
//获取一个迭代器对象
Iterator<E> iterator()
//判断当前指向的位置是否有元素
boolean hasNext()
//获取当前指向的元素并移动指针
E next
```

### 数据结构-树

每一个节点存储（父节点地址、值、左子节点地址、右子节点抵制）

度：每一个节点的子节点个数

二叉树：任意节点的度<=2

树高：树的总层数

根节点：最顶层的节点

左子节点：左下方的节点

右子节点：右下方的节点

根节点的左子树：以根节点的左子节点作根节点构成的树

根节点的右子树：以根节点的右子节点作根节点构成的树

#### 二叉查找树

- 每一个节点最多有两个子节点
- 任意节点左子树上的值都小于当前节点
- 任意节点右子树上的值都大于当前节点

##### 添加节点

1. 小的存左边
2. 大的存右边
3. 一样的不存

##### 查找节点

1. 小了往左查
2. 大了往右查

##### 遍历二叉树

- 前序遍历
  - 从根节点开始，按照**当前节点**，先**左子节点**，再**右子节点**
- 中序遍历（从小到大）
  - 从最左边的子节点开始，先**左子节点**，再**当前节点**，再**右子节点**
- 后序遍历
  - 从最左边的子节点开始，先**左子节点**，再**右子节点**，最后**当前节点**
- 层序遍历
  - 从根节点开始，一层一层的遍历

##### 弊端

容易退化成链表

#### 平衡二叉树

**任意节点**左右子树高度差不超过1

##### 旋转

触发时机：当前二叉树不再是平衡二叉树的时候触发

1. 左旋

	- 从新加入节点开始，以不平衡的点作为支点
	- 将支点的右侧往左拉
	- 原先的右子节点成为新父节点，并把多余的左子节点出让给降级节点充当右子节点

2. 右旋

	- 从新加入节点开始，以不平衡的点作为支点
	- 将支点的左侧往右拉
	- 原先的左子节点成为新父节点，并把多余的右子节点出让给降级节点充当左子节点

##### 破坏平衡二叉树的情况

1. 左左（一次右旋）：当根节点左子树的左子树有节点插入，导致二叉树不平衡
2. 左右（先局部左旋，再整体右旋）：当根节点左子树的右子树有节点插入，导致二叉树不平衡
3. 右右（一次左旋）：当根节点右子树的右子树有节点插入，导致二叉树不平衡
4. 右左（先局部右旋，再整体左旋）：当根节点右子树的左子树有节点插入，导致二叉树不平衡

#### 红黑树

**二叉查找树**的一种

每一个节点可以是红或者黑

红黑树不是高度平衡的，是通过红黑规则实现平衡

- 规则：
  1. 每一个节点或是红色或是黑色
  2. 根节点必须是黑色
  3. 如果一个节点没有子节点或者父节点，则该节点相应的指针属性为Nil，这些Nil视为叶节点,每个叶节点(Nil)是黑色的
  4. 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况)
  5. 对每一个节点,从该节点到其所有后代叶节点的简单路径（不回头）上,均包含相同数目的黑色节点

##### 添加节点

默认红色（效率更高）

- 红黑树添加节点后如何保持红黑规则：

	- 根节点位置：
    	- 直接变为黑色
  	- 非根节点位置：
    	- 父节点为黑色：
        	- 默认红色
    	- 父节点为红色：
        	* 叔叔红色
            	1. 将父节点设为黑色，将叔节点设为黑色
            	2. 将祖父节点设为红色
            	3. 如果祖父节点为根节点，再将根节点变为黑色
            	4. 如果祖父非根节点，将祖父设置为当前节点再进行判断
        	* 叔叔黑色且父节点的右孩子
    			1. 把父节点作为当前节点并左旋，再判断
          	* 叔叔黑色且父节点的左孩子
				1. 将父节点设为黑色
				2. 将祖父节点设为红色
				3. 以祖父节点为支点右旋

### Set集合

- 无序
- 不重复
- 无索引

Set接口中的方法基本和Collection的API一致

#### HashSet

集合底层采用哈希表存储数据，哈希表是一种对增删改查数据性能都较好的结构

创建一个默认长度16默认扩容因子0.75的数组，当元素数量达到 数组长度*扩容因子 个数后，自动扩容一倍

JDK8后，数组+链表+红黑树（当链表长度超过8，数组长度大于等于64，自动转换为红黑树）

同哈希新元素挂在老元素下面

集合中存储的是自定义对象，必须要重写hashCode和equals方法

哈希值：对象的整数表达形式
- 根据hashCode方法算出来的
- 定义在Object类中，所有对象都可以调用，默认使用地址值计算
- 一般情况下，都会重写hashCode方法，利用对象内部属性值计算哈希值
- 小部分情况，不同属性值或者不同地址值计算出来的哈希值一致（哈希碰撞）

- HashSet为什么存取顺序不一
>在遍历HashSet的时候是根据数组+链表/红黑树 顺序来遍历，不能保证取顺序和存一致
- HashSet为什么没索引
>HashSet由数组+链表+红黑树，无法分清楚索引
- HashSet是利用什么机制保证数据去重
>HashCode和equals方法

#### LinkedHashSet

有序、不重复、无索引

底层数据结构依然是哈希表，又额外增加双链表的机制记录存储的顺序

#### TreeSet

不重复、无索引、可排序

基于红黑树的数据结构实现

默认从小到大顺序排序

##### TreeSet的两种排序比较方式

- 默认排序/自然排序：Javabean类实现Comparable接口指定比较规则，重写compareTo方法，返回值为负数，添加元素小；返回值为正数，添加元素大；返回值为0，添加元素已存在，舍弃（o 为已存在的元素，this 要添加的元素）

```
public class Person implements Comparable<Person> {
	
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public int compareTo(Person o) {
        if (this.age > o.age) {
            return 1;
        } else if (this.age < o.age) {
            return -1;
        } else {
            return 0;
        }
    }
}
```

- 比较器排序：用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的，让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法，重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写

```
TreeSet<Person> treeSet = new TreeSet<>(new Comparator<Person>() {
    @Override
    public int compare(Person o1, Person o2) {
        if (o1.age > o2.age) {
            return 1;
        } else if (o1.age < o2.age) {
            return -1;
        } else {
            return 0;
        }
    }
});

treeSet.add(new Person("Tom", 20));
treeSet.add(new Person("Jack", 25));
treeSet.add(new Person("Lily", 20));
treeSet.add(new Person("Tom", 25));

System.out.println(treeSet);
//输出：[Person{name='Jack', age=25}, Person{name='Lily', age=20}, Person{name='Tom', age=25}]
```

### 集合使用环境

- 集合中元素可重复，用基于数组的ArrayList
- 集合中元素可重复，且增删多余查询，用基于链表的LinkedList
- 集合中元素不可重复，用基于哈希表的HashSet
- 集合中元素不可重复，且保证存取顺序，用基于哈希表和双链表的LinkedHashList
- 集合中的元素不可重复，且需要排序，用基于红黑树的TreeList

### 双列集合特点

特点：
  1. 双列集合一次需要存一对数据，分别为键和值
  2. 键不能重复，值可以重复
  3. 键和值是一一对应的，每一个键只能找到自己对应的值
  4. 键+值这个整体我们称之为“键值对”或者“键值对对象”，在Java中叫做“Entry对象”

#### Map

常见API：
```
//添加元素
V put(K key,v value)
//根据键删除键值对元素
V remove(object key)
//移除所有的键值对元素
void clear()
//判断集合是否包含指定的键
boolean containsKey(0bject key)
//判断集合是否包含指定的值
boolean containsValue(object value)
//判断集合是否为空
boolean isEmpty()
//集合的长度，也就是集合中键值对的个数
int size()
```

遍历方式：

1. 键找值
	`Set<> keysSet()`，该方法返回一个由键组成的单列集合，遍历单列集合

2. 键值对
	`Set<Map.Entry<T(key), T(value)>> entrySet()`，该方法返回一个键值对集合

3. Lambda
	`forEach()`重写

#### HashMap

特点：无序、不重复、无索引

底层由哈希表结构实现

#### LinkedHashMap

特点：有序、不重复、无索引

底层由哈希表+双链表结构实现

#### TreeMap

特点：不重复、无索引、可排序

底层由红黑树结构实现

#### 键值对

- 键值对的添加：`put(key,value)`
- 键值对的删除：`remove(key)`
- 键值对的修改：`put(key,value)`
- 键值对的查询：`get(key)`
- 键值对的遍历：`keySet()`

#### 可变参数

可变参数：在方法定义时，使用“…”表示该方法可以接受多个参数，参数类型为Object[]。

```
public void test(Object... args){
    for(Object obj : args){
        System.out.println(obj);
    }
}
```

细节：

1. 可变参数只能作为最后一个参数，且只能有一个

### 泛型

泛型用于约束集合中存储元素的数据类型，本质是将类型参数化
若无泛型，`ArrayList`类在输入不同类型数据的时候仍可以通过编译，但是会在运行时候报错，加入泛型限制数据类型之后，可以使得输入不同类型数据的时候使得编译失败

使用`< 类型参数 >`使得代码操作的数据类型明显，提高了代码的可读性

JDK5引入特性，可以在编译阶段约束操作的数据类型并且进行检查，只能填写引用数据类型

格式：
`<数据类型>`

好处：
- 避免了强制类型转换
- 统一数据类型

Java中的泛型是伪泛型

编译时候检查，传入转为Object，传出转为泛型，此过程为泛型的擦除

可以传入子类类型，默认类型为Object

#### 泛型类

当编写一个类的时候，如果不确定类型，可以下定义为泛型类

```
修饰符 class 类名<类型>{

}
```

类型可以写成T、E、K、V

#### 泛型方法

本方法的泛型只能在本方法中运用

```
修饰符 <E> 返回类型 方法名(参数列表){

}
```
对于不确定个数的参数，可以使用`E...<arrayName>`传入，传入时仍然是`a,b,c,d`一个一个传入

#### 泛型接口

```
修饰符 interface 接口名<类型>{

}
```

实现类给出具体类型

实现类延续泛型，创建对象时再确定泛型类型

#### 泛型的继承

泛型不具备继承性，限制什么类型只能传递什么类型

但是数据具备继承性

```
ArrayList<Father> list1 = new ArrayList<>();
ArrayList<Son> list2 = new ArrayList<>();

// method(ArrayList<Father> list)

method(list1);
method(list2);//报错

list1.add(new Father());
list1.add(new Son());//数据具备继承性
```

#### 泛型的通配符

```
//? extends E:表示可以传递E或者E所有子类类型
//? super E:表示可以传递E或者E所有父类类型
```

限定类型范围

### 不可变集合

是一个长度不可变、内容也无法修改的集合

如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。

当集合对象被不可信的库调用时，不可变形式是安全的。

#### 分类

```
static <E> List<E> of(E...elements)
//创建一个具有指定元素的不可变List集合对象
static <E> Set<E> of(E...elements)
//创建一个具有指定元素的不可变Set集合对象,需要保证唯一性
static <K,V> Map<K,V> of(E...elements)
//创建一个具有指定元素的不可变Map集合对象，需要保证键的唯一性，至多10个键值对
static <K,V> Map<K,V> copyOf(Map<K,V>)
//生成一个具有指定元素的不可变Map集合对象
```

## Stream流

### Stream流的三类方法：
1. 获取stream流：创建一条流水线，把数据放在流水线上准备进行操作
2. 中间方法：流水线上的操作、可以进行多次操作
3. 终结方法：一个Stream流只能有一个中介方法，是流水线上的最后一个操作

### 生成Stream的方法

- Collection体系集合
	使用默认stream()生成流，`default Stream <E stream()>`
- Map体系集合
	把Map转成Set集合，间接的生成流
- 数组
	通过Arrays中的静态方法stream生成流
- 同种数据类型的多个数据
	通过Stream接口的静态方法`of(T..values)`生成流

```
//Collection体系的集合可以使用默认方法stream()生成流
List<String> list = new ArrayList<String>();
Stream<String> stream = list.stream();
Set<String> set = new HashSet<String>();
Stream<String> stream = set.stream();

//Map体系的集合可以使用entrySet()方法生成流
Map<String,Integer> map = new HashMap<String,Integer>();
Stream<String> keyStream = map.keySet().stream();
Stream<Integer> valueStream = map.values().stream();
Stream<Map.Entry<String,Integer>> entryStream = map.entrySet().stream();

//数组可以通过Arrays.stream()方法生成流
int[] arr = {1,2,3,4,5};
Stream<int[]> stream = Arrays.stream(arr);

//同种数据类型的多个数据可以通过Stream.of(T...values)方法生成流
Stream<String> stream = Stream.of("a","b","c");
```

### Stream流中间操作方法

- 概念：中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作

| 方法名                                          | 说明                                                       |
| ----------------------------------------------- | ---------------------------------------------------------- |
| Stream<T> filter(Predicate predicate)           | 用于对流中的数据进行过滤                                   |
| Stream<T> limit(long maxSize)                   | 返回此流中的元素组成的流，截取前指定参数个数的数据         |
| Stream<T> skip(long n)                          | 跳过指定参数个数的数据，返回由该流的剩余元素组成的流       |
| static <T> Stream<T> concat(Stream a, Stream b) | 合并a和b两个流为一个流                                     |
| Stream<T> distinct()                            | 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 |
| Stream<T> map(Function<T,R> mapper)             | 转换流中的数据类型                                         |

中间方法，返回新的Stream流，原来的Stream流只能使用一次且不会影响原本数据

### Stream流终结方法

- 概念：终结方法的意思是,执行完此方法之后,Stream流就被使用完毕,不能再使用其他方法

| 方法名                                   | 说明                       |
| ---------------------------------------- | -------------------------- |
| void forEach(Consumer<? super T> action) | 遍历                       |
| long count()                             | 返回流中元素的个数         |
| toArray()                                | 收集流中的数据，放到数组中 |
| collect()                                | 收集流中的数据，放到集合中 |

## 方法引用

概念：把已经有的方法拿过来用，当做函数式接口中抽象方法的方法体

要求：
1. 引用处必须是函数式接口
2. 被引用方法必须已经存在
3. 被引用方法的形参和返回值必须要跟抽象方法保持一致
4. 被引用方法的功能要满足当前需求

### 引用类方法

格式：`类名::静态方法名`

方法引用符`::`的左边是类名，右边是方法名

### 引用成员方法

格式：`对象名::成员方法名`

方法引用符`::`的左边是对象名，右边是方法名

### 引用构造方法

格式：`类名::new`

方法引用符`::`的左边是类名，右边是new关键字，可以用来创建对象

## 异常

**异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。

在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。

>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行

### 异常体系分类

异常机制其实是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`

Throwable体系：

- **Error**:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症，与开发者无关。
- **Exception**:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。

Exception体系：

- **RuntimeException**:运行时异常，是程序运行过程中可能发生的异常，是可以预见的，是可以处理的。
- **其他异常**:受检异常，是程序运行过程中可能发生的异常，是必须要处理的。

### 异常的作用

- 异常是用来查询bug的关键参考信息
- 异常可以作为昂发内部的一种特殊返回值，以便通知调用者底层的执行情况

### Throwable的成员方法

| 方法名                        | 说明                                                     |
| ----------------------------- | -------------------------------------------------------- |
| public String getMessage()    | 返回此throwable的详细消息字符串                          |
| public String toString()      | 返回此可爬出的简短描述                                   |
| public void printStackTrace() | 将异常的错误信息输出在控制台（仅打印信息，不会停止运行） |

### 抛出、捕获

- 抛出异常`throw`：写在方法内，结束方法，手动抛出异常对象交给调用者
`throw new RuntimeException("异常信息");`

- 声明异常`throws`：写在方法声明处，声明方法可能抛出的异常，编译时异常必须要写
`public void test() throws Exception{}`

- 捕获异常`try-catch-finally`：写在方法内，捕获异常对象，处理异常，在finally代码块中存放的代码都是一定会被执行的（除非JVM退出）

在`catch`中可以填写多个catch块来捕获**不同**的异常，若是多个异常间存在继承关系，那么子类异常需要在上面的catch块中写，否则会被父类异常块捕获。

### 自定义异常

1. 定义异常类
2. 写继承关系
3. 空参构造
4. 带参构造

## File

File对象就表示一个路径，可以使文件的路径，也可以是文件夹的路径

这个路径可以是存在的，也允许不符你在

| 方法名                                   | 说明                                       |
| ---------------------------------------- | ------------------------------------------ |
| public File(String pathname)             | 根据路径名构造File对象                     |
| public File(String parent, String child) | 根据父路径字符串和子路径字符串构造File对象 |
| public File(File parent, String child)   | 根据父File对象和子路径字符串构造File对象   |

### 判断、获取功能

| 方法名                          | 说明                                     |
| ------------------------------- | ---------------------------------------- |
| public boolean isDirectory()    | 判断是否为目录                           |
| public boolean isFile()         | 判断是否为文件                           |
| public boolean exists()         | 判断文件或目录是否存在                   |
| public long length()            | 获取文件大小（字节），不能获取文件夹大小 |
| public String getAbsolutePath() | 获取绝对路径                             |
| public String getPath()         | 获取路径                                 |
| public String getName()         | 获取文件名，带后缀                       |
| public long lastModified()      | 获取最后修改时间（毫秒）                 |

### 创建、删除功能

| 方法名                         | 说明           |
| ------------------------------ | -------------- |
| public boolean createNewFile() | 创建文件       |
| public boolean mkdir()         | 创建目录       |
| public boolean mkdirs()        | 创建多级目录   |
| public boolean delete()        | 删除文件或目录 |

### 遍历功能

| 方法名                    | 说明                                 |
| ------------------------- | ------------------------------------ |
| public String[] list()    | 列出目录下的文件和目录               |
| public File[] listFiles() | 列出目录下的文件和目录，返回File数组 |

## IO流

File类只能对文件本身进行操作，不能读写文件里面存储的数据内容，所以需要IO流来操作文件

IO流：存储和读取数据的解决方案，用于读写文件中的数据

分类：
- **输入流**、**输出流**；
- **字节流**（所有类型的文件）、**字符流**（纯文本文件）；

抽象类：
|            |           **输入流**            |            **输出流**            |
| :--------: | :-----------------------------: | :------------------------------: |
| **字节流** | 字节输入流<br />**InputStream** | 字节输出流<br />**OutputStream** |
| **字符流** |   字符输入流<br />**Reader**    |    字符输出流<br />**Writer**    |

字符流的底层就是字节流，用于处理纯字符

字符流 = 字节流 + 字符集

- 输入流：一次读一个字节，遇到中文，一次读多个字节
- 输出流：底层会把数据按照指定的编码方式进行编码，变成字节再写到文件中

### 字节输出流【OutputStream】

`java.io.OutputStream `抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。

* `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  
* `public void flush() ` ：刷新此输出流并强制任何缓冲的输出字节被写出。  
* `public void write(byte[] b)`：将 b.length字节从指定的字节数组写入此输出流。  
* `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  
* `public abstract void write(int b)` ：将指定的字节输出流。

#### 文件输出流【FileOutputStream】

| 方法名                                               | 说明                                                                    |
| ---------------------------------------------------- | ----------------------------------------------------------------------- |
| public FileOutputStream(File file)                   | 根据文件对象构造文件输出流                                              |
| public FileOutputStream(String name)                 | 根据文件名构造文件输出流                                                |
| public FileOutputStream(File file, boolean append)   | 根据文件对象和是否追加的方式构造文件输出流，默认为false（清空原有内容） |
| public FileOutputStream(String name, boolean append) | 根据文件名和是否追加的方式构造文件输出流                                |
| public void write(int b)                             | 将指定的ASCII码值写入此输出流                                           |
| public void write(byte[] b)                          | 将指定的字节数组写入此输出流                                            |
| public void write(byte[] b, int off, int len)        | 从指定的字节数组写入，从off索引开始，len个字节                          |

换行：
- Windows系统：`\r\n`
- Linux系统：`\n`
- Mac系统：`\r`

创建对象：
- 参数是字符串表示的路径或者是File对象都可以
- 如果路径不存在，会自动创建，但是要保证父级路径是存在的
- 如果文件存在，会清空原文件

写入数据：
- 写到本地文件的是整数在ASCII上对应的字符

释放资源：
- 每次使用完后都需要关闭流，释放资源

### 字节输入流【InputStream】

`java.io.InputStream `抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。

- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。    
- `public abstract int read()`： 从输入流读取数据的下一个字节。 
- `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组b中 。

#### 文件输入流【FileInputStream】

创建字节输入流对象：
- 如果文件不存在，直接报错

读取数据：
- 一次读取一个字节，读出来的是数据在ASCII上对应的数字
- 读取到文件末尾，read方法返回-1

释放数据：
- 每次使用完流后都要释放资源

| 方法名                                      | 说明                                                                          |
| ------------------------------------------- | ----------------------------------------------------------------------------- |
| public FileInputStream(File file)           | 根据文件对象构造文件输入流                                                    |
| public FileInputStream(String name)         | 根据文件名构造文件输入流                                                      |
| public int read()                           | 读取输入流中的字节，返回整数值                                                |
| public int read(byte[] b)                   | 从输入流中读取一些字节数，并将它们存储到字节数组b中，返回读取数组长度         |
| public int read(byte[] b, int off, int len) | 从输入流中读取一些字节数，并将它们存储到字节数组b中，从off索引开始，len个字节 |

#### 自动关闭流

```
//JDK 7
try(FileInputStream fis = new FileInputStream("")){
    //操作流
} catch (IOException e) {	
    e.printStackTrace();
}

//JDK 9
FileInputStream fis = new FileInputStream("");//方法抛出异常
try(fis) {
    //操作流
} catch (IOException e) {
    e.printStackTrace();
}
```

### 文件拷贝

流的关闭原则：**先开后关，后开先关，栈**

```
public class Copy{
	public static void main(String[] args) throws IOException{
		FileInputStream fis = new FileInputStream("");
		FileOutputStream fos = new FileOutputStream("");

		int b;
		while((b=fis.read())!=-1)
			fos.write(b);

		int len;
		byte[] bytes = new byte[1024*1024*5];
		while((len=fis.read(bytes))!=-1)
			fos.write(bytes,0,len);

		fos.close();
		fis.close();
	}
}
```

### 字符集

一个字节由8个比特位表示，每个比特位可以取0或1，所以一个字节可以表示256个不同的数值。

不同的字符集对应不同的编码规则，不同的编码规则对应不同的字符集。

乱码产生原因
1. 读取数据时未读完整个汉字
2. 编码和解码时方式不统一

#### ASCII字符集

ASCII字符集是最早的字符集，共128个字符，每个字符占一个字节。

ASCII字符集的编码规则：前面补0，补齐到8位

ASCII字符集的解码规则：直接转成十进制

#### GBK字符集

GBK字符集英文编码规则：不足8位，前面补0，补齐到8位

GBK字符集英文的解码规则：直接转成十进制

GBK字符集中文编码规则：每个汉字占两个字节，高位字节二进制一定以1开头，转成十进制之后是一个负数，不需要变动

GBK字符集中文的解码规则：直接读取

#### Unicode字符集

Unicode字符集是目前世界上使用最广泛的字符集，包含了世界上所有语言的字符。

UTF-8编码规则：用1~4个字节存储

```
0xxxxxxx
110xxxxx 10xxxxxx
1110xxxx 10xxxxxx 10xxxxxx
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```

### 编码和解码

| 方法名                                                 | 说明                   |
| ------------------------------------------------------ | ---------------------- |
| public byte[] getBytes()                               | 使用默认方式进行编码   |
| public byte[] getBytes(String charsetName)             | 使用指定字符集进行编码 |
| public String String(byte[] bytes)                     | 使用默认方式进行解码   |
| public String String(byte[] bytes, String charsetName) | 使用指定字符集进行解码 |

### 字符输入流【Reader】

`java.io.Reader`抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。

- `public void close()`：关闭此流并释放与此流相关联的任何系统资源。    
- `public int read()`： 从输入流读取一个字符。 
- `public int read(char[] cbuf)`： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。

#### 文件输入流【FileReader】

`java.io.FileReader `类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。

| 方法名                             | 说明                                                                                    |
| ---------------------------------- | --------------------------------------------------------------------------------------- |
| public FileReader(File file)       | 根据文件对象构造文件输入流                                                              |
| public FileReader(String fileName) | 根据文件名构造文件输入流                                                                |
| public int read()                  | 读取输入流中的字符，返回整数值，末尾返回-1                                              |
| public int read(char[] cbuf)       | 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中，返回读取数组长度，读到末尾返回-1 |
| public int close()                 | 释放资源/关闭流                                                                         |

### 字符输出流【Writer】

`java.io.Writer `抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。

- `void write(int c)` 写入单个字符。
- `void write(char[] cbuf) `写入字符数组。 
- `abstract  void write(char[] cbuf, int off, int len) `写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 
- `void write(String str) `写入字符串。 
- `void write(String str, int off, int len)` 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
- `void flush() `刷新该流的缓冲。  
- `void close()` 关闭此流，但要先刷新它。 

#### 文件输出流【FileWriter】

`java.io.FileWriter `类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区

| 方法名                                             | 说明                             |
| -------------------------------------------------- | -------------------------------- |
| public FileWriter(File file)                       | 根据文件对象构造文件输出流       |
| public FileWriter(String fileName)                 | 根据文件名构造文件输出流         |
| public FileWriter(File file, boolean append)       | 创建字符输出流关联本地文件，续写 |
| public FileWriter(String fileName, boolean append) | 创建字符输出流关联本地文件，续写 |
| public void write(int c)                           | 写入单个字符                     |
| public void write(char[] cbuf)                     | 写入字符数组                     |
| public void write(char[] cbuf, int off, int len)   | 写入字符数组的某一部分           |
| public void write(String str)                      | 写入字符串                       |
| public void write(String str, int off, int len)    | 写入字符串的某一部分             |

创建字符输出流对象：
- 参数是字符串表示的路径或者是File对象都可以
- 如果文件不存在，会自动创建，但是要保证父级路径是存在的
- 如果文件存在，默认清空原文件

写数据：
- 如果write方法的参数是整数，但是实际写到本地文件中的是证书在字符集上对应的字符

释放资源：
- 每次使用完流后都要释放资源

### 缓冲流

缓冲流,也叫高效流，是对4个基本的`FileXxx` 流的增强，所以也是4个流，按照数据类型分类：

* **字节缓冲流**：`BufferedInputStream`，`BufferedOutputStream` 
* **字符缓冲流**：`BufferedReader`，`BufferedWriter`

缓冲流的基本原理，是在创建流对象时，会创建一个内置的8192字节长的缓冲区，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。

#### 字节缓冲流

| 方法名                                        | 说明                 |
| --------------------------------------------- | -------------------- |
| public BufferedInputStream(InputStream in)    | 创建带缓冲区的输入流 |
| public BufferedOutputStream(OutputStream out) | 创建带缓冲区的输出流 |

#### 字符缓冲流

| 方法名                            | 说明                                                     |
| --------------------------------- | -------------------------------------------------------- |
| public BufferedReader(Reader in)  | 创建带缓冲区的输入流                                     |
| public BufferedWriter(Writer out) | 创建带缓冲区的输出流                                     |
| public String readLine()          | 读取一行，但不会读取换行符，如果没有数据可以读，返回null |
| public void newLine()             | 跨平台的换行                                             |

### 转换流

转换流是字符流和字节流之间的桥梁，让字节流使用字符流的方法

#### InputStreamReader

转换流`java.io.InputStreamReader`，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。

| 方法名                                                       | 说明                                                 |
| ------------------------------------------------------------ | ---------------------------------------------------- |
| public InputStreamReader(InputStream in)                     | 创建转换流，从指定的字节输入流读取                   |
| public InputStreamReader(InputStream in, String charsetName) | 创建转换流，从指定的字节输入流读取，使用指定的字符集 |

实际使用FileReader类，`public FileReader(File file, CharSet charsetName)`

#### OutputStreamWriter

转换流`java.io.OutputStreamWriter` ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 

| 方法名                                                          | 说明                                                     |
| --------------------------------------------------------------- | -------------------------------------------------------- |
| public OutputStreamWriter(OutputStream out)                     | 创建转换流，将字符写入指定的字节输出流                   |
| public OutputStreamWriter(OutputStream out, String charsetName) | 创建转换流，将字符写入指定的字节输出流，使用指定的字符集 |

实际使用FileWriter类，`public FileWriter(File file, CharSet charsetName)`

### 序列化流/反序列化流

可以把Java对象写到本地文件，对象操作输出流

`serialVersionUID`：是用来标识类的版本的，当类的实现发生变化时，可以修改 serialVersionUID 值，以便反序列化时能够正确的实例化对象。

`transient`关键字：用来修饰不需要序列化的属性。

#### ObjectOutputStream

对象操作输出流,Javabean类要实现`Serializable`标记型接口，才能被序列化。

| 方法名                                      | 说明                                       |
| ------------------------------------------- | ------------------------------------------ |
| public ObjectOutputStream(OutputStream out) | 创建对象输出流，将对象写入指定的字节输出流 |
| public void writeObject(Object obj)         | 将指定的对象写入此输出流                   |

#### ObjectInputStream

对象操作输入流

| 方法名                                   | 说明                                       |
| ---------------------------------------- | ------------------------------------------ |
| public ObjectInputStream(InputStream in) | 创建对象输入流，从指定的字节输入流读取对象 |
| public Object readObject()               | 从此输入流中读取对象                       |

### 打印流

只操作文件目的地，不操作数据源，实现了自动刷新自动换行

#### PrintStream

| 方法名                                                                      | 说明                                   |
| --------------------------------------------------------------------------- | -------------------------------------- |
| public PrintStream(OutputStream/File/String out)                            | 创建打印流，将输出写入指定的字节输出流 |
| public PrintStream(String fileName, CharSet charsetName)                    | 指定字符编码                           |
| public PrintStream(OutputStream out, boolean autoFlush)                     | 指定是否自动刷新                       |
| public PrintStream(OutputStream out, boolean autoFlush, String charsetName) | 指定是否自动刷新和字符编码             |

字节流底层没有缓冲区

| 成员方法                                          | 说明                             |
| ------------------------------------------------- | -------------------------------- |
| public void write(int b)                          | 将指定的字节写入此输出流         |
| public void println(Xxx xxx)                      | 打印任意数据，自动刷新，自动换行 |
| public void print(Xxx xxx)                        | 打印任意数据，自动刷新           |
| public void printf(String format, Object... args) | 带有占位符的打印语句，不换行     |

#### PrintWriter

| 方法名                                                                | 说明                                   |
| --------------------------------------------------------------------- | -------------------------------------- |
| public PrintWriter(Writer out)                                        | 创建打印流，将输出写入指定的字符输出流 |
| public PrintWriter(String fileName, CharSet charsetName)              | 指定字符编码                           |
| public PrintWriter(Writer out, boolean autoFlush)                     | 指定是否自动刷新                       |
| public PrintWriter(Writer out, boolean autoFlush, String charsetName) | 指定是否自动刷新和字符编码             |

字符流底层有缓冲区

| 成员方法                                          | 说明                             |
| ------------------------------------------------- | -------------------------------- |
| public void write(int b)                          | 将指定的字节写入此输出流         |
| public void println(Xxx xxx)                      | 打印任意数据，自动刷新，自动换行 |
| public void print(Xxx xxx)                        | 打印任意数据，自动刷新           |
| public void printf(String format, Object... args) | 带有占位符的打印语句，不换行     |

### 压缩流/解压缩流

压缩流

| 方法名                                   | 说明                                       |
| ---------------------------------------- | ------------------------------------------ |
| public ZipOutputStream(OutputStream out) | 创建压缩输出流，将输出写入指定的字节输出流 |
| public void putNextEntry(ZipEntry entry) | 创建新的压缩条目                           |

解压缩流

| 方法名                                | 说明                                             |
| ------------------------------------- | ------------------------------------------------ |
| public ZipInputStream(InputStream in) | 创建解压缩输入流，从指定的字节输入流读取压缩数据 |
| public ZipEntry getNextEntry()        | 读取下一个压缩条目                               |

### Commons-io

Commons是apache开源基金组织提供的工具包，里面有很多帮助我们提高开发效率的API，Commons-io是apache开源基金组织提供的一组有关IO操作的开源工具包。
作用是提高IO流的开发效率

#### 管理jar包

1. 项目内新建lib文件夹
2. 下载jar包，放入lib文件夹
3. 右键点击jar包，选择Add as Library

#### FileUtils类

| 方法名                                                               | 说明               |
| -------------------------------------------------------------------- | ------------------ |
| public static void copyFile(File src, File dest)                     | 复制文件           |
| public static void copyDirectory(File src, File dest)                | 复制文件夹         |
| public static void copyDirectoryToDirectory(File src, File destDir)  | 复制文件夹到文件夹 |
| public static void deleteDirectory(File directory)                   | 删除文件夹         |
| public static void cleanDirectory(File directory)                    | 清空文件夹         |
| public static String readFileToString(File file, String charsetName) | 读取文件内容       |
| public static void write(File file, Charset charset, String content) | 写入文件内容       |

#### IOUtils类

| 方法名                                                              | 说明               |
| ------------------------------------------------------------------- | ------------------ |
| public static int copy(InputStream input, OutputStream output)      | 复制输入流到输出流 |
| public static int copyLarge(InputStream input, OutputStream output) | 复制大文件         |
| public static String readLines(Reader input)                        | 读取文件内容       |
| public static void write(String str, OutputStream output)           | 写入文件内容       |

## 多线程

进程：进程是程序的基本执行实体

线程：线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。

简单理解，线程就是应用软件中互相独立、可以同时运行的功能

线程的调度方式，分为抢占式和非抢占式。

- 非抢占式：轮流执行
- 抢占式（JVM）：体现随机性，优先级越大分配的越多

### 并发和并行

并发：在同一时刻，有多个指令在单个CPU上交替执行

并行：在同一时刻，有多个指令在多个CPU上同时执行

### 多线程的实现方式

| 实现方式                 | 优点                               | 缺点                               |
| ------------------------ | ---------------------------------- | ---------------------------------- |
| 继承Thread类             | 简单，可以直接使用Thread提供的方法 | 无法继承其他类，可拓展性较差       |
| 实现Runnable接口         | 可以继承其他类，可拓展性强         | 复杂，不能直接使用Thread提供的方法 |
| 利用Callable和Future接口 | 可以继承其他类，可拓展性强         | 复杂，不能直接使用Thread提供的方法 |

#### 继承Thread类
	
将类声明为Thread类的子类，并重写run()方法，接下来可以分配并启动该子类的实例，创建对象之后调用start()方法。

```
public class MyThread extends Thread {
    @Override
    public void run() {		
        // 线程要执行的代码
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
```

#### 实现Runnable接口

声明一个类实现Runnable接口，并重写run()方法，接下来可以分配并启动该类的实例，创建对象之后调用start()方法。

```
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 线程要执行的代码
    }
}

public class Main {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        new Thread(myRunnable).start();
    }
}
```

#### 利用Callable和Future接口

可以将线程的执行结果返回，并提供回调接口。

```
public class MyCallable implements Callable<T> {
    @Override
    public T call() throws Exception {
        // 线程要执行的代码
        return null;
    }
}

public class Main {
    public static void main(String[] args) {
        MyCallable mc = new MyCallable();
		FutureTask<T> ft = new FutureTask<>(mc);
		new Thread(ft).start();
		T result = ft.get(); // 获取线程执行结果
	}
}
```

### Thread的成员方法

| 方法名                           | 说明                       |
| -------------------------------- | -------------------------- |
| String getName()                 | 获取线程的名称             |
| void setName(String name)        | 设置线程的名称             |
| static Thread currentThread()    | 获取当前线程               |
| static viod sleep(long millis)   | 让当前线程暂停执行一段时间 |
| setPriority(int newPriority)     | 设置线程的优先级           |
| final int getPriority()          | 获取线程的优先级           |
| final void setDaemon(boolean on) | 设置线程是否为守护线程     |
| public static void yield()       | 出让线程/礼让线程          |
| public static void join()        | 插入线程/插队线程          |

方法细节：

1. `getName()`：，默认名称为“Thread-数字”
2. `setName(String name)`：可以在子类中继承构造方法设置
3. `currentThread()`：当JVM启动时，系统会自动创建主线程main，作用就是调用main方法，并执行里面的代码
4. `sleep(long millis)`：哪条线程执行到这里，那么哪条线程就会在这里停留对应时间，单位为毫秒，当时间到了后线程会自动地醒来继续执行
5. `setPriority(int newPriority)`、`final int getPriority()`：设置线程的优先级，优先级越高，获得CPU的使用权越大，默认优先级为5，范围为1~10，只是反应抢到CPU的概率，并不是绝对的，具体取决于系统的调度算法。
6. `final void setDaemon(boolean on)`：设置线程是否为守护线程，如果设置为true，则该线程不重要，随着程序的结束而结束，默认值为false。
7. `public static void yield()`：出让线程/礼让线程，让当前线程暂停执行一段时间，但不释放CPU资源，让其他线程有机会执行。
8. `public static void join()`：插队线程，让当前线程暂停执行一段时间，直到其他线程执行完毕，才继续执行。

### 线程的生命周期

![线程的生命周期](img/Java_7.png)

### 线程安全的问题

#### 同步代码块：

把操作共享数据的代码锁起来

```
synchronized(锁){
    // 共享数据操作的代码
}
```

特点1：锁默认打开，有一个线程进去了，锁自动关闭

特点2：里面的代码全部执行完毕，线程出来，锁自动打开

特点3：锁对象可以是任意对象，但必须要唯一

#### 同步方法：

把整个方法锁起来

```
public synchronized void method(){
    // 共享数据操作的代码
}
```

特点1：同步方法是锁住方法里面所有的代码

特点2：锁对象不能自己指定，非静态方法（this），静态（当前类的字节码文件对象）

StringBulider类和StringBuilder类的差别就是，前者是线程不安全的，后者是线程安全的。

### Lock锁接口

JDK5后提供了一个新的锁对象Lock，实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作

即提供了获得锁和释放锁的方法，可以显式地进行锁定和解锁操作，并且可以绑定多个条件。

```
void lock(); //获取锁
void unlock(); //释放锁
```

Lock是接口，不能直接实例化，这里采用它的实现类ReentrantLock来实例化

使用`ReentrantLock()`：空参构造

使用`try-catch-finally`：确保锁一定被释放

### 死锁

两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

#### 死锁条件

- 互斥条件：共享资源X和Y只能被一个线程占用
- 请求和保持条件：线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X
- 不可抢占条件：其他线程不能强行抢占线程T1占有的资源
- 循环等待条件：线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源

#### 处理方法

导致死锁后，只能人工干预来处理，重启服务、kill掉线程

避免死锁，可以：

1. 一次性申请所有资源，就不存在锁要等待了
2. 占用部分资源的线程进行进一步申请其他资源的时候，如果申请不到，先释放自己占有的资源
3. 按序申请资源，线性申请资源
4. 避免嵌套锁

### 生产者和消费者（等待唤醒机制）

生产者消费者模式是一个十分经典的多线程协作的模式

生产者：生产数据，放入缓冲区

消费者：从缓冲区取出数据，消费数据

| 方法名称         | 说明                   |
| ---------------- | ---------------------- |
| void wait()      | 让线程等待，直到被唤醒 |
| void notify()    | 唤醒一个正在等待的线程 |
| void notifyAll() | 唤醒所有正在等待的线程 |

使用以上方法都是和锁绑定

可以模拟实现或者阻塞队列实现

#### 阻塞队列

![阻塞队列的继承结构](img/Java_8.png)

- ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列，FIFO，容量大小为数组大小
- LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列，FIFO，容量大小无限（最大为int的最大值）

| 方法名称      | 说明                                   |
| ------------- | -------------------------------------- |
| void put(E e) | 向队列中添加元素，如果队列已满，则阻塞 |
| E take()      | 从队列中取出元素，如果队列为空，则阻塞 |

### 多线程的6种状态

![线程的状态](img/Java_9.png)

（真实无运行状态）

- 新建状态（NEW）：创建线程对象
- 就绪状态（RUNNABLE）：start方法
- 阻塞状态（BLOCKED）：无法获得锁对象
- 等待状态（WAITING）：wait方法
- 计时等待（TIMED_WAITING）：sleep方法
- 终止状态（TERMINATED）：全部代码运行完毕

### 线程栈

线程栈是用来存储线程运行过程中的局部变量、方法调用、返回地址等信息的内存空间。

每个线程都是一个线程栈

### 线程池

#### 线程池主要核心原理

1. 创建一个池子，池子中是空的

2. 提交任务，池子会创建新的线程对象（无空闲线程，但可创建新线程），任务执行完毕，线程归还给池子，下次再次提交任务时，不需要创建新的线程，直接复用已有的线程

3. 但是提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待，直到池子中有空闲线程，才会执行任务

4. 线程池的大小，决定了池子中最多能创建多少个线程，如果池子中有线程空闲，则不会创建新的线程，而是直接复用已有的线程

#### 线程池代码实现

Executors：线程池的工具类，通过调用方法返回不同的线程池对象

1. 创建线程池对象

| 方法名称                                                | 说明                                                                      |
| ------------------------------------------------------- | ------------------------------------------------------------------------- |
| static ExecutorService newCachedThreadPool()            | 创建一个可缓存线程池，线程池的大小不受限，线程数的创建和销毁由JVM自动管理 |
| static ExecutorService newFixedThreadPool(int nThreads) | 创建固定线程数量的线程池                                                  |

2. 提交任务

`pool.submit(Runnable task)`

3. 所有任务执行完毕，关闭线程池

`pool.shutdown()`

#### 自定义线程池

`ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)`

- 核心线程数量：不能小于0
- 线程池中最大线程的数量：最大数量不能小于核心线程数量
- 空闲时间（值）：不能小于0
- 空闲时间（单位）：用TimeUnit类指定
- 阻塞队列：不能为null
- 创建线程的方式：不能为null
- 要执行的任务过多时的粗略：不能为null

##### 创建临时线程的条件：

1. 线程池中没有空闲线程
2. 阻塞队列已满
3. 线程池中线程数量没有达到最大线程数量

（可以说明，任务不一定是按照提交顺序完成）

##### 任务拒绝策略：

| 任务拒绝策略                           | 说明                                                           |
| -------------------------------------- | -------------------------------------------------------------- |
| ThreadPoolExecutor.AbortPolicy         | 直接抛出异常，默认策略                                         |
| ThreadPoolExecutor.DiscardPolicy       | （不推荐）直接丢弃任务，不抛出异常                             |
| ThreadPoolExecutor.DiscardOldestPolicy | 丢弃队列最前面的任务（等待最久的任务），然后把当前任务加入队列 |
| ThreadPoolExecutor.CallerRunsPolicy    | 由调用者所在的线程来执行任务(绕过线程池)                       |

##### 最大并行数

```
int maxParallelism = Runtime.getRuntime().availableProcessors();
```

可以求出最大并行数

##### 线程池大小设置

对于CPU密集型任务，最大并行数+1

对于IO密集型任务，最大并行数 * 期望CPU利用率 * 总时间(CPU计算时间+等待时间)/CPU计算时间

## 网络编程

网络编程：在网络通信协议下，不同计算机上运行的程序，进行的数据传输和通信，是计算机跟计算机之间通过网络进行数据传输（Java.net包是心爱）

### 常见软件架构

#### CS架构

`C/S Client/Server`：客户端和服务器架构，在用户本地需要下载安装客户端程序，在远程有一个服务器端程序

优缺点：

1. 画面可以做的非常精美，用户体验好

2. 需要开发客户端，也需要开发服务端
3. 用户需要下载和更新的时候太麻烦了

#### BS架构

`B/S Browser/Server`：浏览器和服务器架构，用户通过浏览器访问服务器端程序，服务器端程序提供服务

优缺点：

1. 不需要开发客户端，只需要页面+服务端
2. 用户不需要下载，打开浏览器就能使用

3. 如果应用过大，用户体验受到影响

### 网络编程三要素

1. IP：设备在网络中的地址，是唯一的标识
2. 端口号：应用程序在设备中唯一的标识
3. 协议：数据在网络中传输的规则，常见的协议有UDP、TCP、http、https、ftp等

#### IP

全称：Internet Protocol，即互联网协议地址，也称IP地址，是分配给上网设备的数字标签

上网设备在网络中的地址，是唯一的

##### IPv4

全称：Internet Protocol version 4，即互联网协议第四版

采用32位地址长度，分成4组，每组8位，每组用“.”分隔，点分十进制表示法，0-255

IPv4地址分类：公网地址（万维网使用）和私有地址（局域网使用）

192.168.开头就是私有地址，范围即为192.168.0.0-192.168.255.255，专门为组织机构内部使用，以此来节省IP

127.0.0.1，也可以是`localhost`：是回送地址，也称本地回环地址、本地IP，永远只会寻找当前所在本机（不经过网络，在本地回传）

##### IPv6

全称：Internet Protocol version 6，即互联网协议第六版

采用128位地址长度，分成8组，每组16位，每组用“:”分隔，冒号十六进制表示法，0-65535

特殊情况：连续出现多个0，则使用0位压缩表示法

##### InetAddress类

java.net包中提供的类，用来表示IP地址，可以获取IP地址的各种信息

| 方法名                                    | 说明                                               |
| ----------------------------------------- | -------------------------------------------------- |
| static InetAddress getByName(String host) | 根据主机名获取IP地址，可以使机器名称也可以是IP地址 |
| String getHostName()                      | 获取此IP地址的主机名                               |
| String getHostAddress()                   | 返回文本显示的IP地址字符串                         |

#### 端口号

应用程序在设备中唯一的标识

端口号由两个字节表示的整数，取值范围：0~65535
0~1023：系统预留端口，一般不用

一个端口号只能被一个应用使用，如果多个应用使用同一个端口号，则会出现端口冲突

#### 协议

计算机网络中，连接和通信的规则被称为网络通信协议

- OSI参考模型：世界互联协议标准，全球偷心规范，单模型过于理想化，未能在因特网上进行广泛推广

- TCP/IP参考模型（TCP/IP协议）：事实上的国际标准

![协议对应模型](img/Java_10.png)

UDP协议
- 用户数据报协议（User Datagram Protocol）
- UDP是面向无连接通信协议，速度快，有大小限制（64k），数据不安全，易丢失数据
- 不管是否已经连接成功都发送

TCP协议
- 传输控制协议TCP（Transmission Control Protocol）
- TCP是面向连接的协议，速度慢，没有大小限制，数据安全
- 会确保连接成功，并且数据传输的完整性

##### UDP通信程序

发送数据
1. 创建发送端的DatagramSocket对象
2. 数据打包（DatagramPacket）
3. 发送数据
4. 释放资源


```
//创建发送端的DatagramSocket对象
//绑定端口，通过该端口向外发送，若空参构造，则随机分配可用端口；若指定端口，则绑定该端口
DatagramSocket ds = new DatagramSocket();

//数据打包DatagramPacket
//data为要发送的数据，必须要转化为字节形式
DatagramPacket dp = new DatagramPacket(data, data.length, ip, port);

//发送数据
ds.send(dp);

//释放资源
ds.close();
```

接收数据
1. 创建接收端的DatagramSocket对象
2. 接收打包好的数据
3. 解析数据包
4. 释放资源

```
//创建接收端的DatagramSocket对象
//接收的时候一定要绑定端口，还要和发送端口一致
DatagramSocket ds = new DatagramSocket(port);

//接收打包好的数据
byte[] data = new byte[1024];
DatagramPacket dp = new DatagramPacket(data, data.length);
ds.receive(dp);

//解析数据包
byte[] bytes = dp.getData();
int len = dp.getLength();
InetAddress address = dp.getAddress();
int port = dp.getPort();

System.out.println("接收到的数据：" + new String(bytes, 0, len));
System.out.println("发送方的IP：" + address.getHostAddress());
System.out.println("发送方的端口：" + port);

//释放资源
ds.close();
```

细节：receive()方法是阻塞的，直到接收到数据才会返回，如果没有数据，则一直阻塞

UDP的三种通信方式：

1. 单播

2. 组播
	
	组播地址：224.0.0.0-239.255.255.255，用于多播，同一网络下的所有主机都可以接收到该组播包
	其中224.0.0.0-224.0.0.255为预留的组播地址

3. 广播

	255.255.255.255，用于广播，同一网络下的所有主机都可以接收到该广播包

##### TCP通信程序

TCP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket对象
通信之前要保证连接已经建立
通过Socket产生IO流来进行网络通信

![通信程序流程图](img/Java_11.png)

##### TCP的三次握手

![TCP的三次握手](img/Java_12.png)

##### TCP的四次挥手

![TCP的四次挥手](img/Java_13.png)

## 动态代理

动态代理特点：无侵入式的给代码增加额外的功能

把所有想要被代理的方法写在接口里面，对象和代理需要实现同一个接口

`java.lang.reflect.Proxy`：提供了为对象产生代理对象的方法

## 反射

反射允许对成员变量、成员方法和构造方法的信息进行编程访问

### 获取class对象

1. Class.forName("全类名") 包名+类名

2. 类名.class

3. 对象.getClass()

使用Class对象存储

## API

API(Application Programming Interface):应用程序编程接口

java中的API，指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。

### String类

String 代表字符串，java程序中的所有字符串文字都被实现为此类的实例。
所有的双引号字符串都是String类的对象。
String类在java.lang包下，所以无需导包即可使用。

- 特点：
  - 字符串不可变，值在创建后不可以更改
  - 值可以被共享
  - 效果上相当于字符数组（char[]），但底层原理是字节数组（byte[]）

- 通过构造方法创建字符串
	通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同

- 直接赋值方式创建字符串
	以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护

- 字符串的比较
  - `==` 号
    - 对于基本数据类型，比较的是具体值
    - 对于引用数据类型（String类属于此类），比较的是对象地址值
  - `equal` 方法
	`boolean flag = s1.queal(s2);`可以比较字符串的内容是否相同（区分大小写）

charAt(int index): 根据索引获取相应的字符
length(): 返回字符串的长度
substring(int beginIndex,(int endIndex))：截取从beginIndex到endIndex（默认末尾）,左闭右开
replace(String goalStr, String needStr)：

### StringBulider类

StringBulider是一个可以变化的容器，运用于拼接字符串和反转字符串

```
StringBuilder sb = new StringBuilder();
sb.append(char, char[] ...);
sb.reverse();
```

### Arraylist类

集合：是一种长度可变，且添加数据  的时候不需要考虑索引，默认将数据添加到末尾的存储模型，智能存储引用数据类型

| 方法名                                | 说明                                   |
| ------------------------------------- | -------------------------------------- |
| public boolean add(要添加的元素)      | 将指定的元素追加到此集合的末尾         |
| public boolean remove(要删除的元素)   | 删除指定元素,返回值表示是否删除成功    |
| public E  remove(int index)           | 删除指定索引处的元素，返回被删除的元素 |
| public E   set(int index,E   element) | 修改指定索引处的元素，返回被修改的元素 |
| public E get(int   index)             | 返回指定索引处的元素                   |
| public int   size()                   | 返回集合中的元素的个数                 |

### JFrame类

`import javax.swing.JFrame;`导入JFrame包

```
//召唤主界面
JFrame jFrame = new JFrame();

//设置主界面的大小
jFrame.setSize(514,595);

//将主界面设置到屏幕的正中央
jFrame.setLocationRelativeTo(null);

//将主界面置顶
jFrame.setAlwaysOnTop(true);

//关闭主界面的时候让代码一起停止
jFrame.setDefaultCloseOperation(3);

//给主界面设置一个标题
jFrame.setTitle("拼图游戏单机版 v1.0");

//让主界面显示出来，必须写在最后
jFrame.setVisible(true);

//把管理容器加入界面
jFrame.add((JLabel)temp);

//获取jFrame对象中的隐藏控制组件容器
this.getContentPane();

//取消默认居中的布局方式
jFrame.setLayout(null);
```

坐标以左上角为原点，水平线为x轴，竖直线为y轴

### JMenuBar类

JMenuBar是整体，一个界面中一般只有一个JMenuBar。

而JMenu是菜单中的选项，可以有多个。

JMenuItem是选项下面的条目，也可以有多个。

```
//创建一个菜单对象
JMenuBar jMenuBar = new JMenuBar();
//设置菜单的宽高
jMenuBar.setSize(514, 20);
//创建一个选项
JMenu jMenu1 = new JMenu("功能");
//创建一个条目
jMenuItem1 = new JMenuItem("重新游戏");
//把条目添加到选项当中
jMenu1.add(jMenuItem1);
//把选项添加到菜单当中
jMenuBar.add(jMenu1);
//把菜单添加到最外层的窗体当中
this.setJMenuBar(jMenuBar);
```

### ImageIcon类

描述图片的类，可以关联计算中任意位置的图片，但是一般会把图片拷贝到当前项目中。
```
ImageIcon(String filename);创建对象，输入文件路径
```

### JLabel类

用来管理图片、文字的类，可以用来设置位置、宽高
```
//创建对象，传入ImageIcon类
JLabel((ImageIcon)temp);

//指定图片位置、大小
JLabel.setBounds(int x, int y, int width, int height);
```

先加载的图片在上面，后加载的在下面

### JButton类

```
//初始化按钮
JButton(String fileName);

//设置位置、大小
JButton.setBounds(int x, int y, int width, int height);

//添加动作事件监听（鼠标左键单击，空格），参数为事件被触发后要执行的代码
JButton.addActionListener();
//多结合匿名内部类
JButton.addActionListener(new ActionListener(){
	@Override
	public void actionPeformed(ActionEvent e){
		;
	}
});

//添加鼠标事件监听（滑入、按下、松开、划出）
JButton.addMouseListener();

//添加键盘事件监听（按下键、释放键、键入键）
JButton.addKeyListener();
```

### Math类

私有化构造方式，所有的方法都是静态的

```
//获得参数绝对值
public static int abs(int a);
//向上取整
public static double ceil(double a);
//向下取整
public static double floor(double a);
//四舍五入
public static int round(float a);
//取最大值
public static int max(int a,int b);
//取最小值
public static int min(int a,int b);
//返回a的b次幂
public static double pow(double a, double b);
//返回一个范围为 [0.0,1.0) 的随机数
public static double random();
//开平方根
public static double sqrt(double a);
//开立方根
public static double cbrt(double a);
```

### System类

```
//结束程序（0为正常停止，非0为异常停止）
public static void exit(int status);
//返回时间原点（1970.01.01.08:00:00）至今的毫秒数
public static long currentTimeMillis();
//数组拷贝
public static void arraycopy(数据源数组, 起始索引, 目的地数组, 起始索引, 拷贝个数);

//System：类名
//out：静态变量
//System.out：获取打印的对象
//println()：方法
//参数：表示打印的内容
```

### Runtime类

```
//获取当前系统的运行虚拟环境对象
public static Runtime getRuntime();
//停止虚拟机
public void exit();
//获得CPU的线程数
public int availableProcessors();
//JVM能从系统中获取总内存大小（单位byte）
public long maxMemory();
//JVM已经从系统中获取的内存大小（单位byte）
punlic long totalMemory();
//JVM剩余内存大小（单位Byte）
public long freeMemory();
//运行cmd命令
public process exec(String command);
```

### Object类

```
//创建对象
public Object();
//返回对象的字符串表达形式
public String toString();
//比较两个对象是否相等
public boolean equals(Object obj);
//对象克隆
protected Object clone(int a);
```

对于javabean类可以根据需求直接重写
默认的toString()方法是对地址值进行字符串化
默认的equals()方法是比较地址值是否相同

如果一个接口里面没有抽象方法，表示当前的接口是一个标记性接口`cloneable`，若当前接口一旦实现了，那么当前类的对象就可以被克隆，如果没有实现，当前类的对象就不能克隆

克隆对象需要：1、重写Object的clone方法；2、让javabean类实现Cloneable接口；3、创建原对象并调用clone就可以了

**浅克隆：**

​	不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来 

​	基本数据类型拷贝过来的是具体的数据，引用数据类型拷贝过来的是地址值。

​	Object类默认的是浅克隆

![浅克隆](img\Java_5.png)

**深克隆：**

​	基本数据类型拷贝过来，字符串复用，引用数据类型会重新创建新的

![深克隆](img\java_6.img)

### Objects类

工具类，存在于`java.util`包下，所以需要进行导入，且被`final`修饰即不可以被继承

```
// 获取对象的字符串表现形式
public static String toString(Object o)
// 先作非空判断，比较两个对象是否相等
public static boolean equals(Object a, Object b)
// 判断对象是否为null，为则返回true
public static boolean isNull(Object obj)
// 判断对象是否不为null，不为则返回true
public static boolean nonNull(Object obj)
```

### BigInteger类

处于`math`包下，需要进行导入

```
//获取随机大整数，范围：[0 ~ 2的num次方-1]
public BigInteger(int num, Random rnd)
//获取指定的大整数
public BigInteger(String val)
//获取指定进制的大整数
public BigInteger(String val, int radix)

//静态方法获取BigInteger的对象，内部有优化
public static BigInteger valueOf(long val)
```

若BigInteger表示的数字没有超过long的范围，可以使用静态方法获取
若超出long的范围，可以使用构造方法获取
对象一旦创建，BigInteger内部记录的值不能发生改变
只要进行计算都会产生一个新的BigInteger对象

```
//加法
public BigInteger add(BigInteger val)
//减法
public BigInteger subtract(BigInteger val)
//乘法
public BigInteger multiply(BigInteger val)
//除法
public BigInteger divide(BigInteger val)
//除法，获取商和余数
public BigInteger[] divideAndRemainder(BigInteger val)
//比较是否相同
public  boolean equals(Object x)
//次幂、次方
public  BigInteger pow(int exponent)
//返回较大值/较小值
public  BigInteger max/min(BigInteger val)
//转为int类型整数，超出范围数据有误
public  int intValue(BigInteger val)
```

### BigDecimal类

使用float或者double类型的数据在进行数学运算的时候，很有可能会产生精度丢失问题。

计算机底层在进行运算的时候，使用的都是二进制数据； 在程序中写了一个十进制数据 ，在进行运算的时候，计算机会将这个十进制数据转换成二进制数据，然后再进行运算，计算完毕以后计算机会把运算的结果再转换成十进制数据再展示；

如果数据是一个浮点类型的数据，有的时候计算机并不会将这个数据完全转换成一个二进制数据，而是将这个将其转换成一个无限的趋近于这个十进数的二进制数据

所以为了解决精度问题，引入了`BigDecimal`类，存在于`java.math`包下，使用时候需要进行引入

构造方法：
```
public BigDecimal(int val)
public BigDecimal(long val)
public BigDecimal(String val)
```

成员方法：
```
// 加法运算
public BigDecimal add(BigDecimal value)
// 减法运算
public BigDecimal subtract(BigDecimal value)
// 乘法运算
public BigDecimal multiply(BigDecimal value)
// 触发运算
public BigDecimal divide(BigDecimal value)
```

### Date类

`java.text.Date`

`public Date()`：从运行程序的此时此刻到时间原点经历的毫秒值,转换成Date对象，分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。

`public Date(long date)`：将指定参数的毫秒值date,转换成Date对象，分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。

`public long getTime()` 把日期对象转换成对应的时间毫秒值。

`public void setTime(long time)` 把方法参数给定的毫秒值设置给日期对象

### SimpleDateFormat类

`java.text.SimpleDateFormat`

该类实现了日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换

`public SimpleDateFormat(String pattern)`：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。

- `public String format(Date date)`：将Date对象格式化为字符串。

- `public Date parse(String source)`：将字符串解析为Date对象。

| 标识字母（区分大小写） | 含义 |
| ---------------------- | ---- |
| y                      | 年   |
| M                      | 月   |
| d                      | 日   |
| H                      | 时   |
| m                      | 分   |
| s                      | 秒   |

### Calendar类

`java.util.Calendar`类表示一个“日历类”，可以进行日期运算。它是一个抽象类，不能创建对象，我们可以使用它的子类：`java.util.GregorianCalendar`类

直接创建`GregorianCalendar`类
通过`Calendar`中的静态方法`getInstance()`来获取`GregorianCalendar`对象

月份范围为0~11
星期，日-六分别为1-7

```
\\获取日期对象
public final Date getTime()
\\给日历设置日期对象
public final setTime(Date date)
\\拿到时间毫秒值
public long getTimeInMillis()
\\给日历设置时间亳秒值
public void setTimeInMillis(long millis)
\\职日历中的某个字段信息
public int get(int field)
\\修改日历的某个字段信息
public void set(int field,int value)
\\为某个字段增加/减少指定的值
public void add(int field,int amount)
```

### ZoneId类

`java.time.ZoneId`

```
\\获取Java中支持的所有时区
static Set<string> getAvailableZoneIds()
\\获取系统默认时区
static ZoneId systemDefault()
\\获取一个指定时区
static Zoneld of(string zoneld)
```

### Instant类

时间戳
```
//获取当前时间的Instant对象(标准时间)
static Instant now()
//根据(秒/毫秒/纳秒)获取Instant对象
static Instant ofXxxx(long epochMilli)
//指定时区
ZonedDateTime atZone(ZoneIdzone)
//判断系列的方法
boolean isxxx(Instant otherInstant)
//减少时间系列的方法
Instant minusXxx(long millisToSubtract)
//增加时间系列的方法
Instant plusXxx(long millisToSubtract)
```

### ZoneDateTime类

```
\\获取当前时间的ZonedDateTime对象
static ZonedDateTime now()
\\获取指定时间的ZonedDateTime对象
static ZonedDateTime ofXxxx(...)
\\修改时间系列的方法
ZonedDateTime withXxx(时间)
\\减少时间系列的方法
ZonedDateTime minusXxx(时间)
\\增加时间系列的方法
ZonedDateTime plusXxx(时间)
```

### DateTimeFormatter类

```
\\获取格式对象
static DateTimeFormatter ofPattern(格式)
\\按照指定方式格式化
String format(时间对象)
```

### LocalDate类

### LocatTime类

### LocalDateTime类

### Duration类

### Period类

### ChronoUnit类

### Arrays类

### 包装类

Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类

| 基本类型 | 对应的包装类（位于java.lang包中） |
| -------- | --------------------------------- |
| byte     | Byte                              |
| short    | Short                             |
| int      | **Integer**                       |
| long     | Long                              |
| float    | Float                             |
| double   | Double                            |
| char     | **Character**                     |
| boolean  | Boolean                           |

JDK5自动装箱与自动拆箱

直接对包装类赋值、运算

- 包装类与字符串之间的转换

基本类型转换为String

- 方式一：直接在数字后加一个空字符串
- 方式二：通过String类静态方法valueOf()

将字符串转为基本类型

- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。
- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。
- **`public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。**
- **`public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。**
- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。
- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。
- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。

细节：获取Integer对象的时候不要自己new，而是采取直接赋值或者静态方法valueOf的方式

### Arrays类

```
//把数组拼接成一个字符串
public static String toString(数组)
//二分查找法查找元素
public staticint binarySearch(数组，查找的元素)
//拷贝数组
public static int[] copyOf(原数组,新数组长度)
//拷贝数组(指定范围)
public static int[]copyOfRange(原数组,起始索引,结束索引)
//填充数组
public static void fill(数组,元素)
//按照默认方式进行数组排序
public static void sort(数组)
//按照指定的规则排序
public static void sort(数组，排序规则)
```

`compare(T o1, T o2)`

形式参数：
`o1`表示无序序列中的每一个元素，`o2`表示有序序列中的元素

返回值：
负数：表示当前插入的元素小，放在前面
正数、0：表示当前插入的元素大，放在后面

### Collections类

```
public static <T> boolean addAll(Collection<T> c, T... elements)
//批量添加元素
public static void shuffle(List<?> list)
//打乱List集合元素的顺序
public static<T> void sort(List<T> list)
//对List集合元素进行排序
public static<T> void sort(List<T> list, Comparator<T> c)
//对List集合元素进行指定规则的排序
```