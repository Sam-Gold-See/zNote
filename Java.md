# Java

## 基础知识储备

### CMD 界面常见命令

|       操作       | 说明                                |
| :--------------: | :---------------------------------- |
|     盘符名称     | 盘符切换。E:回车，表示切换到 E 盘。 |
|       dir        | 查看当前路径下的内容。              |
|     cd 目录      | 进入单级目录。                      |
|      cd ..       | 回退到上一级目录。                  |
| cd 目录 1\目录 2 | 进入多级目录。                      |
|      cd \        | 回退到盘符目录。                    |
|       cls        | 清屏。                              |
|       exit       | 退出命令提示符窗口。                |
|      strat       | 打开文件                            |
|     ipconfig     | 查看本地 IP 地址                    |
|     ping IP      | 检查网络是否连接                    |

进入的目录带有中文、空格需要将目录使用双引号标记 cd "目录"

### Java 路径

绝对路径：

一定从盘符开始

相对路径：

相对当前项目，JAVA 中相对路径是**相对 JVM 的启动路径**的，对于简单的 JAVA 项目，其 JVM 是在项目名称下启动的

### Java 基础命令

在命令行环境中
先后输入以下指令来完成 编译+运行

```shell
javac + 文件名 + 后缀(编译java文件)
java + 文件名(运行编译后的java文件)
```

### Java 的三大平台

JavaSE、JavaME、JavaEE

#### JavaSE

是另两个版本的基础，主要用于开发桌面应用

#### JavaME

Java 语言的小型版本，用于嵌入式消费类电子设备或者小型移动设备的开发

#### JavaEE

用于 Web 方向的网站开发（主要从事后台服务器的开发）
服务器领域，Java 是龙头老大

### Java 的主要特性

- 面向对象
- 安全性
- 多线程
- 简单易用
- 开源
- 跨平台

### JRE 和 JDK

JVM（Java Virtual Machine），Java 虚拟机

JRE（Java Runtime Environment），Java 运行环境，包含了 JVM 和 Java 的核心类库（Java API）

JDK（Java Development Kit）称为 Java 开发工具，包含了 JRE 和开发工具

### IDEA

IDEA 全称为 Intellij IDEA，是用于 Java 语言开发的集成环境（IDE：把代码编写、编译、执行、调试等多种功能综合到一起的开发工具）

#### IDEA 中层级结构介绍

- 结构分类

  - Project（项目、工程）
    淘宝、京东等网站都属于一个个项目，IDEA 中就是一个个的 Project
  - module（模块）
    一个项目可以存放多个模块，不同的模块可以存放项目中不同的业务功能代码，如一个网站分成论坛模块，报名咨询模块等等
  - package（包）
    一个模块中有很多的细分业务，如一个论坛模块就包含了发帖、评论等不同的业务
  - class（类）
    真正的写代码地方

- 层级关系：project - module - package - class

## Java 基础语法

### 注释

注释是对代码的解释和说明文字，分为单行注释、多行注释和文档注释

- 单行注释

```java
// 这是单行注释文字
```

- 多行注释

```java
/*
这是多行注释文字
这是多行注释文字
这是多行注释文字
*/
```

- 文档注释

```java
/**

*/
```

### 关键字

被 Java 赋予了特定涵义的英文单词

- 特点：

1. 关键字的字母**全部小写**
2. 在常用的代码编辑器，有特殊高亮标记

#### class

用于（创建/定义）一个类，类是 Java 最基本的组成单元

### 字面量（常量）

字面量类型：

- 整数类型 int
- 小数类型 double
- 字符串类型 string
- 字符类型
- 布尔类型
- 空类型(null)

### 变量

在程序执行过程中，有可能变化的值

定义格式:

```
    数据类型 变量名 = 数据值;
```

### 数据类型

- 基本数据类型：

| 数据类型 | 关键字  | 内存占用 |                     取值范围                     |
| :------: | :-----: | :------: | :----------------------------------------------: |
|   整数   |  byte   |    1     |    负的 2 的 7 次方 ~ 2 的 7 次方-1(-128~127)    |
|          |  short  |    2     | 负的 2 的 15 次方 ~ 2 的 15 次方-1(-32768~32767) |
|          |   int   |    4     |        负的 2 的 31 次方 ~ 2 的 31 次方-1        |
|          |  long   |    8     |        负的 2 的 63 次方 ~ 2 的 63 次方-1        |
|  浮点数  |  float  |    4     |           1.401298e-45 ~ 3.402823e+38            |
|          | double  |    8     |          4.9000000e-324 ~ 1.797693e+308          |
|   字符   |  char   |    2     |                     0-65535                      |
|   布尔   | boolean |    1     |                   true，false                    |

定义 long 类型的数据，需要在数据值后方加一个 L 作为后缀
定义 float 类型的数据，需要在数据值后方加一个 F 作为后缀

### 标识符

标识符：就是给类，方法，变量等起的名字

- 必须由数字、字母、下划线\_、美元符号$组成。
- 数字不能开头
- 不能是关键字
- 区分大小写的。

小驼峰命名法用于：方法、变量

大驼峰命名法用于：类名

### 键盘录入

1. 导入`Scanner`这个类

```java
import java.util.Scanner;
```

2. 创建对象

```java
Scanner sc = new Scanner(System.in);
```

3. 接收数据

```java
int i = sc.nextInt();
```

4. 关闭对象

```java
sc.close();
```

方法：

1. next(), nextLine(): 可以接受任何数据，但是都会返回一个字符串

2. nextInt()：只能接受一个整数

3. nextDouble()：能接受整数和小数，但是都会看做小数返回

细节：

1. next（），nextInt（），nextDouble（）在接收数据的时候，会遇到空格，回车，制表符其中一个就会停止接收数据，但是这些符号 + 后面的数据还在内存中并没有接收。如果后面还有其他键盘录入的方法，会自动将这些数据接收。

2. nextLine（）方法是把一整行全部接收完毕。

使用方法：

键盘录入分为两套：

- next（）、nextInt（）、nextDouble（）这三个配套使用。

  如果用了这三个其中一个，就不要用 nextLine（）。

- nextLine（）单独使用。

  如果想要整数，那么先接收，再使用 Integer.parseInt 进行类型转换。

### 运算符和表达式

运算符：就是对常量或者变量进行操作的符号。

表达式：用运算符把常量或者变量连接起来的，符合 Java 语法的式子就是表达式。

#### 算术运算符

```java
+ - * / %
```

1. 隐式转换：

- 取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算。
- byte、short、char 三种类型的数据在运算的时候，都会直接先提升为 int，然后再进行运算。

取值范围大小（从小到大）：

byte -> short -> int -> long -> float -> double

2. 强制转换：

书写格式：

```java
goalType variableName = (goalType) value;
```

会导致精度丢失

#### 字符串的 + 操作

- 当+操作中出现字符串时，此时就是字符串的连接符，会将前后的数据进行拼接，并产生一个新的字符串。
- 当连续进行+操作时，从左到右逐个执行的。

#### 自增自减运算符

```java
++ 自增运算符
-- 自减运算符
```

#### 赋值运算符

```java
=
+=
-=
*=
/=
%=
```

#### 关系运算符

```java
==
!=
>
>=
<
<=
```

#### 逻辑运算符

```java
&  -> &&(短路)
|  -> ||(短路)
^
!
<< 左移，低位补0
>> 右移，除符号位都补0
>>> 无符号右移，高位补0
```

#### 三元运算符

```java
关系表达式 ? 表达式1 : 表达式2 ;
```

### 判断和循环

#### 流程控制语句

1. 分类

- 顺序结构
- 判断和选择结构
- 循环结构

2. 顺序结构

按照代码的先后顺序依次执行

3. 判断结构

```java
if (关系表达式) {
    语句体 ;
}

if (关系表达式) {
    语句体1 ;
} else {
    语句体2 ;
}

if (关系表达式1) {
    语句体1 ;
} else if (关系表达式2) {
    语句体2 ;
}
...
else {
    语句体n+1;
}
```

4. 选择结构

```java
switch (表达式) {
	case 1:
		语句体1;
		break;
	case 2:
		语句体2;
		break;
	...
	default:
		语句体n+1;
		break;
}
```

- default 的位置和省略情况

  default 可以放在任意位置，也可以省略

- case 穿透

  不写 break 会引发 case 穿透现象

5. 循环结构

```java
for (初始化语句;条件判断语句;条件控制语句) {
	循环体语句;
}

while(条件判断语句){
	循环体;
	条件控制语句;
}

do{
    循环体;
    条件控制语句;
}while(条件判断语句);
```

### 数组

数组：指的是一种容器，可以同来存储同种数据类型的多个值。

定义格式：

```java
数据类型[] 数组名 -> int[] array
数据类型 数组名[] -> int array[]
```

#### 静态、动态初始化数组

格式：

```java
//静态
数据类型[] 数组名 = new 数据类型[]{元素1，元素2，元素3，元素4...};
->
int[] array = new int[]{1,2,3,4};

//动态
数据类型[] 数组名 = new 数据类型[数组的长度];
->
int[] array = new int[3];
```

解释：

- 数据类型：限定了数组以后能存什么类型的数据。
- 方括号：表示现在定义的是一个数组。
- 数组名：在起名字的时候遵循小驼峰命名法。
- new：给数组在内存中开辟一个空间
- 数据类型：限定数组能存什么类型的数据，前后数据类型要保持一致

#### 地址值（指针）

对于一个名为 array 的数组进行打印操作

```java
System.out.println(array);//address
```

输出的是数组的地址值，即表示数组在内存中的位置

#### 数组元素访问、索引、长度

```java
数组名[索引];   ->数组的内容

数组名.length;  ->数组的长度
```

#### 数组的内存

```java
int[] arr = new int[2];
sout(arr);//arr这个数组在堆内存中的地址值
sout(arr[0]);
```

### 方法

方法是程序中最小的执行单元，必须先创建才可以使用，该过程称为方法定义

#### 方法的定义和调用

- 无参数方法定义和调用

```java
定义：
public static void methodName (){
	// 方法体
}

调用：
methodName();
```

- 带参数方法定义和调用

```java
public static void methodName (values){
	方法体;
}
```

- 带返回值方法的定义和调用

```java
public static valueType methodName (value){
	return newValue;
}
```

#### 形参和实参

1. 形参：方法定义中的参数

2. 实参：方法调用中的参数

#### 方法重载

方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载

- 多个方法在同一个类中
- 多个方法具有相同的方法名
- 多个方法的参数不相同，类型不同或者数量不同

重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关
**不能通过返回值来判定两个方法是否相互构成重载**

#### 方法的值传

传递基本数据类型时，传递的是真实数据，形参的改变不影响实际参数的值

传递引用数据类型时，传递的是地址值，形参的改变影响实际参数的值

## 面向对象

### 类和对象

客观存在的事物皆为对象

- 类

  - 类的理解
    - 类是对现在生活中一类具有共同属性和行为的事物的抽象
    - 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合
    - 类是对现实事物的一种描述
  - 类的组成
    - 属性：指事物的特征
    - 行为：指事物能执行的操作

- 类和对象的关系
  - 类：对现实生活中一类具有共同属性和行为的事物的抽象
  - 对象：是能够看得到摸得着的真实实体
  - **类是对事物的一种描述，对象则为具体存在的事物**

### 类的定义

类的组成是由属性和行为两部分组成

- 属性：在类中通过成员变量来体现
- 行为：在类中通过成员方法来体现

```java
public class className{
	// 成员变量
	valueType value1;
	valueType value2;
	...
	// 成员方法
	...
}
```

### 对象的使用

- 创建对象的格式

```java
className objectName = new className();
```

- 调用对象的格式：

```java
objectName.memberName;
objectName.memberFunction();
```

### 类的类型

- **javabean 类**：用来描述一类事物的类（不写 main 方法）
- **测试类**：编写 main 方法的类
- **工具类**：私有化构造方法，静态化方法，使用类名调用方法

### 注意事项

- 类名首字母建议大写，需要见名知意，驼峰模式
- 一个 java 文件中可以定义多个 class 类，且只能一个类是 public 修饰，同时 public 修饰的类名必须成为代码名

### 封装

封装：**告诉用户如何正确设计对象的属性和方法**
对象代表什么，就得封装相应数据，并提供数据相应的行为

### private 关键字

**private**是一个权限修饰符，可以修饰成员（变量和方法），被其修饰的成员只能在本类中才能被访问

### this 关键字

由于变量遵循就近原则，使用 this 可以区分局部变量和成员变量

this 的本质：所在方法调用者的地址

```java
this.value
```

### 成员变量和局部变量

- 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）
- 内存中位置不同：成员变量（堆内存）局部变量（栈内存）
- 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）
- 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）

### 构造方法

格式：

```java
public class ClassName{
	修饰符 ClassName(value){

	}
}
```

功能：主要是完成对象数据的初始化

- 特点：
  - 方法名与类名相同，大小写也要一致
  - 没有返回值类型，连 void 都没有
  - 没有具体的返回值

### 标准类制作

- 类名需要见名知意
- 成员变量使用 private 修饰
- 提供至少两个构造方法
  1. 无参构造方法
  2. 带全部参数的构造方法
- get 和 set 方法
  ​ 提供每一个成员变量对应的 setXxx()/getXxx()
- 如果还有其他行为，也需要写上

### 对象内存图

Java 内存分配分为：栈、堆、方法区、本地方法栈、寄存器

方法区：存储可以运行的 class 文件

栈内存：方法运行时所进入的内存，方法进栈运行，运行完毕出栈

堆内存：new 出来的东西会在堆内存中开辟空间并产生地址

本地方法栈：JVM 在使用操作系统功能的时候使用

寄存器：给 CPU 使用，和开发无关

#### 一个对象的内存图

![测试代码](img/Java_1.png)

![内存存储展示](img/Java_2.png)

随着栈内存的方法逐渐使用完毕逐个 pop 出

#### 多个对象的内存图

![测试代码](img/Java_3.png)

![内存存储展示](img/Java_4.png)
其中的两个对象的`study()`方法都已经运行完成 pop 出栈

#### 两个引用指向同一个对象

```java
Student stu1 = new Student();
Student stu2 = stu1;

此时相当于两个指针（stu1,stu2）同时指向了一个地址值
```

### 基本数据类型和引用数据类型

基本数据类型：数据值是存储在自己的空间中，赋值给其他变量也是赋的真实的值

引用数据类型：数据值是存储在其他空间中，自己空间中存储的是地址值，赋值给其他变量赋的是地址值

### static 关键字

- 静态成员变量
  `static`关键字在 Java 开发中非常的重要，对于理解面向对象非常关键
  用来修饰的成员变量和成员方法是属于类的，放在静态区中
  没有被 static 修饰的成员变量和方法则是属于对象的

  被 static 修饰的成员变量，说明该变量是属于类的，直接使用类名访问即可，该变量称为**类变量**或者**静态成员变量**，直接使用类名访问即可，因为类只有一个，所以静态成员变量也只存在一份，使用**类名.变量名称**

- 实例变量
  无 static 修饰的成员变量属于每个对象，必须创建类的对象才可以访问，使用**对象.变量名称**

- 静态方法
  staitc 修饰成员方法，说明该方法属于类，称为**类方法**或者**静态方法**，直接使用类名访问，所有对象都可以共享这个方法,使用**类名.方法名称**即可

- 实例方法
  无 static 修饰的成员方法属于每个对象，该方法也叫做实例方法，所以必须创建对象才可以访问，使用**对象.实例方法**访问

对于 static 修饰的成员变量或者成员方法，即静态变量和静态方法，该类的每一个对象都**共享**同一个类和静态变量和静态方法，任何对象都可以更改静态变量的值或者访问静态方法

无 static 修饰的成员变量或者成员方法，即实例变量和实例方法，必须创建对象才能访问

static 修饰的变量、方法存储在静态区，随着类的加载而加载，且只加载一次，所以只有一份，节省内存，优先于对象存在

无 static 修饰的成员，是属于对象，对象有多少个他们就有多少份，且必须由对象调用

### 继承

多个类中存在相同属性和行为时，我们可以将这些内容内容单独抽取一个类，那么多个类无需再定义这些属性和行为，只需要**继承**那一个类就可以

其中，多个类可以称为**子类**，单独被继承的那一个类被称为**父类**、**超类**或者**基类**

- 定义：
  继承：就是子类继承父类的属性和行为，使得子类对象可以直接具有与父类相同的属性、相同的行为，子类可以直接访问父类中的**非私有**的属性和行为

- 特点：

  1.  提高了**代码的复用性**，减少代码冗余，相同代码重复利用
  2.  使类与类之间产生了关系
  3.  Java 只支持单继承，不支持多继承
  4.  一个类可以有多个子类
  5.  可以多层继承

- 格式：
  ```java
  class 父类{
  	...
  }
  class 子类 extends 父类{
  	...
  }
  ```

Java 是单继承的，一个类只能继承一个直接父类

继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用

子类不能继承父类的**构造方法**，但是子类可以继承父类的私用成员，只是无法直接访问，需要通过 getter/setter 方法来访问父类的 private 成员变量

- 成员变量

  子类和父类中的成员变量出现重名，此时的访问是有影响的，子类会优先访问自己对象中的成员变量，如果想要访问父类的同名成员变量，可以使用**super**关键词

  同**shit**，**super**代表的是父类对象的引用，**this**代表的是当前对象的引用

- 成员方法

  子类父类中出现重名的成员方法，则创建子类的对象调用该方法的时候，子类对象会优先调用自己的方法

- 方法重写

  子类出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写，**声明不变，重新实现**，子类方法覆盖父类方法，必须保证权限大于等于父类权限，返回值类型、函数名和参数列表必须一模一样

- @Override 重写注解

  在重写方法前面加上该注解，一方面可以提高代码的可读性，一方面可以防止重写出错

- 构造方法

  继承后，子类工作方法器特点：子类所有构造方法的第一行都会默认先调用父类的无参构造方法，子类构造方法的第一行都隐含了`super()`去调用父类无参数构造方法，`super()`可省略

-`super()和this()`

```java
	this.成员变量
	super.成员变量

	this.成员方法名()
	super.成员方法名()

	this(...)
	super(...)
```

**super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现**

使用`super(...)`可以调用父类构造方法初始化继承自父类的成员变量的数据
使用`this(...)`可以调用本类中其他的构造方法

### 多态

**多条是继封装、继承之后，面向对象的第三大特性**
**多态出现于继承或者实现关系中**

多态体现的格式：

```java
父类类型 变量名 = new 子类/实现类构造器;
变量名.方法名()
```

**多态的前提**：有继承关系，子类对象是可以赋值给父类类型的变量。

使用多态后，对于方法的形参可以定义为共同的父类

```java
class Person{}
class Student extends Person{}
class Teacher extends Person{}
...
public void register(Person p){
	p.show();
}
...
register(Person p);
register(Student s);
register(Teacher t);
```

#### 多态的定义和前提

**多态**：是指同一行为，具有多个不同表现形式。

前提：

1. 有继承或实现关系
2. 方法的重写（不重写没有意义）
3. 父类引用指向子类对象

> 父类类型：指子类对象继承的父类类型，或者实现的父接口类型

#### 多态的运行特点

调用成员变量/成员方法：编译看左边，运行看右边

#### 多态的弊端

多态的编译阶段是看左边父类类型的，若子类独有（非从父类处重写），此时多态的写法无法访问子类独有功能。

#### 引用类型转换

**多态写法无法访问子类独有功能**

多态的转型氛围**向上转型（自动转型）** 和 **向下转型（强制转型）**

- 向上转型：
  多态本身是子类类型向父类类型向上转换的过程

  父类类型相对于子类来说是大范围的类型，子类范围小的可以直接自动转型给父类类型的变量

- 向下转型：
  一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式

  所以，为了调用子类特有的方法，必须进行向下转型

#### instanceof 关键字

```java
变量名 instanceof 数据类型
```

如果变量属于该数据类型或者其子类类型，返回 true
如果变量不属于该数据类型或者其子类类型，返回 false

在 JDK14 时提出新特性，将判断和强制转换合并效果

### 包

包在操作系统中其实就是一个文件夹。**包是用来分门别类的管理技术，不同技术类放在不同的包下**，方便管理和维护

命名规范：

```
路径名.路径名.xxx.xxx
```

- 需要导包的情况

在使用 Java 中提供的非核心包中的类时，使用自己写的其他包中的类，此时需要导包

- 不需要导包的情况

在使用 Java 核心包(Java.lang)中的类时，使用自己写的同一个包中的类时，此时不需要导包

### 权限修饰符

- public：公共的，所有地方都可以访问。

- protected：本类 ，本包，其他包中的子类都可以访问。

- 默认（没有修饰符）：本类 ，本包可以访问。

  注意：默认是空着不写，不是 default

- private：私有的，当前类可以访问。
  `public > protected > 默认 > private`

- 成员变量使用`private` ，隐藏细节。
- 构造方法使用`public` ，方便创建对象。
- 成员方法使用`public` ，方便调用方法。

### final 关键字

Java 提供了`final`关键字，表示修饰的内容不可变

- **final**：不可改变，可以用于修饰类、方法和变量
  - 类：被修饰的类不能被继承
  - 方法：被修饰的方法不能被重写
  - 变量：被修饰的变量有且仅能被赋值一次

```java
final class 类名{
}

修饰符 final 返回值类型 方法名(参数列表){
}

final 基本类型 变量名 = 值;
```

被 final 修饰的常量名称，一般都有书写规范，所有字母都**大写**

## 抽象类

把没有方法体的方法称为抽象方法。
Java 语法规定，包含抽象方法的类就是抽象类。

- 抽象方法：没有方法体的方法
- 抽象类：包含抽象方法的类

### abstract 关键字

用于修饰方法和类，修饰的方法是抽象方法，修饰的类是抽象类

- 抽象方法
  `修饰符 abstract 返回值类型 方法名 (参数列表);`

- 抽象类
  `abstract class 类名字{}`

### 抽象类使用方法

要求：继承抽象类的子类**必须重写父类所有的抽象方法**，否则子类也得声明为抽象类。

子类对父类抽象方法的完成时吸纳，将这种方法重写的操作，叫做**实现方法**

### 抽象类的特征

**有得有失**
有得：抽象类得到了拥有抽象方法的能力
有失：抽象了失去了创建对象的能力

### 抽象类的袭击

- 抽象类不能**创建对象**，只能创建其非抽象子类的对象

  > 假设创建了抽象类的的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义

- 抽象类可以有构造方法，是供子类创建对象时，初始化父类成员

  > 子类的构造方法中，有默认的 super()，需要访问父类的构造方法

- 抽象类中不一定包含抽象方法，但有抽象方法的类必定是抽象类

  > 未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类的结构设计

- 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则子类也必须定义为抽象类，编译无法通过而报错

  > 假设不重写所有的抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象方法，没有意义

- 抽象类存在的意义就是被子类继承

  > 抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现

## 接口

接口是**更加彻底**的抽象，在 JDK7 及其之前，接口中全部都是抽象方法。
接口同样是不能创建对象的

定义格式：

```java
public interface 接口名称{
	// 抽象方法
}
```

成分特点：接口中只有抽象方法和常量

### 接口中的抽象方法

接口中的抽象方法默认会自动加上`public abstract`修饰
按照规范：以后接口中的抽象方法建议不要写`public abstract`

### 接口中的常量

在接口中的常量的成员变量默认会加上：`public static final`，也就是说接口中定义的成员变量实际上是一个常量，被修饰后，变量值不可以被修改；同时静态化的变量可以直接用接口名访问
常量必须要给初始值，建议字母圈大写，单词间下划线链接

### 基本实现

类与接口的关系为实现关系，即**类实现接口**，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用`implements`关键字

#### 实现接口的格式

```java
接口的实现：
在Java中接口是被实现的，实现接口的类被称为实现类
class 类名 implements 接口1，接口2，接口3...{

}
```

#### 类实现接口的要求和意义

1. 必须重写实现的全部接口中所有抽象方法
2. 如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类必须定义成抽象类
3. 意义：接口实现体现得是一种**规范**，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类，这是一种**强制性的规范**

- 接口与接口的多继承

一个接口可以同时继承多个接口：

- 类与接口是实现关系
- 接口与接口是继承关系

接口继承接口就是，把其他接口的抽象方法与本接口进行了合并

```java
public interface A extends B,C{
}
```

#### 接口的细节

1. 当两个接口中存在相同的抽象方法时候，怎么办？

   > 只要重写一次就可以，此时的重写，既表示重写接口 1 的，也表示重写接口 2 的

2. 实现类能不能继承 A 类的时候，同时实现其他接口呢？

   > 实现类可以继承一个抽象类的同时，在实现其他多个接口，只不过要把里面所有的抽象方法全部重写

3. 实现类能不能继承一个抽象类的时候，同时实现其他接口呢？

   > 实现类可以继承一个抽象类的同时，在实现其他多个接口，只不过要把里面所有的抽象方法全部重写

4. 实现类 Zi，实现了一个接口，还继承了一个 Fu 类。假设再接口中有一个方法，父类有一个同样的方法，子类应该如何操作

   > 一：如果父类中的方法体可以满足业务需求，在子类中可以不用重写

   > 二：如果父类中的方法体不可以满足业务需求，在子类中需要重写

5. 如果一个接口中有 10 个抽象方法，但我在实现类只需要使用一个，该怎么办？

   > 可以在接口和实现类中间，新建一个中间类（适配器类）

   > 让这个适配器类趋势线接口，对接口里面所有的方法做空重写

   > 让子类继承这个适配器类，想要用到那个方法就重写哪个方法

   > 中间类没有实际意义，一般定义为抽象类，不让外界创建对象

## 内部类

讲一个类 A 定义在另一个类 B 里面，里面的那个类 A 就称为**内部类**，B 则为**外部类**
当事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用（人体内有心脏，汽车内有发动机）

### 分类

按照定义的位置来份

1. 成员内部类，类定义在了成员位置（类中方法外称为成员位置，无 static 修饰的内部类）

2. 静态内部类，类定义在了成员位置（类中方法外称为成员位置，有 static 修饰的内部类）

3. 局部内部类，定义在了方法内

4. 匿名内部类，没有名字的内部类，可以在类内任意地方

### 成员内部类

特点：

- 无 static 修饰的内部类，属于外部类对象的
- 宿主：外部对象

使用格式：`外部类.内部类`

获取成员内部类对象的两种方式：

1. 外部直接创建成员内部类的对象

`外部类.内部类 变量 = new 外部类(). new 内部类()`

2. 外部类中定义一个方法提供内部类对象

```java
public class Outer{
	private class Inner{}
	public Inner getInner{
		return new Inner();
	}
}

public class Demo{
	public static void main(String[] args){
		Outer o = new Outer();
		Inner i = o.getInner();
	}
}
```

细节：

1. 成员内部类可以被一些修饰符所修饰，如：`private`，`public`，`protected`
   > 若内部类被`private`修饰，外界无法直接获取内部类的对象，只能通过外部类的相关函数获得；若是其他修饰词，一般直接使用直接引用获取对象
2. 成员内部类里面，JDK16 及其之后才能定义静态变量
3. 创建内部类对象时，对象中有一个隐含的`外部类名.this`记录外部类对象的地址值（在内部类调用外部类）
   > 你不累如果想要访问外部类的成员变量，外部类的变量必须使用 final 修饰（JDK8 后默认加上）

### 静态内部类

特点：

- 静态内部类是一种特殊的成员内部类
- 有 static 修饰，属于外部类本身
- 静态类内部类与其他类使用方法一样，只是访问时需要使用`外部类.内部类`
- 静态内部类可以直接访问外部类的静态成员
- 静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象

使用格式：
`外部类.内部类`

静态内部类的创建格式：
`外部类.内部类 变量 = new 外部类.内部类构造器;`

调用方法的格式：

- 调用非静态方法的格式：先创建对象，用对象调用
- 调用静态方法的格式：外部类名.内部类名.方法名()

### 局部内部类

定义在方法中的类

### 匿名内部类

**匿名内部类**：是内部类的简化写法，他是一个隐含了名字的内部类

格式：

```java
new 类名或者接口名(){
	重写方法
};
```

包含了继承或者实现关系、方法重写、创建对象

若希望定义一个只要使用一次的类，就可以考虑到匿名内部类，匿名内部类的本质作用是为了简化代码。

匿名内部类必须**继承一个父类**或者**实现一个父接口**

匿名内部类格式：

```java
new 父类名或者接口名(){
	//方法重写
	@Override
	public void method(){
		//执行语句
	}
}
```

特点：

1. 定义一个没有名字的内部类
2. 这个类实现了父类，或者父类接口
3. 匿名内部类会创建这个没有名字的类的对象

### GUI

GUI(Graphical User Interface)图形用户接口

采取图形化的方式显示操作界面

相关内容存储在 Swing 包（AWT 包过老不利于兼容）

## 正则表达式

`regex`：正则表达式就是用来验证各种字符串的规则。它内部描述了一些规则，我们可以验证用户输入的字符串是否匹配这个规则、在一段文本中查找满足要求的字符串

- 字符类：

1. [abc]：代表 a 或者 b，或者 c 字符中的一个。
2. [^abc]：代表除 a,b,c 以外的任何字符。
3. [a-z]：代表 a-z 的所有小写字符中的一个。
4. [A-Z]：代表 A-Z 的所有大写字符中的一个。
5. [0-9]：代表 0-9 之间的某一个数字字符。
6. [a-zA-Z0-9]：代表 a-z 或者 A-Z 或者 0-9 之间的任意一个字符。
7. [a-dm-p]：a 到 d 或 m 到 p 之间的任意一个字符。

- 预定义字符：

1. "." ： 匹配任何字符。（`"."`表示任意字符，`\\.`表示仅匹配 . ）
2. "\d"：一个任何数字[0-9]的简写；
3. "\D"：任何非数字[^0-9]的简写；
4. "\s"： 一个空白字符：[\t\n\x0B\f\r] 的简写
5. "\S"： 非空白字符：[^\s] 的简写
6. "\w"：单词字符：[a-zA-Z-0-9]的简写
7. "\W"：非单词字符：[^\w]

- 逻辑运算符

1. &&：并且
2. |：或者
3. \：转义字符

- 数量词

1. X? 一次或 0 次
2. X\* 零次或多次
3. X+ 一次或多次
4. X{n} 正好 n 次
5. X{n,} 至少 n 次
6. X{n,m} 至少 n 次但不超过 m 次

特殊标志、非捕获分组：

1. `(?i)`表示从此开始的后面组内，不区分大小写匹配
2. `(?=)`问号代指前面的匹配内容，等号后面跟上需要匹配的内容，但是不输出
3. `(?:)`问号代指前面的匹配内容，冒号后面跟上需要匹配的内容，保持输出
4. `(?!)`问号代指前面的匹配内容，感叹号后面跟上不能匹配的内容
5. `\\组号`在正则表达式内部，表示把第 x 组内容再拿出来用一次
6. `$组号`在正则外部使用，表示把第 x 组内容再拿出来用一次

贪婪爬取和非贪婪爬取：

1. 默认贪婪匹配
2. 非贪婪匹配：在数量词后面加`?`

使用括号进行分组

```java
//判断是否满足正则表达式的规则
public String[] matches(String regex);
//按照正则表达式的规则替换
public String replaceAll(String regex, String newStr);
//按照正则表达式的规则切割字符串
public String[] split(String regex);
```

### 爬取数据

```java
java.util.regex.Pattern
java.util.regex.Matcher

Pattern p = Pattern.compile(regex:"");
Matcher m = p.matcher(str);

while(m.find()){		//.find()返回boolean
	String s = m.group();
}
```

## Lambda

函数式编程思想，JDK 8 后开始的新语法

可以简化匿名内部类的书写，只能简化函数式接口的匿名内部类

删除其他，保留参数列表
`(T o1, T o2)->{}`

函数式接口：有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加`@FunctionalInterface`注解

## 集合

集合的体系结构：单列集合、双列集合（每次添加数据的个数划分）

单列集合：

- Collection

  - List

    - ArrayList
    - LinkedList

  - Set
    - TreeSet
    - HashSet
      - LinkedHashSet

List 系列的特点：

- 有序
- 可重复
- 有索引

Set 系列的特点：

- 无序
- 不重复
- 无索引

```java
\\添加元素
boolean add(E e)
\\从集合中移除指定的元素
boolean remove(Object o)
\\根据条件进行移除
boolean removeIf(Object o)
\\清空集合中的元素
void clear()
\\判断集合中是否存在指定的元素
boolean contains(Object o)
\\判断集合是否为空
boolean isEmpty()
\\集合的长度，也就是集合中元素的个数
int size()
```

contains 方法的底层是以来 equals 方法进行判断的，如果集合存储的是自定义对象，需要在 javabean 类中重写 equals 方法

### 数据结构

- 栈：后进先出、先进后出
- 队列：先进先出，后进后出
- 数组：查询快、增删慢
- 链表：查询慢、增删快；节点是独立的对象，在内存中不连续，节点包含数据值和下一个节点的地址

### Iterator 迭代器

Collection 集合获取迭代器

`Iterator<T> it = iterator()`返回迭代器对象，默认只想当前集合的 0 索引

迭代器遍历的时候禁止使用集合的方法增删改，使用`Iterator<T>.remove()`来进行删除

Iterator 的常用方法

```java
//判断当前位置是否有元素，有元素返回true，没有元素返回false
boolean hasNext()
//获取当前位置的元素，并将迭代器对象移向下一个位置
Iterator<T>.next()
```

### Collection

Collection 是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的

- 迭代器遍历

- 增强 for 遍历

> 所有的单列集合和数组才能用增强 for 遍历
> 修改在增强 for 中的变量不会改变集合中原本的数据

- lambda 方法遍历

  `Collection.forEach((value)->{});`

#### List

```java
//在此集合中的指定位置插入指定的元素
void add(int index,E element)
//删除指定索引处的元素，返回被删除的元素
E remove(int index)
//修改指定索引处的元素，返回被修改的元素
E set(int index,E element)
//返回指定索引处的元素
E get(int index)
```

当方法被调用时候出现了重载现象，优先调用实参和形参类型一致的那个方法

列表迭代器遍历

```java
ListIterator<T> it = list.listIerator();

it.add();//列表迭代器专属
it.remove();
```

#### ArrayList

底层原理：

1. ArrayList 是数组结构
2. 空参创建的集合，在底层创建一个默认长度为 0 的数组
3. 添加第一个元素时，底层会创建一个新的长度为 10 的数组
4. `size()`既表示元素的个数也表示下个存入数据的索引
5. 存满时会扩容 1.5 倍（1 个个填入）
6. 若一次添加多个元素，1.5 倍仍放不下，则新创建数组的长度以实际为准

#### LinkedList

底层数据结构是双向链表，查询慢、增删快，但只对首尾操作，速度极快

```java
\\在该列表开头插入指定的元素
public void addFirst(E e)
\\将指定的元素追加到此列表的末尾
public void addLast(E e)
\\返回此列表中的第一个元素
public E getFirst()
\\返回此列表中的最后一个元素
public E getLast()
\\从此列表中删除并返回第一个元素
public E removeFirst()
\\从此列表中删除并返回最后一个元素
public E removeLast()
```

底层原理：

1. 刚开始创建的时候，底层创建了两个变量：一个记录头结点 first，一个记录尾结点 last，默认为 null
2. 添加第一个元素时，底层创建一个结点对象，first 和 last 都记录这个结点的地址值
3. 添加第二个元素时，底层创建一个结点对象，第一个结点会记录第二个结点的地址值，last 会记录新结点的地址值

迭代器分析：

```java
//获取一个迭代器对象
Iterator<E> iterator()
//判断当前指向的位置是否有元素
boolean hasNext()
//获取当前指向的元素并移动指针
E next
```

### 数据结构-树

每一个节点存储（父节点地址、值、左子节点地址、右子节点抵制）

度：每一个节点的子节点个数

二叉树：任意节点的度<=2

树高：树的总层数

根节点：最顶层的节点

左子节点：左下方的节点

右子节点：右下方的节点

根节点的左子树：以根节点的左子节点作根节点构成的树

根节点的右子树：以根节点的右子节点作根节点构成的树

#### 二叉查找树

- 每一个节点最多有两个子节点
- 任意节点左子树上的值都小于当前节点
- 任意节点右子树上的值都大于当前节点

##### 添加节点

1. 小的存左边
2. 大的存右边
3. 一样的不存

##### 查找节点

1. 小了往左查
2. 大了往右查

##### 遍历二叉树

- 前序遍历
  - 从根节点开始，按照**当前节点**，先**左子节点**，再**右子节点**
- 中序遍历（从小到大）
  - 从最左边的子节点开始，先**左子节点**，再**当前节点**，再**右子节点**
- 后序遍历
  - 从最左边的子节点开始，先**左子节点**，再**右子节点**，最后**当前节点**
- 层序遍历
  - 从根节点开始，一层一层的遍历

##### 弊端

容易退化成链表

#### 平衡二叉树

**任意节点**左右子树高度差不超过 1

##### 旋转

触发时机：当前二叉树不再是平衡二叉树的时候触发

1. 左旋

   - 从新加入节点开始，以不平衡的点作为支点
   - 将支点的右侧往左拉
   - 原先的右子节点成为新父节点，并把多余的左子节点出让给降级节点充当右子节点

2. 右旋

   - 从新加入节点开始，以不平衡的点作为支点
   - 将支点的左侧往右拉
   - 原先的左子节点成为新父节点，并把多余的右子节点出让给降级节点充当左子节点

##### 破坏平衡二叉树的情况

1. 左左（一次右旋）：当根节点左子树的左子树有节点插入，导致二叉树不平衡
2. 左右（先局部左旋，再整体右旋）：当根节点左子树的右子树有节点插入，导致二叉树不平衡
3. 右右（一次左旋）：当根节点右子树的右子树有节点插入，导致二叉树不平衡
4. 右左（先局部右旋，再整体左旋）：当根节点右子树的左子树有节点插入，导致二叉树不平衡

#### 红黑树

**二叉查找树**的一种

每一个节点可以是红或者黑

红黑树不是高度平衡的，是通过红黑规则实现平衡

- 规则：
  1. 每一个节点或是红色或是黑色
  2. 根节点必须是黑色
  3. 如果一个节点没有子节点或者父节点，则该节点相应的指针属性为 Nil，这些 Nil 视为叶节点,每个叶节点(Nil)是黑色的
  4. 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况)
  5. 对每一个节点,从该节点到其所有后代叶节点的简单路径（不回头）上,均包含相同数目的黑色节点

##### 添加节点

默认红色（效率更高）

- 红黑树添加节点后如何保持红黑规则：

  - 根节点位置： - 直接变为黑色
    - 非根节点位置：
      - 父节点为黑色： - 默认红色
      - 父节点为红色：
        _ 叔叔红色 1. 将父节点设为黑色，将叔节点设为黑色 2. 将祖父节点设为红色 3. 如果祖父节点为根节点，再将根节点变为黑色 4. 如果祖父非根节点，将祖父设置为当前节点再进行判断
        _ 叔叔黑色且父节点的右孩子 1. 把父节点作为当前节点并左旋，再判断 \* 叔叔黑色且父节点的左孩子
        1. 将父节点设为黑色
        2. 将祖父节点设为红色
        3. 以祖父节点为支点右旋

### Set 集合

- 无序
- 不重复
- 无索引

Set 接口中的方法基本和 Collection 的 API 一致

#### HashSet

集合底层采用哈希表存储数据，哈希表是一种对增删改查数据性能都较好的结构

创建一个默认长度 16 默认扩容因子 0.75 的数组，当元素数量达到 数组长度\*扩容因子 个数后，自动扩容一倍

JDK8 后，数组+链表+红黑树（当链表长度超过 8，数组长度大于等于 64，自动转换为红黑树）

同哈希新元素挂在老元素下面

集合中存储的是自定义对象，必须要重写 hashCode 和 equals 方法

哈希值：对象的整数表达形式

- 根据 hashCode 方法算出来的
- 定义在 Object 类中，所有对象都可以调用，默认使用地址值计算
- 一般情况下，都会重写 hashCode 方法，利用对象内部属性值计算哈希值
- 小部分情况，不同属性值或者不同地址值计算出来的哈希值一致（哈希碰撞）

- HashSet 为什么存取顺序不一
  > 在遍历 HashSet 的时候是根据数组+链表/红黑树 顺序来遍历，不能保证取顺序和存一致
- HashSet 为什么没索引
  > HashSet 由数组+链表+红黑树，无法分清楚索引
- HashSet 是利用什么机制保证数据去重
  > HashCode 和 equals 方法

#### LinkedHashSet

有序、不重复、无索引

底层数据结构依然是哈希表，又额外增加双链表的机制记录存储的顺序

#### TreeSet

不重复、无索引、可排序

基于红黑树的数据结构实现

默认从小到大顺序排序

##### TreeSet 的两种排序比较方式

- 默认排序/自然排序：Javabean 类实现 Comparable 接口指定比较规则，重写 compareTo 方法，返回值为负数，添加元素小；返回值为正数，添加元素大；返回值为 0，添加元素已存在，舍弃（o 为已存在的元素，this 要添加的元素）

```java
public class Person implements Comparable<Person> {

    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Person o) {
        if (this.age > o.age) {
            return 1;
        } else if (this.age < o.age) {
            return -1;
        } else {
            return 0;
        }
    }
}
```

- 比较器排序：用 TreeSet 集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的，让集合构造方法接收 Comparator 的实现类对象，重写 compare(T o1,T o2)方法，重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写

```java
TreeSet<Person> treeSet = new TreeSet<>(new Comparator<Person>() {
    @Override
    public int compare(Person o1, Person o2) {
        if (o1.age > o2.age) {
            return 1;
        } else if (o1.age < o2.age) {
            return -1;
        } else {
            return 0;
        }
    }
});

treeSet.add(new Person("Tom", 20));
treeSet.add(new Person("Jack", 25));
treeSet.add(new Person("Lily", 20));
treeSet.add(new Person("Tom", 25));

System.out.println(treeSet);
//输出：[Person{name='Jack', age=25}, Person{name='Lily', age=20}, Person{name='Tom', age=25}]
```

### 集合使用环境

- 集合中元素可重复，用基于数组的 ArrayList
- 集合中元素可重复，且增删多余查询，用基于链表的 LinkedList
- 集合中元素不可重复，用基于哈希表的 HashSet
- 集合中元素不可重复，且保证存取顺序，用基于哈希表和双链表的 LinkedHashList
- 集合中的元素不可重复，且需要排序，用基于红黑树的 TreeList

### 双列集合特点

特点：

1. 双列集合一次需要存一对数据，分别为键和值
2. 键不能重复，值可以重复
3. 键和值是一一对应的，每一个键只能找到自己对应的值
4. 键+值这个整体我们称之为“键值对”或者“键值对对象”，在 Java 中叫做“Entry 对象”

#### Map

常见 API：

```java
//添加元素
V put(K key,v value)
//根据键删除键值对元素
V remove(object key)
//移除所有的键值对元素
void clear()
//判断集合是否包含指定的键
boolean containsKey(0bject key)
//判断集合是否包含指定的值
boolean containsValue(object value)
//判断集合是否为空
boolean isEmpty()
//集合的长度，也就是集合中键值对的个数
int size()
```

遍历方式：

1. 键找值
   `Set<> keysSet()`，该方法返回一个由键组成的单列集合，遍历单列集合

2. 键值对
   `Set<Map.Entry<T(key), T(value)>> entrySet()`，该方法返回一个键值对集合

3. Lambda
   `forEach()`重写

#### HashMap

特点：无序、不重复、无索引

底层由哈希表结构实现

#### LinkedHashMap

特点：有序、不重复、无索引

底层由哈希表+双链表结构实现

#### TreeMap

特点：不重复、无索引、可排序

底层由红黑树结构实现

#### 键值对

- 键值对的添加：`put(key,value)`
- 键值对的删除：`remove(key)`
- 键值对的修改：`put(key,value)`
- 键值对的查询：`get(key)`
- 键值对的遍历：`keySet()`

#### 可变参数

可变参数：在方法定义时，使用“…”表示该方法可以接受多个参数，参数类型为 Object[]。

```java
public void test(Object... args){
    for(Object obj : args){
        System.out.println(obj);
    }
}
```

细节：

1. 可变参数只能作为最后一个参数，且只能有一个

### 泛型

泛型用于约束集合中存储元素的数据类型，本质是将类型参数化
若无泛型，`ArrayList`类在输入不同类型数据的时候仍可以通过编译，但是会在运行时候报错，加入泛型限制数据类型之后，可以使得输入不同类型数据的时候使得编译失败

使用`< 类型参数 >`使得代码操作的数据类型明显，提高了代码的可读性

JDK5 引入特性，可以在编译阶段约束操作的数据类型并且进行检查，只能填写引用数据类型

格式：
`<数据类型>`

好处：

- 避免了强制类型转换
- 统一数据类型

Java 中的泛型是伪泛型

编译时候检查，传入转为 Object，传出转为泛型，此过程为泛型的擦除

可以传入子类类型，默认类型为 Object

#### 泛型类

当编写一个类的时候，如果不确定类型，可以下定义为泛型类

```java
修饰符 class 类名<类型>{

}
```

类型可以写成 T、E、K、V

#### 泛型方法

本方法的泛型只能在本方法中运用

```java
修饰符 <E> 返回类型 方法名(参数列表){

}
```

对于不确定个数的参数，可以使用`E...<arrayName>`传入，传入时仍然是`a,b,c,d`一个一个传入

#### 泛型接口

```java
修饰符 interface 接口名<类型>{

}
```

实现类给出具体类型

实现类延续泛型，创建对象时再确定泛型类型

#### 泛型的继承

泛型不具备继承性，限制什么类型只能传递什么类型

但是数据具备继承性

```java
ArrayList<Father> list1 = new ArrayList<>();
ArrayList<Son> list2 = new ArrayList<>();

// method(ArrayList<Father> list)

method(list1);
method(list2);//报错

list1.add(new Father());
list1.add(new Son());//数据具备继承性
```

#### 泛型的通配符

```java
//? extends E:表示可以传递E或者E所有子类类型
//? super E:表示可以传递E或者E所有父类类型
```

限定类型范围

### 不可变集合

是一个长度不可变、内容也无法修改的集合

如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。

当集合对象被不可信的库调用时，不可变形式是安全的。

#### 分类

```java
static <E> List<E> of(E...elements)
//创建一个具有指定元素的不可变List集合对象
static <E> Set<E> of(E...elements)
//创建一个具有指定元素的不可变Set集合对象,需要保证唯一性
static <K,V> Map<K,V> of(E...elements)
//创建一个具有指定元素的不可变Map集合对象，需要保证键的唯一性，至多10个键值对
static <K,V> Map<K,V> copyOf(Map<K,V>)
//生成一个具有指定元素的不可变Map集合对象
```

## Stream 流

### Stream 流的三类方法：

1. 获取 stream 流：创建一条流水线，把数据放在流水线上准备进行操作
2. 中间方法：流水线上的操作、可以进行多次操作
3. 终结方法：一个 Stream 流只能有一个中介方法，是流水线上的最后一个操作

### 生成 Stream 的方法

- Collection 体系集合
  使用默认 stream()生成流，`default Stream <E stream()>`
- Map 体系集合
  把 Map 转成 Set 集合，间接的生成流
- 数组
  通过 Arrays 中的静态方法 stream 生成流
- 同种数据类型的多个数据
  通过 Stream 接口的静态方法`of(T..values)`生成流

```java
//Collection体系的集合可以使用默认方法stream()生成流
List<String> list = new ArrayList<String>();
Stream<String> stream = list.stream();
Set<String> set = new HashSet<String>();
Stream<String> stream = set.stream();

//Map体系的集合可以使用entrySet()方法生成流
Map<String,Integer> map = new HashMap<String,Integer>();
Stream<String> keyStream = map.keySet().stream();
Stream<Integer> valueStream = map.values().stream();
Stream<Map.Entry<String,Integer>> entryStream = map.entrySet().stream();

//数组可以通过Arrays.stream()方法生成流
int[] arr = {1,2,3,4,5};
Stream<int[]> stream = Arrays.stream(arr);

//同种数据类型的多个数据可以通过Stream.of(T...values)方法生成流
Stream<String> stream = Stream.of("a","b","c");
```

### Stream 流中间操作方法

- 概念：中间操作的意思是,执行完此方法之后,Stream 流依然可以继续执行其他操作

| 方法名                                          | 说明                                                        |
| ----------------------------------------------- | ----------------------------------------------------------- |
| Stream<T> filter(Predicate predicate)           | 用于对流中的数据进行过滤                                    |
| Stream<T> limit(long maxSize)                   | 返回此流中的元素组成的流，截取前指定参数个数的数据          |
| Stream<T> skip(long n)                          | 跳过指定参数个数的数据，返回由该流的剩余元素组成的流        |
| static <T> Stream<T> concat(Stream a, Stream b) | 合并 a 和 b 两个流为一个流                                  |
| Stream<T> distinct()                            | 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流 |
| Stream<T> map(Function<T,R> mapper)             | 转换流中的数据类型                                          |

中间方法，返回新的 Stream 流，原来的 Stream 流只能使用一次且不会影响原本数据

### Stream 流终结方法

- 概念：终结方法的意思是,执行完此方法之后,Stream 流就被使用完毕,不能再使用其他方法

| 方法名                                   | 说明                       |
| ---------------------------------------- | -------------------------- |
| void forEach(Consumer<? super T> action) | 遍历                       |
| long count()                             | 返回流中元素的个数         |
| toArray()                                | 收集流中的数据，放到数组中 |
| collect()                                | 收集流中的数据，放到集合中 |

## 方法引用

概念：把已经有的方法拿过来用，当做函数式接口中抽象方法的方法体

要求：

1. 引用处必须是函数式接口
2. 被引用方法必须已经存在
3. 被引用方法的形参和返回值必须要跟抽象方法保持一致
4. 被引用方法的功能要满足当前需求

### 引用类方法

格式：`类名::静态方法名`

方法引用符`::`的左边是类名，右边是方法名

### 引用成员方法

格式：`对象名::成员方法名`

方法引用符`::`的左边是对象名，右边是方法名

### 引用构造方法

格式：`类名::new`

方法引用符`::`的左边是类名，右边是 new 关键字，可以用来创建对象

## 异常

**异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致 JVM 的非正常停止。

在 Java 等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java 处理异常的方式是中断处理。

> 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行

### 异常体系分类

异常机制其实是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`

Throwable 体系：

- **Error**:严重错误 Error，无法通过处理的错误，只能事先避免，好比绝症，与开发者无关。
- **Exception**:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。

Exception 体系：

- **RuntimeException**:运行时异常，是程序运行过程中可能发生的异常，是可以预见的，是可以处理的。
- **其他异常**:受检异常，是程序运行过程中可能发生的异常，是必须要处理的。

### 异常的作用

- 异常是用来查询 bug 的关键参考信息
- 异常可以作为昂发内部的一种特殊返回值，以便通知调用者底层的执行情况

### Throwable 的成员方法

| 方法名                        | 说明                                                     |
| ----------------------------- | -------------------------------------------------------- |
| public String getMessage()    | 返回此 throwable 的详细消息字符串                        |
| public String toString()      | 返回此可爬出的简短描述                                   |
| public void printStackTrace() | 将异常的错误信息输出在控制台（仅打印信息，不会停止运行） |

### 抛出、捕获

- 抛出异常`throw`：写在方法内，结束方法，手动抛出异常对象交给调用者
  `throw new RuntimeException("异常信息");`

- 声明异常`throws`：写在方法声明处，声明方法可能抛出的异常，编译时异常必须要写
  `public void test() throws Exception{}`

- 捕获异常`try-catch-finally`：写在方法内，捕获异常对象，处理异常，在 finally 代码块中存放的代码都是一定会被执行的（除非 JVM 退出）

在`catch`中可以填写多个 catch 块来捕获**不同**的异常，若是多个异常间存在继承关系，那么子类异常需要在上面的 catch 块中写，否则会被父类异常块捕获。

### 自定义异常

1. 定义异常类
2. 写继承关系
3. 空参构造
4. 带参构造

## File

File 对象就表示一个路径，可以使文件的路径，也可以是文件夹的路径

这个路径可以是存在的，也允许不符你在

| 方法名                                   | 说明                                         |
| ---------------------------------------- | -------------------------------------------- |
| public File(String pathname)             | 根据路径名构造 File 对象                     |
| public File(String parent, String child) | 根据父路径字符串和子路径字符串构造 File 对象 |
| public File(File parent, String child)   | 根据父 File 对象和子路径字符串构造 File 对象 |

### 判断、获取功能

| 方法名                          | 说明                                     |
| ------------------------------- | ---------------------------------------- |
| public boolean isDirectory()    | 判断是否为目录                           |
| public boolean isFile()         | 判断是否为文件                           |
| public boolean exists()         | 判断文件或目录是否存在                   |
| public long length()            | 获取文件大小（字节），不能获取文件夹大小 |
| public String getAbsolutePath() | 获取绝对路径                             |
| public String getPath()         | 获取路径                                 |
| public String getName()         | 获取文件名，带后缀                       |
| public long lastModified()      | 获取最后修改时间（毫秒）                 |

### 创建、删除功能

| 方法名                         | 说明           |
| ------------------------------ | -------------- |
| public boolean createNewFile() | 创建文件       |
| public boolean mkdir()         | 创建目录       |
| public boolean mkdirs()        | 创建多级目录   |
| public boolean delete()        | 删除文件或目录 |

### 遍历功能

| 方法名                    | 说明                                   |
| ------------------------- | -------------------------------------- |
| public String[] list()    | 列出目录下的文件和目录                 |
| public File[] listFiles() | 列出目录下的文件和目录，返回 File 数组 |

## IO 流

File 类只能对文件本身进行操作，不能读写文件里面存储的数据内容，所以需要 IO 流来操作文件

IO 流：存储和读取数据的解决方案，用于读写文件中的数据

分类：

- **输入流**、**输出流**；
- **字节流**（所有类型的文件）、**字符流**（纯文本文件）；

抽象类：
| | **输入流** | **输出流** |
| :--------: | :-----------------------------: | :------------------------------: |
| **字节流** | 字节输入流<br />**InputStream** | 字节输出流<br />**OutputStream** |
| **字符流** | 字符输入流<br />**Reader** | 字符输出流<br />**Writer** |

字符流的底层就是字节流，用于处理纯字符

字符流 = 字节流 + 字符集

- 输入流：一次读一个字节，遇到中文，一次读多个字节
- 输出流：底层会把数据按照指定的编码方式进行编码，变成字节再写到文件中

### 字节输出流【OutputStream】

`java.io.OutputStream `抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。

- `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。
- `public void flush() ` ：刷新此输出流并强制任何缓冲的输出字节被写出。
- `public void write(byte[] b)`：将 b.length 字节从指定的字节数组写入此输出流。
- `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。
- `public abstract void write(int b)` ：将指定的字节输出流。

#### 文件输出流【FileOutputStream】

| 方法名                                               | 说明                                                                     |
| ---------------------------------------------------- | ------------------------------------------------------------------------ |
| public FileOutputStream(File file)                   | 根据文件对象构造文件输出流                                               |
| public FileOutputStream(String name)                 | 根据文件名构造文件输出流                                                 |
| public FileOutputStream(File file, boolean append)   | 根据文件对象和是否追加的方式构造文件输出流，默认为 false（清空原有内容） |
| public FileOutputStream(String name, boolean append) | 根据文件名和是否追加的方式构造文件输出流                                 |
| public void write(int b)                             | 将指定的 ASCII 码值写入此输出流                                          |
| public void write(byte[] b)                          | 将指定的字节数组写入此输出流                                             |
| public void write(byte[] b, int off, int len)        | 从指定的字节数组写入，从 off 索引开始，len 个字节                        |

换行：

- Windows 系统：`\r\n`
- Linux 系统：`\n`
- Mac 系统：`\r`

创建对象：

- 参数是字符串表示的路径或者是 File 对象都可以
- 如果路径不存在，会自动创建，但是要保证父级路径是存在的
- 如果文件存在，会清空原文件

写入数据：

- 写到本地文件的是整数在 ASCII 上对应的字符

释放资源：

- 每次使用完后都需要关闭流，释放资源

### 字节输入流【InputStream】

`java.io.InputStream `抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。

- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。
- `public abstract int read()`： 从输入流读取数据的下一个字节。
- `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组 b 中 。

#### 文件输入流【FileInputStream】

创建字节输入流对象：

- 如果文件不存在，直接报错

读取数据：

- 一次读取一个字节，读出来的是数据在 ASCII 上对应的数字
- 读取到文件末尾，read 方法返回-1

释放数据：

- 每次使用完流后都要释放资源

| 方法名                                      | 说明                                                                               |
| ------------------------------------------- | ---------------------------------------------------------------------------------- |
| public FileInputStream(File file)           | 根据文件对象构造文件输入流                                                         |
| public FileInputStream(String name)         | 根据文件名构造文件输入流                                                           |
| public int read()                           | 读取输入流中的字节，返回整数值                                                     |
| public int read(byte[] b)                   | 从输入流中读取一些字节数，并将它们存储到字节数组 b 中，返回读取数组长度            |
| public int read(byte[] b, int off, int len) | 从输入流中读取一些字节数，并将它们存储到字节数组 b 中，从 off 索引开始，len 个字节 |

#### 自动关闭流

```java
//JDK 7
try(FileInputStream fis = new FileInputStream("")){
    //操作流
} catch (IOException e) {
    e.printStackTrace();
}

//JDK 9
FileInputStream fis = new FileInputStream("");//方法抛出异常
try(fis) {
    //操作流
} catch (IOException e) {
    e.printStackTrace();
}
```

### 文件拷贝

流的关闭原则：**先开后关，后开先关，栈**

```java
public class Copy{
	public static void main(String[] args) throws IOException{
		FileInputStream fis = new FileInputStream("");
		FileOutputStream fos = new FileOutputStream("");

		int b;
		while((b=fis.read())!=-1)
			fos.write(b);

		int len;
		byte[] bytes = new byte[1024*1024*5];
		while((len=fis.read(bytes))!=-1)
			fos.write(bytes,0,len);

		fos.close();
		fis.close();
	}
}
```

### 字符集

一个字节由 8 个比特位表示，每个比特位可以取 0 或 1，所以一个字节可以表示 256 个不同的数值。

不同的字符集对应不同的编码规则，不同的编码规则对应不同的字符集。

乱码产生原因

1. 读取数据时未读完整个汉字
2. 编码和解码时方式不统一

#### ASCII 字符集

ASCII 字符集是最早的字符集，共 128 个字符，每个字符占一个字节。

ASCII 字符集的编码规则：前面补 0，补齐到 8 位

ASCII 字符集的解码规则：直接转成十进制

#### GBK 字符集

GBK 字符集英文编码规则：不足 8 位，前面补 0，补齐到 8 位

GBK 字符集英文的解码规则：直接转成十进制

GBK 字符集中文编码规则：每个汉字占两个字节，高位字节二进制一定以 1 开头，转成十进制之后是一个负数，不需要变动

GBK 字符集中文的解码规则：直接读取

#### Unicode 字符集

Unicode 字符集是目前世界上使用最广泛的字符集，包含了世界上所有语言的字符。

UTF-8 编码规则：用 1~4 个字节存储

```
0xxxxxxx
110xxxxx 10xxxxxx
1110xxxx 10xxxxxx 10xxxxxx
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```

### 编码和解码

| 方法名                                                 | 说明                   |
| ------------------------------------------------------ | ---------------------- |
| public byte[] getBytes()                               | 使用默认方式进行编码   |
| public byte[] getBytes(String charsetName)             | 使用指定字符集进行编码 |
| public String String(byte[] bytes)                     | 使用默认方式进行解码   |
| public String String(byte[] bytes, String charsetName) | 使用指定字符集进行解码 |

### 字符输入流【Reader】

`java.io.Reader`抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。

- `public void close()`：关闭此流并释放与此流相关联的任何系统资源。
- `public int read()`： 从输入流读取一个字符。
- `public int read(char[] cbuf)`： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中 。

#### 文件输入流【FileReader】

`java.io.FileReader `类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。

| 方法名                             | 说明                                                                                     |
| ---------------------------------- | ---------------------------------------------------------------------------------------- |
| public FileReader(File file)       | 根据文件对象构造文件输入流                                                               |
| public FileReader(String fileName) | 根据文件名构造文件输入流                                                                 |
| public int read()                  | 读取输入流中的字符，返回整数值，末尾返回-1                                               |
| public int read(char[] cbuf)       | 从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中，返回读取数组长度，读到末尾返回-1 |
| public int close()                 | 释放资源/关闭流                                                                          |

### 字符输出流【Writer】

`java.io.Writer `抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。

- `void write(int c)` 写入单个字符。
- `void write(char[] cbuf) `写入字符数组。
- `abstract  void write(char[] cbuf, int off, int len) `写入字符数组的某一部分,off 数组的开始索引,len 写的字符个数。
- `void write(String str) `写入字符串。
- `void write(String str, int off, int len)` 写入字符串的某一部分,off 字符串的开始索引,len 写的字符个数。
- `void flush() `刷新该流的缓冲。
- `void close()` 关闭此流，但要先刷新它。

#### 文件输出流【FileWriter】

`java.io.FileWriter `类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区

| 方法名                                             | 说明                             |
| -------------------------------------------------- | -------------------------------- |
| public FileWriter(File file)                       | 根据文件对象构造文件输出流       |
| public FileWriter(String fileName)                 | 根据文件名构造文件输出流         |
| public FileWriter(File file, boolean append)       | 创建字符输出流关联本地文件，续写 |
| public FileWriter(String fileName, boolean append) | 创建字符输出流关联本地文件，续写 |
| public void write(int c)                           | 写入单个字符                     |
| public void write(char[] cbuf)                     | 写入字符数组                     |
| public void write(char[] cbuf, int off, int len)   | 写入字符数组的某一部分           |
| public void write(String str)                      | 写入字符串                       |
| public void write(String str, int off, int len)    | 写入字符串的某一部分             |

创建字符输出流对象：

- 参数是字符串表示的路径或者是 File 对象都可以
- 如果文件不存在，会自动创建，但是要保证父级路径是存在的
- 如果文件存在，默认清空原文件

写数据：

- 如果 write 方法的参数是整数，但是实际写到本地文件中的是证书在字符集上对应的字符

释放资源：

- 每次使用完流后都要释放资源

### 缓冲流

缓冲流,也叫高效流，是对 4 个基本的`FileXxx` 流的增强，所以也是 4 个流，按照数据类型分类：

- **字节缓冲流**：`BufferedInputStream`，`BufferedOutputStream`
- **字符缓冲流**：`BufferedReader`，`BufferedWriter`

缓冲流的基本原理，是在创建流对象时，会创建一个内置的 8192 字节长的缓冲区，通过缓冲区读写，减少系统 IO 次数，从而提高读写的效率。

#### 字节缓冲流

| 方法名                                        | 说明                 |
| --------------------------------------------- | -------------------- |
| public BufferedInputStream(InputStream in)    | 创建带缓冲区的输入流 |
| public BufferedOutputStream(OutputStream out) | 创建带缓冲区的输出流 |

#### 字符缓冲流

| 方法名                            | 说明                                                      |
| --------------------------------- | --------------------------------------------------------- |
| public BufferedReader(Reader in)  | 创建带缓冲区的输入流                                      |
| public BufferedWriter(Writer out) | 创建带缓冲区的输出流                                      |
| public String readLine()          | 读取一行，但不会读取换行符，如果没有数据可以读，返回 null |
| public void newLine()             | 跨平台的换行                                              |

### 转换流

转换流是字符流和字节流之间的桥梁，让字节流使用字符流的方法

#### InputStreamReader

转换流`java.io.InputStreamReader`，是 Reader 的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。

| 方法名                                                       | 说明                                                 |
| ------------------------------------------------------------ | ---------------------------------------------------- |
| public InputStreamReader(InputStream in)                     | 创建转换流，从指定的字节输入流读取                   |
| public InputStreamReader(InputStream in, String charsetName) | 创建转换流，从指定的字节输入流读取，使用指定的字符集 |

实际使用 FileReader 类，`public FileReader(File file, CharSet charsetName)`

#### OutputStreamWriter

转换流`java.io.OutputStreamWriter` ，是 Writer 的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。

| 方法名                                                          | 说明                                                     |
| --------------------------------------------------------------- | -------------------------------------------------------- |
| public OutputStreamWriter(OutputStream out)                     | 创建转换流，将字符写入指定的字节输出流                   |
| public OutputStreamWriter(OutputStream out, String charsetName) | 创建转换流，将字符写入指定的字节输出流，使用指定的字符集 |

实际使用 FileWriter 类，`public FileWriter(File file, CharSet charsetName)`

### 序列化流/反序列化流

可以把 Java 对象写到本地文件，对象操作输出流

`serialVersionUID`：是用来标识类的版本的，当类的实现发生变化时，可以修改 serialVersionUID 值，以便反序列化时能够正确的实例化对象。

`transient`关键字：用来修饰不需要序列化的属性。

#### ObjectOutputStream

对象操作输出流,Javabean 类要实现`Serializable`标记型接口，才能被序列化。

| 方法名                                      | 说明                                       |
| ------------------------------------------- | ------------------------------------------ |
| public ObjectOutputStream(OutputStream out) | 创建对象输出流，将对象写入指定的字节输出流 |
| public void writeObject(Object obj)         | 将指定的对象写入此输出流                   |

#### ObjectInputStream

对象操作输入流

| 方法名                                   | 说明                                       |
| ---------------------------------------- | ------------------------------------------ |
| public ObjectInputStream(InputStream in) | 创建对象输入流，从指定的字节输入流读取对象 |
| public Object readObject()               | 从此输入流中读取对象                       |

### 打印流

只操作文件目的地，不操作数据源，实现了自动刷新自动换行

#### PrintStream

| 方法名                                                                      | 说明                                   |
| --------------------------------------------------------------------------- | -------------------------------------- |
| public PrintStream(OutputStream/File/String out)                            | 创建打印流，将输出写入指定的字节输出流 |
| public PrintStream(String fileName, CharSet charsetName)                    | 指定字符编码                           |
| public PrintStream(OutputStream out, boolean autoFlush)                     | 指定是否自动刷新                       |
| public PrintStream(OutputStream out, boolean autoFlush, String charsetName) | 指定是否自动刷新和字符编码             |

字节流底层没有缓冲区

| 成员方法                                          | 说明                             |
| ------------------------------------------------- | -------------------------------- |
| public void write(int b)                          | 将指定的字节写入此输出流         |
| public void println(Xxx xxx)                      | 打印任意数据，自动刷新，自动换行 |
| public void print(Xxx xxx)                        | 打印任意数据，自动刷新           |
| public void printf(String format, Object... args) | 带有占位符的打印语句，不换行     |

#### PrintWriter

| 方法名                                                                | 说明                                   |
| --------------------------------------------------------------------- | -------------------------------------- |
| public PrintWriter(Writer out)                                        | 创建打印流，将输出写入指定的字符输出流 |
| public PrintWriter(String fileName, CharSet charsetName)              | 指定字符编码                           |
| public PrintWriter(Writer out, boolean autoFlush)                     | 指定是否自动刷新                       |
| public PrintWriter(Writer out, boolean autoFlush, String charsetName) | 指定是否自动刷新和字符编码             |

字符流底层有缓冲区

| 成员方法                                          | 说明                             |
| ------------------------------------------------- | -------------------------------- |
| public void write(int b)                          | 将指定的字节写入此输出流         |
| public void println(Xxx xxx)                      | 打印任意数据，自动刷新，自动换行 |
| public void print(Xxx xxx)                        | 打印任意数据，自动刷新           |
| public void printf(String format, Object... args) | 带有占位符的打印语句，不换行     |

### 压缩流/解压缩流

压缩流

| 方法名                                   | 说明                                       |
| ---------------------------------------- | ------------------------------------------ |
| public ZipOutputStream(OutputStream out) | 创建压缩输出流，将输出写入指定的字节输出流 |
| public void putNextEntry(ZipEntry entry) | 创建新的压缩条目                           |

解压缩流

| 方法名                                | 说明                                             |
| ------------------------------------- | ------------------------------------------------ |
| public ZipInputStream(InputStream in) | 创建解压缩输入流，从指定的字节输入流读取压缩数据 |
| public ZipEntry getNextEntry()        | 读取下一个压缩条目                               |

### Commons-io

Commons 是 apache 开源基金组织提供的工具包，里面有很多帮助我们提高开发效率的 API，Commons-io 是 apache 开源基金组织提供的一组有关 IO 操作的开源工具包。
作用是提高 IO 流的开发效率

#### 管理 jar 包

1. 项目内新建 lib 文件夹
2. 下载 jar 包，放入 lib 文件夹
3. 右键点击 jar 包，选择 Add as Library

#### FileUtils 类

| 方法名                                                               | 说明               |
| -------------------------------------------------------------------- | ------------------ |
| public static void copyFile(File src, File dest)                     | 复制文件           |
| public static void copyDirectory(File src, File dest)                | 复制文件夹         |
| public static void copyDirectoryToDirectory(File src, File destDir)  | 复制文件夹到文件夹 |
| public static void deleteDirectory(File directory)                   | 删除文件夹         |
| public static void cleanDirectory(File directory)                    | 清空文件夹         |
| public static String readFileToString(File file, String charsetName) | 读取文件内容       |
| public static void write(File file, Charset charset, String content) | 写入文件内容       |

#### IOUtils 类

| 方法名                                                              | 说明               |
| ------------------------------------------------------------------- | ------------------ |
| public static int copy(InputStream input, OutputStream output)      | 复制输入流到输出流 |
| public static int copyLarge(InputStream input, OutputStream output) | 复制大文件         |
| public static String readLines(Reader input)                        | 读取文件内容       |
| public static void write(String str, OutputStream output)           | 写入文件内容       |

## 多线程

进程：进程是程序的基本执行实体

线程：线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。

简单理解，线程就是应用软件中互相独立、可以同时运行的功能

线程的调度方式，分为抢占式和非抢占式。

- 非抢占式：轮流执行
- 抢占式（JVM）：体现随机性，优先级越大分配的越多

### 并发和并行

并发：在同一时刻，有多个指令在单个 CPU 上交替执行

并行：在同一时刻，有多个指令在多个 CPU 上同时执行

### 多线程的实现方式

| 实现方式                     | 优点                                 | 缺点                                 |
| ---------------------------- | ------------------------------------ | ------------------------------------ |
| 继承 Thread 类               | 简单，可以直接使用 Thread 提供的方法 | 无法继承其他类，可拓展性较差         |
| 实现 Runnable 接口           | 可以继承其他类，可拓展性强           | 复杂，不能直接使用 Thread 提供的方法 |
| 利用 Callable 和 Future 接口 | 可以继承其他类，可拓展性强           | 复杂，不能直接使用 Thread 提供的方法 |

#### 继承 Thread 类

将类声明为 Thread 类的子类，并重写 run()方法，接下来可以分配并启动该子类的实例，创建对象之后调用 start()方法。

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        // 线程要执行的代码
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
```

#### 实现 Runnable 接口

声明一个类实现 Runnable 接口，并重写 run()方法，接下来可以分配并启动该类的实例，创建对象之后调用 start()方法。

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 线程要执行的代码
    }
}

public class Main {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        new Thread(myRunnable).start();
    }
}
```

#### 利用 Callable 和 Future 接口

可以将线程的执行结果返回，并提供回调接口。

```java
public class MyCallable implements Callable<T> {
    @Override
    public T call() throws Exception {
        // 线程要执行的代码
        return null;
    }
}

public class Main {
    public static void main(String[] args) {
        MyCallable mc = new MyCallable();
		FutureTask<T> ft = new FutureTask<>(mc);
		new Thread(ft).start();
		T result = ft.get(); // 获取线程执行结果
	}
}
```

### Thread 的成员方法

| 方法名                           | 说明                       |
| -------------------------------- | -------------------------- |
| String getName()                 | 获取线程的名称             |
| void setName(String name)        | 设置线程的名称             |
| static Thread currentThread()    | 获取当前线程               |
| static viod sleep(long millis)   | 让当前线程暂停执行一段时间 |
| setPriority(int newPriority)     | 设置线程的优先级           |
| final int getPriority()          | 获取线程的优先级           |
| final void setDaemon(boolean on) | 设置线程是否为守护线程     |
| public static void yield()       | 出让线程/礼让线程          |
| public static void join()        | 插入线程/插队线程          |

方法细节：

1. `getName()`：，默认名称为“Thread-数字”
2. `setName(String name)`：可以在子类中继承构造方法设置
3. `currentThread()`：当 JVM 启动时，系统会自动创建主线程 main，作用就是调用 main 方法，并执行里面的代码
4. `sleep(long millis)`：哪条线程执行到这里，那么哪条线程就会在这里停留对应时间，单位为毫秒，当时间到了后线程会自动地醒来继续执行
5. `setPriority(int newPriority)`、`final int getPriority()`：设置线程的优先级，优先级越高，获得 CPU 的使用权越大，默认优先级为 5，范围为 1~10，只是反应抢到 CPU 的概率，并不是绝对的，具体取决于系统的调度算法。
6. `final void setDaemon(boolean on)`：设置线程是否为守护线程，如果设置为 true，则该线程不重要，随着程序的结束而结束，默认值为 false。
7. `public static void yield()`：出让线程/礼让线程，让当前线程暂停执行一段时间，但不释放 CPU 资源，让其他线程有机会执行。
8. `public static void join()`：插队线程，让当前线程暂停执行一段时间，直到其他线程执行完毕，才继续执行。

### 线程的生命周期

![线程的生命周期](img/Java_7.png)

### 线程安全的问题

#### 同步代码块：

把操作共享数据的代码锁起来

```java
synchronized(锁){
    // 共享数据操作的代码
}
```

特点 1：锁默认打开，有一个线程进去了，锁自动关闭

特点 2：里面的代码全部执行完毕，线程出来，锁自动打开

特点 3：锁对象可以是任意对象，但必须要唯一

#### 同步方法：

把整个方法锁起来

```java
public synchronized void method(){
    // 共享数据操作的代码
}
```

特点 1：同步方法是锁住方法里面所有的代码

特点 2：锁对象不能自己指定，非静态方法（this），静态（当前类的字节码文件对象）

StringBulider 类和 StringBuilder 类的差别就是，前者是线程不安全的，后者是线程安全的。

### Lock 锁接口

JDK5 后提供了一个新的锁对象 Lock，实现提供比使用 synchronized 方法和语句可以获得更广泛的锁定操作

即提供了获得锁和释放锁的方法，可以显式地进行锁定和解锁操作，并且可以绑定多个条件。

```java
void lock(); //获取锁
void unlock(); //释放锁
```

Lock 是接口，不能直接实例化，这里采用它的实现类 ReentrantLock 来实例化

使用`ReentrantLock()`：空参构造

使用`try-catch-finally`：确保锁一定被释放

### 死锁

两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

#### 死锁条件

- 互斥条件：共享资源 X 和 Y 只能被一个线程占用
- 请求和保持条件：线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X
- 不可抢占条件：其他线程不能强行抢占线程 T1 占有的资源
- 循环等待条件：线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源

#### 处理方法

导致死锁后，只能人工干预来处理，重启服务、kill 掉线程

避免死锁，可以：

1. 一次性申请所有资源，就不存在锁要等待了
2. 占用部分资源的线程进行进一步申请其他资源的时候，如果申请不到，先释放自己占有的资源
3. 按序申请资源，线性申请资源
4. 避免嵌套锁

### 生产者和消费者（等待唤醒机制）

生产者消费者模式是一个十分经典的多线程协作的模式

生产者：生产数据，放入缓冲区

消费者：从缓冲区取出数据，消费数据

| 方法名称         | 说明                   |
| ---------------- | ---------------------- |
| void wait()      | 让线程等待，直到被唤醒 |
| void notify()    | 唤醒一个正在等待的线程 |
| void notifyAll() | 唤醒所有正在等待的线程 |

使用以上方法都是和锁绑定

可以模拟实现或者阻塞队列实现

#### 阻塞队列

![阻塞队列的继承结构](img/Java_8.png)

- ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列，FIFO，容量大小为数组大小
- LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列，FIFO，容量大小无限（最大为 int 的最大值）

| 方法名称      | 说明                                   |
| ------------- | -------------------------------------- |
| void put(E e) | 向队列中添加元素，如果队列已满，则阻塞 |
| E take()      | 从队列中取出元素，如果队列为空，则阻塞 |

### 多线程的 6 种状态

![线程的状态](img/Java_9.png)

（真实无运行状态）

- 新建状态（NEW）：创建线程对象
- 就绪状态（RUNNABLE）：start 方法
- 阻塞状态（BLOCKED）：无法获得锁对象
- 等待状态（WAITING）：wait 方法
- 计时等待（TIMED_WAITING）：sleep 方法
- 终止状态（TERMINATED）：全部代码运行完毕

### 线程栈

线程栈是用来存储线程运行过程中的局部变量、方法调用、返回地址等信息的内存空间。

每个线程都是一个线程栈

### 线程池

#### 线程池主要核心原理

1. 创建一个池子，池子中是空的

2. 提交任务，池子会创建新的线程对象（无空闲线程，但可创建新线程），任务执行完毕，线程归还给池子，下次再次提交任务时，不需要创建新的线程，直接复用已有的线程

3. 但是提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待，直到池子中有空闲线程，才会执行任务

4. 线程池的大小，决定了池子中最多能创建多少个线程，如果池子中有线程空闲，则不会创建新的线程，而是直接复用已有的线程

#### 线程池代码实现

Executors：线程池的工具类，通过调用方法返回不同的线程池对象

1. 创建线程池对象

| 方法名称                                                | 说明                                                                        |
| ------------------------------------------------------- | --------------------------------------------------------------------------- |
| static ExecutorService newCachedThreadPool()            | 创建一个可缓存线程池，线程池的大小不受限，线程数的创建和销毁由 JVM 自动管理 |
| static ExecutorService newFixedThreadPool(int nThreads) | 创建固定线程数量的线程池                                                    |

2. 提交任务

`pool.submit(Runnable task)`

3. 所有任务执行完毕，关闭线程池

`pool.shutdown()`

#### 自定义线程池

`ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)`

- 核心线程数量：不能小于 0
- 线程池中最大线程的数量：最大数量不能小于核心线程数量
- 空闲时间（值）：不能小于 0
- 空闲时间（单位）：用 TimeUnit 类指定
- 阻塞队列：不能为 null
- 创建线程的方式：不能为 null
- 要执行的任务过多时的粗略：不能为 null

##### 创建临时线程的条件：

1. 线程池中没有空闲线程
2. 阻塞队列已满
3. 线程池中线程数量没有达到最大线程数量

（可以说明，任务不一定是按照提交顺序完成）

##### 任务拒绝策略：

| 任务拒绝策略                           | 说明                                                           |
| -------------------------------------- | -------------------------------------------------------------- |
| ThreadPoolExecutor.AbortPolicy         | 直接抛出异常，默认策略                                         |
| ThreadPoolExecutor.DiscardPolicy       | （不推荐）直接丢弃任务，不抛出异常                             |
| ThreadPoolExecutor.DiscardOldestPolicy | 丢弃队列最前面的任务（等待最久的任务），然后把当前任务加入队列 |
| ThreadPoolExecutor.CallerRunsPolicy    | 由调用者所在的线程来执行任务(绕过线程池)                       |

##### 最大并行数

```java
int maxParallelism = Runtime.getRuntime().availableProcessors();
```

可以求出最大并行数

##### 线程池大小设置

对于 CPU 密集型任务，最大并行数+1

对于 IO 密集型任务，最大并行数 _ 期望 CPU 利用率 _ 总时间(CPU 计算时间+等待时间)/CPU 计算时间

## 网络编程

网络编程：在网络通信协议下，不同计算机上运行的程序，进行的数据传输和通信，是计算机跟计算机之间通过网络进行数据传输（Java.net 包是心爱）

### 常见软件架构

#### CS 架构

`C/S Client/Server`：客户端和服务器架构，在用户本地需要下载安装客户端程序，在远程有一个服务器端程序

优缺点：

1. 画面可以做的非常精美，用户体验好

2. 需要开发客户端，也需要开发服务端
3. 用户需要下载和更新的时候太麻烦了

#### BS 架构

`B/S Browser/Server`：浏览器和服务器架构，用户通过浏览器访问服务器端程序，服务器端程序提供服务

优缺点：

1. 不需要开发客户端，只需要页面+服务端
2. 用户不需要下载，打开浏览器就能使用

3. 如果应用过大，用户体验受到影响

### 网络编程三要素

1. IP：设备在网络中的地址，是唯一的标识
2. 端口号：应用程序在设备中唯一的标识
3. 协议：数据在网络中传输的规则，常见的协议有 UDP、TCP、http、https、ftp 等

#### IP

全称：Internet Protocol，即互联网协议地址，也称 IP 地址，是分配给上网设备的数字标签

上网设备在网络中的地址，是唯一的

##### IPv4

全称：Internet Protocol version 4，即互联网协议第四版

采用 32 位地址长度，分成 4 组，每组 8 位，每组用“.”分隔，点分十进制表示法，0-255

IPv4 地址分类：公网地址（万维网使用）和私有地址（局域网使用）

192.168.开头就是私有地址，范围即为 192.168.0.0-192.168.255.255，专门为组织机构内部使用，以此来节省 IP

127.0.0.1，也可以是`localhost`：是回送地址，也称本地回环地址、本地 IP，永远只会寻找当前所在本机（不经过网络，在本地回传）

##### IPv6

全称：Internet Protocol version 6，即互联网协议第六版

采用 128 位地址长度，分成 8 组，每组 16 位，每组用“:”分隔，冒号十六进制表示法，0-65535

特殊情况：连续出现多个 0，则使用 0 位压缩表示法

##### InetAddress 类

java.net 包中提供的类，用来表示 IP 地址，可以获取 IP 地址的各种信息

| 方法名                                    | 说明                                                   |
| ----------------------------------------- | ------------------------------------------------------ |
| static InetAddress getByName(String host) | 根据主机名获取 IP 地址，可以使机器名称也可以是 IP 地址 |
| String getHostName()                      | 获取此 IP 地址的主机名                                 |
| String getHostAddress()                   | 返回文本显示的 IP 地址字符串                           |

#### 端口号

应用程序在设备中唯一的标识

端口号由两个字节表示的整数，取值范围：0~65535
0~1023：系统预留端口，一般不用

一个端口号只能被一个应用使用，如果多个应用使用同一个端口号，则会出现端口冲突

#### 协议

计算机网络中，连接和通信的规则被称为网络通信协议

- OSI 参考模型：世界互联协议标准，全球偷心规范，单模型过于理想化，未能在因特网上进行广泛推广

- TCP/IP 参考模型（TCP/IP 协议）：事实上的国际标准

![协议对应模型](img/Java_10.png)

UDP 协议

- 用户数据报协议（User Datagram Protocol）
- UDP 是面向无连接通信协议，速度快，有大小限制（64k），数据不安全，易丢失数据
- 不管是否已经连接成功都发送

TCP 协议

- 传输控制协议 TCP（Transmission Control Protocol）
- TCP 是面向连接的协议，速度慢，没有大小限制，数据安全
- 会确保连接成功，并且数据传输的完整性

##### UDP 通信程序

发送数据

1. 创建发送端的 DatagramSocket 对象
2. 数据打包（DatagramPacket）
3. 发送数据
4. 释放资源

```java
//创建发送端的DatagramSocket对象
//绑定端口，通过该端口向外发送，若空参构造，则随机分配可用端口；若指定端口，则绑定该端口
DatagramSocket ds = new DatagramSocket();

//数据打包DatagramPacket
//data为要发送的数据，必须要转化为字节形式
DatagramPacket dp = new DatagramPacket(data, data.length, ip, port);

//发送数据
ds.send(dp);

//释放资源
ds.close();
```

接收数据

1. 创建接收端的 DatagramSocket 对象
2. 接收打包好的数据
3. 解析数据包
4. 释放资源

```java
//创建接收端的DatagramSocket对象
//接收的时候一定要绑定端口，还要和发送端口一致
DatagramSocket ds = new DatagramSocket(port);

//接收打包好的数据
byte[] data = new byte[1024];
DatagramPacket dp = new DatagramPacket(data, data.length);
ds.receive(dp);

//解析数据包
byte[] bytes = dp.getData();
int len = dp.getLength();
InetAddress address = dp.getAddress();
int port = dp.getPort();

System.out.println("接收到的数据：" + new String(bytes, 0, len));
System.out.println("发送方的IP：" + address.getHostAddress());
System.out.println("发送方的端口：" + port);

//释放资源
ds.close();
```

细节：receive()方法是阻塞的，直到接收到数据才会返回，如果没有数据，则一直阻塞

UDP 的三种通信方式：

1. 单播

2. 组播

   组播地址：224.0.0.0-239.255.255.255，用于多播，同一网络下的所有主机都可以接收到该组播包
   其中 224.0.0.0-224.0.0.255 为预留的组播地址

3. 广播

   255.255.255.255，用于广播，同一网络下的所有主机都可以接收到该广播包

##### TCP 通信程序

TCP 通信协议是一种可靠的网络协议，它在通信的两端各建立一个 Socket 对象
通信之前要保证连接已经建立
通过 Socket 产生 IO 流来进行网络通信

![通信程序流程图](img/Java_11.png)

##### TCP 的三次握手

![TCP的三次握手](img/Java_12.png)

##### TCP 的四次挥手

![TCP的四次挥手](img/Java_13.png)

## 动态代理

动态代理特点：无侵入式的给代码增加额外的功能

把所有想要被代理的方法写在接口里面，对象和代理需要实现同一个接口

`java.lang.reflect.Proxy`：提供了为对象产生代理对象的方法

## 反射

反射允许对封装类成员变量、成员方法和构造方法的信息进行编程访问

1. 获取 class 对象，类名为 Class

2. 获取成员变量、成员方法、构造方法（获取）

3. 调用方法（解剖）

### 获取 class 对象

1. Class.forName("全类名") 包名+类名

源代码阶段使用（将 java 文件编译成 class 文件），最为常用

2. 类名.clss

加载阶段使用（将 class 文件加载到内存中），更多用于当做参数传递

3. 对象.getClass()

运行阶段使用（获取对象的类信息），当已经有了对象才可以使用

### 获取成员变量、成员方法、构造方法

#### 获取构造方法

Constructor 类，可以获取类的构造方法

| 方法名                                                           | 说明                                     |
| ---------------------------------------------------------------- | ---------------------------------------- |
| Constructor<?>[] getConstructors()                               | 获取类的所有公共构造方法                 |
| Constructor<?>[] getDeclaredConstructors()                       | 获取类的所有构造方法（包括私有构造方法） |
| Constructor<T> getConstructor(Class<?>...parameterTypes)         | 返回单个公共构造方法对象                 |
| Constructor<T> getDeclaredConstructor(Class<?>...parameterTypes) | 返回单个构造方法对象（包括私有构造方法） |

传入的参数是类的 class 对象，如传入`String.class`

#### 调用构造方法

getModifiers() 方法可以获取构造方法的修饰符，返回 int 类型，具体含义参考 Modifier 类

getParameterTypes() 方法可以获取构造方法的参数类型，返回 Parameter 类数组

对于 Constructor 类，可以通过 `newInstance()` 方法将获得的构造放方法创建对象，传入参数为构造方法的参数，也可以使用 `setAccessible(true)` 方法临时取消权限校验进行构造

#### 获取字段（成员变量）

| 方法名                              | 说明                               |
| ----------------------------------- | ---------------------------------- |
| Field[] getFields()                 | 获取类的所有公共字段               |
| Field[] getDeclaredFields()         | 获取类的所有字段（包括私有字段）   |
| Field getField(String name)         | 根据字段名获取字段                 |
| Field getDeclaredField(String name) | 根据字段名获取字段（包括私有字段） |

#### 调用字段

getModifiers() 方法可以获取字段的修饰符，返回 int 类型，具体含义参考 Modifier 类

getType() 方法可以获取字段的类型，返回 Class 类对象

getName() 方法可以获取字段的名称，返回字符串

对于 Field 类，可以通过 `get()` 方法获取字段的值，可以通过 `set()` 方法设置字段的值，传入的参数都是该对象（set 方法多传入修改后的值），也可以使用 `setAccessible(true)` 方法临时取消权限校验进行操作

#### 获取成员方法

| 方法名                                                           | 说明                                             |
| ---------------------------------------------------------------- | ------------------------------------------------ |
| Method[] getMethods()                                            | 获取类的所有公共方法（包括父类）                 |
| Method[] getDeclaredMethods()                                    | 获取类的所有方法（包括私有方法，不包括父类）     |
| Method getMethod(String name, Class<?>...parameterTypes)         | 根据方法名和参数类型获取方法对象                 |
| Method getDeclaredMethod(String name, Class<?>...parameterTypes) | 根据方法名和参数类型获取方法对象（包括私有方法） |

#### 调用成员方法

getModifiers() 方法可以获取方法的修饰符，返回 int 类型，具体含义参考 Modifier 类

getName() 方法可以获取方法的名称，返回字符串

getParameters() 方法可以获取方法的参数列表，返回 Parameter 类数组

getExceptionTypes() 方法可以获取方法的异常列表，返回 Class 类数组

invoke(Object obj, Object...args) 方法可以调用方法，传入的参数为调用方法的对象以及该方法需要使用的参数，返回值是方法的返回值，也可以使用 `setAccessible(true)` 方法临时取消权限校验进行操作

getReturnType() 方法可以获取方法的返回类型，返回 Class 类对象

### 反射的作用

1. 获取一个类里面所有的信息，获取到了之后，在执行其他的业务逻辑

2. 结合配置文件，动态地创建对象并且调用方法

## 类与对象

### Object 类

```java
//创建对象
public Object();
//返回对象的字符串表达形式
public String toString();
//比较两个对象是否相等
public boolean equals(Object obj);
//对象克隆
protected Object clone(int a);
```

对于 javabean 类可以根据需求直接重写
默认的 toString()方法是对地址值进行字符串化
默认的 equals()方法是比较地址值是否相同

如果一个接口里面没有抽象方法，表示当前的接口是一个标记性接口`cloneable`，若当前接口一旦实现了，那么当前类的对象就可以被克隆，如果没有实现，当前类的对象就不能克隆

克隆对象需要：1、重写 Object 的 clone 方法；2、让 javabean 类实现 Cloneable 接口；3、创建原对象并调用 clone 就可以了

**浅克隆：**

​ 不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来

​ 基本数据类型拷贝过来的是具体的数据，引用数据类型拷贝过来的是地址值。

​ Object 类默认的是浅克隆

![浅克隆](img\Java_5.png)

**深克隆：**

​ 基本数据类型拷贝过来，字符串复用，引用数据类型会重新创建新的

![深克隆](img\java_6.png)

### Objects 类

工具类，存在于`java.util`包下，所以需要进行导入，且被`final`修饰即不可以被继承

```java
// 获取对象的字符串表现形式
public static String toString(Object o)
// 先作非空判断，比较两个对象是否相等
public static boolean equals(Object a, Object b)
// 判断对象是否为null，为则返回true
public static boolean isNull(Object obj)
// 判断对象是否不为null，不为则返回true
public static boolean nonNull(Object obj)
```

### 包装类

Java 提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类

| 基本类型 | 对应的包装类（位于 java.lang 包中） |
| -------- | ----------------------------------- |
| byte     | Byte                                |
| short    | Short                               |
| int      | **Integer**                         |
| long     | Long                                |
| float    | Float                               |
| double   | Double                              |
| char     | **Character**                       |
| boolean  | Boolean                             |

JDK5 自动装箱与自动拆箱

直接对包装类赋值、运算

- 包装类与字符串之间的转换

基本类型转换为 String

- 方式一：直接在数字后加一个空字符串
- 方式二：通过 String 类静态方法 valueOf()

将字符串转为基本类型

- `public static byte parseByte(String s)`：将字符串参数转换为对应的 byte 基本类型。
- `public static short parseShort(String s)`：将字符串参数转换为对应的 short 基本类型。
- `public static int parseInt(String s)`：将字符串参数转换为对应的 int 基本类型。
- `public static long parseLong(String s)`：将字符串参数转换为对应的 long 基本类型。
- `public static float parseFloat(String s)`：将字符串参数转换为对应的 float 基本类型。
- `public static double parseDouble(String s)`：将字符串参数转换为对应的 double 基本类型。
- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的 boolean 基本类型。

细节：获取 Integer 对象的时候不要自己 new，而是采取直接赋值或者静态方法 valueOf 的方式

## 日志

### 日志技术概述

可以把程序在运行过程中的详细信息都打印在控制台上

利用 log 日志还可以把这些详细信息保存到文件和数据库中。

#### 优势

- 可以将系统执行的信息选择性的记录到指定位置（控制台、文件、数据库中）

- 可以随时以开关的形式控制是否记录日志，无需修改源代码

### 日志技术体系

#### 体系结构

日志规范接口：`Commons Logging`（JCL）、`Simple Logging Facade for Java`（slf4j）

**日志规范**：一些接口，提供给日志的实现框架设计的标准

日志实现框架：`Log4j`、`JUL`(java.util.logging)、`Logback`等

**日志框架**：已经做好的日志记录实现代码

### Logback 概述

Logback 是基于 slf4j 的日志规范实现的框架，性能比之前使用的 log4j 要好

#### 技术模块

- Logback-core:该模块为其他两个模块提供基础代码，必须有

- Logback-classic:完整实现了 slf4j API 的模块

- Logback-access:模块与 Tomcat 和 Jetty 等 Servlet 容器集成，以提供 HTTP 访问日志功能

### Logback 快速上手

- 导入包在 lib 文件夹中，并且将 lib 文件夹作为库

- 配置文件 **logback.xml** 并放到 src 文件夹下

- `public static final Logger LOGGER = LoggerFactory.getLogger("类对象");`

- 用`LOGGER.info("日志信息");`等等方法输出在控制台/文件/数据库中

> xml 文件配置，其中文件路径需要自行修改

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- CONSOLE ：表示当前的日志信息是可以输出到控制台的 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <!-- 输出流对象 默认 System.out 改为 System.err  其中err：控制台输出日志为红色，而out为黑色 -->
        <target>System.out</target>
        <encoder>
            <!-- 格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符 -->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level]  %c [%thread] : %msg%n</pattern>
        </encoder>
    </appender>

    <!-- File：表示当前的日志信息是可以输出到文件的 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf-8</charset>
        </encoder>
        <!-- 日志输出路径(logback_message.log是文档名，下方还有一处文件名（不用写.log）) -->
        <file>C:\Hcx\Code\Java\log\test.log</file>
        <!-- 指定日志文件拆分和压缩规则（防止文件过大） -->
        <rollingPolicy
                class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <!-- 通过指定压缩文件名称，来确定分割文件方式 -->
            <fileNamePattern>C:\Hcx\Code\Java\log\test-%d{yyyy-MMdd}.log%i.gz</fileNamePattern>
            <maxFileSize>1MB</maxFileSize> <!-- 文件拆分大小 -->
        </rollingPolicy>
    </appender>

    <!--
    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF (关掉)， 默认debug（可忽略大小写）
    <root>可以包含零个或多个<appender-ref>元素，标识这个输出位置将会被本日志级别控制。
    -->
    <root level="INFO"> <!-- 打印规则：只打印不低于当前级别的日志 -->
        <appender-ref ref="CONSOLE"/> <!-- 如果这个地方不配置关联打印的位置，改位置将不会记录日志 -->
        <appender-ref ref="FILE" />
    </root>
</configuration>

```

### Logback 配置详解

Logback 日志系统的特性都是通过核心板配置文件 logback.xml 来配置的。

#### Logback 日志输出位置、格式设置

- 通过 logback.xml 文件中的`<appender>`标签可以设置输出位置和日志信息的详细格式。

- 通常可以设置 2 个日志输出位置：**一个是控制台**、**一个是系统文件**

  - 控制台输出日志信息：`<appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">`

  - 文件输出日志信息：`<appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">`

- 日志信息的详细格式设置：

  - 日志输出方式（控制台中）：`<target>`标签，传入`System.out`或`System.err`

  - 日志输出格式：`<encoder>`、`<pattern>`标签，设置日志输出格式，其中`<pattern>`标签设置日志信息的输出格式

  - 日志文字编码：`<charset>`标签设置日志信息的编码格式（文件输出）

  - 日志输出文件路径：`<file>`标签设置日志文件输出路径（文件输出）

  - 日志文件拆分和压缩：`<rollingPolicy>`标签设置日志文件拆分和压缩规则（文件输出）

  - `<root>`标签设置日志输出位置和日志级别，在`<root level="">`处填入级别表示只打印不低于当前级别的日志信息，中间加入`<appender-ref>`标签关联日志输出位置

#### Logback 日志级别设置

- Logback 日志系统共分为 5 个级别：

  - TRACE：细粒度信息，仅在调试阶段使用

  - DEBUG：调试信息，一般用于开发阶段

  - INFO：运行信息，记录程序的运行状态

  - WARN：警告信息，记录程序的运行中出现的异常

  - ERROR：错误信息，记录程序的运行中出现的严重错误

- 额外设置：

  - ALL：打印所有级别的日志信息

  - OFF：关闭所有日志信息

- 在 logback.xml 文件的`<root>`标签中设置日志级别，如：`<root level="INFO">`

## 类加载器

类加载器：负责将.class 文件（存储的物理文件）加载到内存中

### 类加载介绍

#### 类加载时机：

1. 创建类的实例（对象）

2. 调用类的方法

3. 访问类或者接口的类变量，或者为该变量赋值

4. 用反射方法来强制创建某个类或接口对应的 `java.lang.Class` 对象

5. 初始化某个类的子类

6. 直接使用 **java.exe** 命令来运行某个主类

#### 类加载过程

加载 -> 验证 -> 准备 -> 解析 -> 初始化

其中 验证 -> 准备 -> 解析 3 个步骤可以合并为 1 个步骤，即链接阶段

##### 加载

- 通过一个类的全限定名来获取定义此类的二进制字节流

  - 全限定名：包名.类名，如 java.lang.String

  - 二进制字节流：类文件字节码

  - 即通过**包名 + 类名**，获取这个类，准备用流进行传输

- 将这个字节流所代表的静态存储结构转化为运行时数据结构

  - 静态存储结构：类中的静态变量、静态方法、常量池等

  - 运行时数据结构：JVM 内存中的方法区、堆内存、方法栈等

  - 将这个类加载到内存中

- 在内存中生成一个代表这个类的 java.lang.Class 对象，任何类被使用时，系统都会为之建立一个 java.lang.Class 对象

  - 加载完毕创建一个 class 对象

##### 链接

- 验证：确保 Class 文件字节流中，包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全

  - 文件中的信息是否符合虚拟机规范，有无安全隐患

- 准备：负责为类的类变量（被 static 修饰的变量）分配内存，并设置默认初始化值

  - 初始化静态变量

- 解析：将类的二进制数据流中的符号引用替换为直接引用

  - 本类中如果用到了其他类，此时就需要找到对应的类

##### 初始化

- 根据程序员通过程序指定的主观计划去初始化类变量和其他资源

  - 静态变量赋值以及初始化其他资源

### 类加载器分类

- 分类

  - Bootstrap class loader：虚拟机的内置类加载器，通常表示为 null ，并且没有父 null

  - Platform class loader：平台类加载器,负责加载 JDK 中一些特殊的模块

  - System class loader：系统类加载器,负责加载用户类路径上所指定的类库

- 类加载器的继承关系

  - System 的父加载器为 Platform

  - Platform 的父加载器为 Bootstrap

#### 双亲委派模型

![双亲委派模型](img\Java_14.png)

##### 双亲委派模型的流程

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行

2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器

3. 如果父类加载器可以完成类加载任务，就成功返回

4. 倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式

#### ClassLoader 常用方法

| 方法名                                              | 说明               |
| --------------------------------------------------- | ------------------ |
| public static ClassLoader getSystemClassLoader()    | 获取系统类加载器   |
| public InputStream getResourceAsStream(String name) | 加载某一个资源文件 |

## 配置文件

配置文件：用来保存程序在运行时需要的一些参数

常见的配置文件格式：TXT, Properties, XML

### 配置文件优缺点

- **TXT 文件**：

  - 优点：无

  - 缺点：不直观，不易维护

- **Properties 文件**：

  - 优点：键值对形式易于阅读、解析简单

  - 缺点：无法配置一组一组的数据

- **XML 文件**：

  - 优点：易于阅读，可以配置成组出现的数据

  - 缺点：解析比较复杂

### Properties

在 Java 中使用**Properties**类来处理这种类型的数据，它是一个轻量级的配置文件和键值对存储工具，用于存储应用程序的配置参数、用户首选项等等

#### 什么是 Properties

**Properties** 是 Java 标准库中的一个类，在 util 库下，用于处理配置文件和键值对存储。继承自 **Hashtable** 类，因此可以存储一组键值对，其中键和值都是字符串类型。

#### Properties 常用方法

| 方法名                                                        | 说明                                   |
| ------------------------------------------------------------- | -------------------------------------- |
| public void setProperty(String key, String value)             | 设置键值对                             |
| public String getProperty(String key)                         | 获取键值对                             |
| public void load(InputStream inputStream)                     | 从输入流中加载配置信息                 |
| public void store(OutputStream outputStream, String comments) | 存储配置信息到输出流，字符串为注释内容 |

#### 进阶用法

##### 默认值设置

`getProperty(String key, String defaultValue)`，若键值对不存在，则返回默认值（无）

##### 遍历 Properties

`.entrySet().stream().forEach(entry -> System.out.println(entry.getKey() + " = " + entry.getValue()));`

`.forEach((k, v) -> System.out.println(k + " = " + v));`遍历所有键值对

### XML

#### XML 概述

- XML 的全称为(Extensible Markup Language)，是一种**可拓展**的**标记语言**

- 标记语言：通过标签来描述数据的一门语言（标签有时候我们也将其称之为元素）

- 可拓展：标签的名字是可以自己定义的

#### XML 作用

- 用于进行存储数据和传输数据

- 作为软件的配置文件

#### XML 的创建、语法规则

- 创建一个 XML 类型的文件，要求文件的后缀必须使用 xml

- 文档声明必须是第一行

```xml
<?xml version="1.0" encoding="UTF-8"?>
version: XML默认的版本号码，该属性是必须存在的
encoding: 本XML文件的编码
```

- 标签由一对尖括号和合法标识符组成：`<name></name>`，必须存在一个根标签，**有且只能有一个**

- 标签必须成对出现，有开始，有结束：`<name></name>`

- 特殊的标签可以不成对，但是必须有结束标记，如：`<br/>`

- 标签中可以定义属性，属性和标签名之间空格隔开，属性和属性值之间用等号链接，属性值必须用引号引起来`<student id = "1"></student>`

- 标签需要正确的嵌套

- XML 文件中可以做定义注释信息：`<!- 注释内容 -->`

- XML 中可以存在以下特殊字符

  -`&lt` `<`：小于号

  -`&gt` `>`：大于号

  -`&amp` `&`：和号

  -`&apos` `'`：单引号

  -`&quot` `"`：双引号

- XML 文件中可以存在 CDATA 区：`<![CDATA[ ...内容... ]]>`

#### XML 文档约束

- 文档约束：是用来限定 xml 文件中的标签以及属性应该怎么写 -> 以此强制约束程序员必须按照文档约束的规定来编写 xml 文件

- 文档约束的分类

  - DTD（Document Type Definition）：定义 XML 文档的结构和元素

  - schema：定义 XML 文档的结构和元素，并对元素进行类型和约束的定义

##### DTD

1. DTD 约束文档，文件后缀是`.dtd`

![DTD约束文档](img\Java_15.png)

2. 在需要编写的 XML 文件中导入该 DTD 约束文档

- 引入本地 dtd

`<!DOCTYPE 根元素名称 SYSTEM 'dtd文件路径'>`

- 在 xml 文件内部引入

`<!DOCTYPE 根元素名称 [dtd文件内容]>`

- 引入网络 dtd

`<!DOCTYPE 根元素名称 PUBLIC "DTD文件名称" "DTD文档的URL">`

3. **按照约束的规定来编写 XML 文件的内容**

DTD 约束文档可以约束 XML 文件的编写，**不能约束具体的数据类型**

##### schema

- schema 可以约束具体的数据类型，约束能力上更强大

- schema 本身也是个 xml 文件，本身也受到其他约束文件的要求，所以编写的更加严谨

![schema约束](img\Java_16.png)

###### schema 使用方法

- 编写 schema 约束文档，后缀必须是`.xsd`

- 在需要编写的 XML 文件中导入该 schema 约束文档

![schema引入](img\Java_17.png)

- **按照约束内容编写 XML 文件的标签**

#### XML 解析

XML 的数据的作用是用来存储数据、做配置信息、进行数据传输，最终需要被程序进行读取，解析里面的信息

XML 解析：使用程序读取 XML 中的数据

两种解析方法：**DOM 解析** 和 **SAX 解析**

- SAX 解析：不会把整体的 XML 文件都加载到内存，而是从上往下进行扫描

  - 缺点：只能读取，不能添加，不能删除

  - 优点：因为是逐行扫描，不需要把整体的 xml 文件都加载到内存，所以可以用来解析比较大的 xml 文件

- DOM 解析：把整体的 XML 文件加载到内存，会把这整个 xml 文件在内存中形成一个树形结构，我们可以通过这个树形结构来解析 xml 文件

  - 优点：可以读取、可以添加、可以删除、可以对 xml 文件进行任何操作

  - 缺点：需要 xml 文件全部加载到内存，所以不能解析非常大的 xml 文件（对于现在的计算机，该缺点忽略不计）

##### DOM 解析

常见的解析工具：

![DOM解析工具](img\Java_18.png)

DOM 解析 XML 文档对象模型

![DOM解析流程](img\Java_19.png)

###### Dom4j 解析 XML

- 官网下载 Dom4j 框架，官网下载

- 在项目中创建目录：lib

- 引入 jar 包到 lib 文件夹下

- 在 lib 文件夹选择添加为库

- 在类中导入包使用

**Dom4j 解析 XML**

SAXReader 类：用来读取 XML 文件

| 方法名                    | 说明                            |
| ------------------------- | ------------------------------- |
| public SAXReader()        | 创建 Dom4J 的解析器对象         |
| Document read(String url) | 加载 XML 文件成为 Document 对象 |
| Document read(File file)  | 加载 XML 文件成为 Document 对象 |

Document 类：用来表示 XML 文档的树形结构

| 方法名                   | 说明                  |
| ------------------------ | --------------------- |
| Element getRootElement() | 获取 XML 文档的根元素 |

Element 类：用来表示 XML 文档中的元素

| 方法名                              | 说明                                                     |
| ----------------------------------- | -------------------------------------------------------- |
| List<Element> elements()            | 得到当前元素下的所有子元素                               |
| List<Element> elements(String name) | 得到当前元素下指定名字的子元素返回集合                   |
| Element element(String name)        | 得到当前元素下指定名字的子元素，若有很多同名则返回第一个 |
| String getName()                    | 得到当前元素的名字                                       |
| String attributeValue(String name)  | 通过属性名直接得到属性值                                 |
| String elementText(String name)     | 得到制定名称的子元素的文本                               |
| String getText()                    | 得到当前元素的文本                                       |

##### XPath 解析

- XPath 在解析 XML 文档方面提供了独树一帜的路径思想，更加优雅高效，更适合进行微信息检索

- XPath 使用**路径表达式**来定位 XML 文档中的元素节点或属性节点

## 单元测试

- 单元测试就是针对最小的功能单元编写测试代码，Java 程序最小的功能单元是方法，因此，单元测试就是针对 Java 方法的测试没劲儿检查方法的正确性

### Junit 单元测试框架

- JUnit 是使用 Java 语言实现的单元测试框架，开源

- 几乎所有 IDE 工具都集成了 JUnit，这样我们就可以直接在 IDE 中编写并运行 JUnit 测试

- JUnit 可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法

- 单元测试中的某个方法测试失效了，不会影响其他测试方法的测试

#### JUnit 快速入门

**编写测试方法：测试方法必须是公共的无参数无返回值的非静态方法**

在测试方法上使用`@Test`注解：标注该方法是一个测试方法

##### 使用经验

在实际开发过程中，想要测试一个方法是否正确，并不是直接在当前方法的上面写`@Test`

而是自己独立编写一个测试类（不要写 main 方法）

在这个测试类中编写一些测试方法，测试方法中调用要被测试的方法即可

##### 断点调试

`Assert`类，可以断点调试，可以查看断点处的变量值

`Assert.assertEquals("相同时候出现的提示信息",实际结果,预计值)`

#### JUnit 常用注解{#junit-annotation}

| 注解名       | 说明                                                       |
| ------------ | ---------------------------------------------------------- |
| @Test        | 标注一个方法为测试方法                                     |
| @Before      | 用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次 |
| @After       | 用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次 |
| @BeforeClass | 用来静态修饰方法，该方法会在所有测试方法之前只执行一次     |
| @AfterClass  | 用来静态修饰方法，该方法会在所有测试方法之后只执行一次     |

- 开始执行的方法：初始化资源

- 执行完之后的方法：释放资源

#### 相对路径

默认情况：相对路径是相对于项目

单元测试：相对路径是相对于测试类

## 注解

注解的主要作用：对我们的程序进行标注，通过注解可以给类增加额外的信息

注解是给编译器、JVM 看的，编译器或 JVM 可以根据注解来完成对应的功能

### Java 部分常用注解

| 注解名                   | 说明         |
| ------------------------ | ------------ |
| @Override                | 标注方法重写 |
| @Deprecated              | 标注过时方法 |
| @SuppressWarnings("all") | 压制警告信息 |

部分第三方注解，详见[JUnit 常用注解](#junit-annotation)

### 自定义注解

自定义注解单独存在无意义，一般和反射结合使用，会用反射去解析注解

#### 格式

```java
public @interface 注解名称 {
  public 属性类型 属性名() default 默认值;
}
```

使用自定义注解格式

`@注解名(属性名1 = 属性值1，属性名2 = 属性值2)`

**特殊属性**

- value 属性，如果只有一个 value 属性的情况下，使用 value 属性可以省略 value 名称不写

- 如果有多个属性，且多个属性没有默认值，那么 value 名称是不能省略的

### 元注解

- 元注解：就是注解注解的注解。写在注解上面的注解

- `@Target`：约束自定义注解只能在哪些地方使用，其中可使用的值定义在 ElementType 中，常用值如下

  - **TYPE** 类、接口

  - **FIELD** 成员变量

  - **METHOD** 成员方法

  - **PARAMETER** 方法参数

  - **CONSTRUCTOR** 构造器

  - **LOCAL_VARIABLE** 局部变量

- `@Retention`：申明注解的生命周期，其中可使用的值定义在 RetentionPolicy 中，常用值如下

  - **SOURCE** 注解只作用在源码阶段，生成的字节码文件中不存在

  - **CLASS** 注解作用在源码阶段、字节码阶段，运行阶段不存在（默认值）

  - **RUNTIME** 注解作用在源码阶段、字节码阶段、运行阶段（开发常用）

## Schedule-System 项目笔记

### MVC 架构

#### pojo 层

##### pojo 层作用

- 类中定义了多个类属性，并与数据库表的字段保持一致，一张表对应一个 model 类。

- 主要用于定义与数据库对应的类对象，提供 get/set 方法,tostring 方法,有参无参构造函数。

##### 实体类

1. 实体类的类名和表格名称应该对应（对应不是一致）

2. 实体类的属性名和表格的列名应该对应

3. 每个属性都必须是私有的

4. 每个属性都应该具备 getter 和 setter 方法

5. 必须具备无参构造器

6. 应该实现序列化接口（缓存 分布式项目数据传递 可能会将对象序列化）

7. 应该重写类的 HashCode 和 equals 方法

8. toString 是否重写都可以

9. 使用 Lombok 注解，帮助生成 getter setter 全参构造 无参构造 equals hashCode 方法

- lombok 使用方法：

  - 引入 Lombok 插件依赖

  - 在设置-编译器-注解处理器-启用注解处理

  - 在需要使用 Lombok 注解的类上添加相应注解：

    - @Data：包括了 @Getter、@Setter、@ToString、@EqualsAndHashCode 四种注解的功能，生成 getter setter equals hashCode toString 方法

    - @AllArgsConstructor：生成全参构造器

    - @NoArgsConstructor：生成无参构造器

#### dao 层

##### dao 层作用

Data access Object，数据访问对象，该类中用于定义对表格 CRUD 的方法

Dao 层一般需要定义接口和实现类（接口用于定义方法，实现类用于实现接口方法）其他程序员无需关注具体实现，只需要调用接口方法即可

接口处要添加合理的文档注释

```java
/**
 * 介绍一下当前类...
 * 作者：
 * 时间：
 */
```

`@param` ：是一个用于文档注释的标记，用于描述方法的参数，提供关于参数的详细信息

`@return` ：是一个用于文档注释的标记，用于描述方法的返回值，提供关于返回值的详细信息

#### util 软件包

##### util 软件包作用

- 该软件包中定义了一些工具类，比如分页工具类，加密工具类，邮件工具类等。

- 工具类一般都定义为静态类，提供一些工具方法，方便其他程序员调用。

如 JDBCUtil 工具类，用于提供 JDBC 相关的工具方法，如获取数据库连接，关闭数据库连接等，约定俗成的工具包。

#### service 层

##### service 层作用

- 该层中定义了一些业务逻辑，比如用户注册，用户登录，用户信息修改等。

#### controller 层

直接使用实现类定义，因为 Servlet 技术的特殊性，使用定义接口反而会干扰代码的可读性

contorller 层需要判断请求的类型，然后调用相应的业务逻辑，所以设置 RequestURI 为 `/service/*`

使用反射技术，根据请求的 URI 调用相应的业务逻辑，并返回相应的结果（方便后续根据返回结果设置方法名进行跳转）

#### 业务需求写入

从前端至后端，以 controller 层为起点（前端请求 controller 层），调用 service 层的业务逻辑，service 再调用 dao 层的数据库信息处理，pojo 层可以作为中间对象传输，前端根据返回结果设置相应结果

### 监听器限制登录状态

对于需要限制状态的页面，如后台管理页面，需要在每次请求页面时判断用户是否登录，如果用户未登录，则跳转到登录页面。为了实现该需求，使用监听 session 域信息和过滤器技术实现。

### 校验用户名是否占用

使用 Ajax 技术，在用户名输入框输入时，通过后台请求判断用户名是否存在，如果存在，则提示用户名已存在，如果不存在，则提示用户名可以使用。

#### 跨域过滤器

为了避免违背同源策略，需要在服务器端配置跨域过滤器，以允许跨域请求。

未来使用框架，直接使用 `@CrossOrigin` 解决解决跨域问题

## Maven

Maven 的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM:Project Object Model）

Maven 结构：

![Maven项目的核心组件及其相互关系](img/Java_20.png)

Maven 的作用：

- 项目构建：提供标准的、跨平台的自动化项目构建方式

- 依赖管理：方便快捷的管理项目依赖的资源（jar 包），避免资源间的版本冲突问题

- 统一开发结构：提供标准的、统一的项目结构

### 仓库

**仓库**：用于存储资源，包含各种 jar 包

**仓库分类**：

- 本地仓库：自己电脑上存储资源的仓库，连接远程仓库获取资源

- 远程仓库：非本机电脑上的仓库，为本地仓库提供资源

  - 中央仓库：Maven 团队维护，存储所有资源的仓库（mvnrepository.com）

  - 私服：部门/公司范围内存储资源的仓库，从中央仓库获取资源

**私服的作用**：

- 保存具有版权的资源，包含购买或自主研发的 jar

  - 中央仓库中的 jar 都是开源的，不能存储具有版权的资源

- 一定范围内共享资源，仅对内部开放，不对外共享

### 坐标

坐标：Maven 中的坐标用于描述仓库中资源的位置

- Maven 坐标主要组成：

  - groupId：定义当前 Mabem 项目隶属组织名称（通常是域名反写，例如：org.mybatis）

  - artifactId：定义当前 Maven 项目名称（通常是模块名称，例如 CRM、SMS）

  - version：定义当前项目版本号

  - packaging：定义该项目的打包方式

- Maven 坐标的作用：

  使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成

### 配置

#### 本地仓库配置

在 maven 安装路径中的`conf/setting.xml`，使用`<localRepository>`进行定义

#### 远程仓库配置

在 `maven-model-builder-{version}.jar/org/apache/maven/model/pom-4.0.0.xml` 中 `<repositories>` 可以发现初始定位

仍然在 `setting.xml` 中进行配置， `<mirrors>` 标签中添加如下内容

```xml
<mirror>
  <!-- 此镜像的唯一标识符，用来区分不同的mirror元素 -->
  <id>nexus-aliyun</id>
  <!-- 对哪种仓库进行镜像，简单来说就是替代哪个仓库 -->
  <mirrorOf>central</mirrorOf>
  <!-- 镜像名称 -->
  <name>Nexus aliyun</name>
  <!-- 镜像url -->
  <url>http://maven.aliyun.com/nexus/content/groups/public</url>
</mirror>
```

### Maven 构建项目

Maven 工程目录结构：

![Maven工程目录结构](img/Java_21.png)

在`src`同级目录中创建`pom.xml`文件

基础`pom.xml`文件结构

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project
  xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>

  <groupId>com.example</groupId>
  <artifactId>myproject</artifactId>
  <version>1.0</version>
  <packaging>jar</packaging>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
    <dependency>
  </dependencies>

</project>
```

#### Maven 项目构建命令

- Maven 构建命令使用`mvn`开头，后面添加功能参数，可以一次执行多个命令，使用空格分隔

```shell
mvn compile # 编译项目
mvn clean   # 清理项目
mvn test    # 运行测试用例
mvn package # 打包项目
mvn install # 安装项目到本地仓库
```

#### 插件创建工程

创建工程

```shell
mvn archetype:generate -DgroupID={project-packaging} -DartifactId={project-name} -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
```

创建 Java 工程

```shell
mvn archetype:generate -DgroupId=com.itheima -DartifactId=java-project -DarchetypeArtifactId=maven-archetype-quickstart -Dversion=0.0.1-snapshot -DinteractiveMode=false
```

创建 Web 工程

```shell
mvn archetype:generate -DgroupId=com.itheima -DartifactId=web-project -DarchetypeArtifactId=maven-archetype-webapp -Dversion=0.0.1-snapshot -DinteractiveMode=false
```

#### 依赖配置

在`pom.xml`文件中

```xml
<!-- 设置当前项目所依赖的所有jar -->
<dependencies>
  <!-- 设置具体的依赖 -->
  <dependency>
    <!-- 依赖所属群组id -->
    <groupId>junit</groupId>
    <!-- 依赖所属项目id -->
    <artifactId>junit</artifactId>
    <!-- 依赖版本号 -->
    <version>4.12</version>
  </dependency>
</dependencies>
```

**依赖传递**

- 依赖具有传递性：

  - 直接依赖：在当前项目中通过依赖配置建立的依赖关系

  - 间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源

**依赖冲突问题**

- 路径优先：当依赖中出现相同的资源时，层级越低，优先级越低；层级越浅，优先级越高

- 声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的

- 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的

**可选依赖**

- 可选依赖指对外隐藏当前所依赖的资源——不透明，将标签`<optional></optional>`的值设置为 true

**排除依赖**

在资源下，创建`exclusion`标签，用于排除依赖

```xml
<dependencies>
  <dependency>
    <groupId>com.itheima</groupId>
    <artifactId>project</artifactId>
    <version>1.0-SNAPSHOT</version>
    <exclusions>
      <exclusion>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
      </exclusion>
    </exclusions>
  </dependency>
</dependencies>
```

**依赖范围**

依赖的 jar 默认情况可以在任何地方使用，可以通过`<scope></scope>`标签设定其作用范围

作用范围：

- 主程序范围有效（main 文件夹范围内）

- 测试程序范围内有效（test 文件夹范围内）

- 是否参与打包（package 指令范围内）

| scope    | 主代码 | 测试代码 | 打包 | 范例        |
| -------- | ------ | -------- | ---- | ----------- |
| compile  | Y      | Y        | Y    | log4j       |
| test     | N      | Y        | N    | junit       |
| provided | Y      | Y        | N    | servlet-api |
| runtime  | N      | N        | Y    | jdbc        |

**依赖范围的传递性**

- 带有以来范围的资源在进行传递时，作用范围将受到影响

| ROW 直接依赖，COL 间接依赖 | scmpile | test | provided | runtime |
| -------------------------- | ------- | ---- | -------- | ------- |
| compile                    | compile | test | provided | runtime |
| test                       | None    | None | None     | None    |
| provided                   | None    | None | None     | None    |
| runtime                    | runtime | test | provied  | runtime |

### 生命周期与插件

#### 项目构建生命周期

compile -> test-compile -> test -> package -> install

Maven 对项目构建的生命周期划分为 3 套

- clean：清理工作

  - pre-clean：执行一些需要在clean之前完成的工作

  - clean：移除所有上一次构建生成的文件

  - post-clean：执行一些需要在clean后立刻完成的工作

- default：核心工作，例如编译、测试、打包、部署等（部分）

  - compile：编译项目的源代码

  - test-compile：编译测试源代码

  - test：运行测试

  - package：打包项目

  - install：安装项目到本地仓库

- site：产生报告，发布站点等

  - pre-site：执行一些需要在生成站点文档之前完成的工作

  - site：生成项目的站点文档

  - post-site：执行一些需要在生成站点文档之后完成的工作，并且为部署准备

  - site-deploy：将生成的站点文档部署到特定的服务器上

#### 插件

- 插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能

- 默认maven在各个生命周期上绑定有预设的功能

- 通过插件可以自定义其他功能

## JavaSSM 框架

### Spring 框架

企业级一站式框架：某特定领域系统的一组约定、标准、代码库以及工具的集合。框架作为项目的骨架和基础结构，提供了高层次的抽象和可复用性，而工具作为辅助手段，帮助开发者完成特定任务并提高工作效率

Spring 是一个**IoC(DI)**和**AOP**框架

特性：

- 非侵入式：基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API

- 依赖注入：DI(Dependency Injection)是控制反转(IoC)最经典的实现

- 面向切面编程：Aspect Oriented Programming - AOP

- 容器：Spring 是一个容器，包含并管理应用对象的生命周期

- 组件化：Spring 通过将众多简单的组件配置组合成一个复杂应用

- 一站式：Spring 提供了一系列框架，解决了应用开发中的众多问题

#### 组件和容器

**组件**：具有一定功能的对象

**容器**：管理组件（创建、获取、保存、销毁）

#### IoC 和 DI

- **Ioc**：Inversion of Control （控制反转）思想

  - **控制**：资源的控制权（资源的创建、获取、销毁等）

  - **反转**：和传统的方式不同

- **DI**：Dependency Injection （依赖注入）实现方法

  - **依赖**：组件的依赖关系，如 NewsController 依赖 NewsService

  - **注入**：通过 Setter 方法、构造器等方式自动的注入（赋值）

#### 容器的注册

新建 Maven 项目，引入 Spring 依赖
