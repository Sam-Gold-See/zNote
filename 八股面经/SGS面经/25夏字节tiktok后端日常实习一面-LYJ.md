1 进程线程协程区别
2 协程
3 死锁条件
4 如何解决
5tcp udp 区别
6 三次握手四次挥手
7time_wait
8http 各版本区别
9 网址请求流程 拓展如果是返回的是图片资源
10websocket
11 弱网情况下
12 心跳机制
13mysql 数据结构
14 为什么 b+
15 索引
16 索引失效
17 模糊情况下是否都失效
18 分库分表
19 主从时延的可能
20 如何解决
21redis 数据结构
22 实现
23zset 实现
24 跳表实现
25 持久化
26aof 和 rdb 区别
27 如何恢复
28 微服务和传统优势
29 微服务特别的优势
30 微服务通信
31 讲讲 protobuf
32protobuf 优势
33 项目一结构
34 线程池实现
35 项目二 rbac 是什么
36redis 和 mysql 一致性
37 如果用 canal 伪装从库强一致性如何保证
38 实现 kvlru，附带过期机制
39redis 内存淘汰机制

以下是针对面经问题的系统整合与解答，涵盖操作系统、网络、数据库、Redis、微服务等核心领域：

---

### **一、操作系统**

1. **进程、线程、协程区别**

   - **进程**：资源分配的最小单位，有独立内存空间，切换开销大。
   - **线程**：CPU 调度的最小单位，共享进程内存，切换开销中等（需内核介入）。
   - **协程**：用户态轻量级线程，由程序控制切换，开销极小（无需内核参与），适合高并发 I/O 密集型任务。

2. **协程（Coroutine）**

   - **特点**：单线程内实现并发，通过 `yield` 让出执行权，避免阻塞等待。
   - **优势**：无锁、高并发（如 Go 的 goroutine，Python 的 asyncio）。

3. **死锁条件 & 解决方案**
   - **必要条件**：互斥、持有并等待、不可剥夺、环路等待。
   - **解决方案**：
     - 破坏环路等待：资源按序申请（如统一编号，从小到大获取）。
     - 超时释放：申请资源超时则释放已持有资源（如数据库锁超时）。
     - 死锁检测：定时检测环路并终止进程（如数据库死锁回滚）。

---

### **二、网络协议**

#### **TCP vs UDP**

| **特性** | TCP                  | UDP         |
| -------- | -------------------- | ----------- |
| 连接     | 面向连接             | 无连接      |
| 可靠性   | 可靠（重传、确认）   | 不可靠      |
| 有序性   | 保证数据顺序         | 不保证      |
| 速度     | 慢（握手、拥塞控制） | 快          |
| 适用场景 | 文件传输、HTTP       | 视频流、DNS |

5. **三次握手**

   ```plaintext
   Client → SYN → Server
   Client ← SYN+ACK ← Server
   Client → ACK → Server
   ```

   **目的**：同步序列号，确保双方收发能力正常。

6. **四次挥手**

   ```plaintext
   Client → FIN → Server
   Client ← ACK ← Server
   Client ← FIN ← Server
   Client → ACK → Server → 进入TIME_WAIT
   ```

   **目的**：双方确认关闭连接，处理残留数据。

7. **TIME_WAIT**

   - **时长**：2MSL（Max Segment Lifetime，通常 2 分钟）。
   - **作用**：确保最后一个 ACK 被接收（防止旧连接数据干扰新连接）。

8. **HTTP 各版本区别**  
   | **版本** | 关键特性 |
   | -------- | ---------------------------------- |
   | HTTP/1.0 | 短连接（每个请求新建 TCP 连接） |
   | HTTP/1.1 | 长连接、管道化、Host 头 |
   | HTTP/2 | 二进制分帧、多路复用、头部压缩 |
   | HTTP/3 | 基于 QUIC（UDP）、0-RTT、防队头阻塞 |

9. **网址请求流程（含图片断点续传）**

   1. DNS 解析 → 2. TCP 握手 → 3. HTTP 请求 → 4. 服务器响应  
      **断点续传**：

   - 客户端请求头：`Range: bytes=500-1000`
   - 服务端响应头：`206 Partial Content` + `Content-Range: bytes 500-1000/2000`

10. **WebSocket**

    - **特点**：全双工通信，服务端可主动推送数据（如聊天室、实时游戏）。
    - **建立**：HTTP 升级请求（`Upgrade: websocket`）。

11. **弱网优化**

    - **策略**：TCP 优化（调整拥塞窗口）、UDP+重传（QUIC）、数据压缩、降级策略。

12. **心跳机制**
    - **作用**：检测连接存活，防止僵尸连接（如 TCP Keepalive、WebSocket Ping/Pong）。
    - **实现**：客户端定时发送空包，服务端超时无响应则断开。

---

### **三、数据库（MySQL）**

13. **MySQL 数据结构**

    - **InnoDB 引擎**：B+树索引，数据按主键聚簇存储。

14. **为什么用 B+树？**

    - **对比 B 树**：
      - 叶子节点链表结构，适合范围查询。
      - 非叶子节点不存数据，单次 I/O 可读更多索引。
      - 查询更稳定（所有数据在叶子层）。

15. **索引类型**

    - **聚簇索引**：叶子节点存完整数据（如主键索引）。
    - **非聚簇索引**：叶子节点存主键值（需回表查询）。

16. **索引失效场景**

    - 对索引列运算（`WHERE age+1>20`）
    - 类型转换（字符串列用数字查询）
    - 左模糊匹配（`LIKE '%abc'`）
    - 联合索引未遵循最左前缀

17. **模糊查询是否都失效？**

    - **右模糊**（`LIKE 'abc%'`）→ **可用索引**
    - **左模糊**（`LIKE '%abc'`）→ **索引失效**

18. **分库分表**

    - **垂直拆分**：按业务分离表（如用户库、订单库）。
    - **水平拆分**：按分片键（如用户 ID）分散数据到多个表/库。

19. **主从时延原因**

    - 主库并发写入高 → 从库 SQL 单线程回放
    - 网络延迟
    - 从库读压力大

20. **主从时延解决方案**
    - 读写分离：写主库，读从库（容忍延迟）。
    - 半同步复制：写操作需至少一个从库确认。
    - 并行复制（MySQL 5.7+）：从库多线程回放。

---

### **四、Redis**

21. **数据结构**  
    | **类型** | 使用场景 |
    | -------- | ---------------------- |
    | String | 缓存、计数器 |
    | Hash | 对象属性（如用户信息） |
    | List | 消息队列、时间线 |
    | Set | 去重（如点赞用户） |
    | ZSet | 排行榜（带权重排序） |

22. **底层实现**

    - **String**：SDS（动态字符串）。
    - **Hash**：ziplist（小数据）或 hashtable。
    - **ZSet**：ziplist + 跳表（skiplist）。

23. **ZSet 实现（跳表）**

    - **结构**：多层链表，上层是下层的“快速通道”。
    - **查询**：从顶层开始，向右向下搜索（平均 O(log N)）。
    - **插入**：随机确定节点层高（概率 1/2^k）。

24. **跳表示意图**

    ```plaintext
    层3： 1 → 5 → 9
    层2： 1 → 3 → 5 → 7 → 9
    层1： 1→2→3→4→5→6→7→8→9
    ```

25. **持久化方式**

    - **RDB**：定时内存快照（二进制文件），恢复快，可能丢数据。
    - **AOF**：记录写命令（文本文件），数据安全，文件大恢复慢。

26. **AOF vs RDB**  
    | **对比项** | RDB | AOF |
    | ---------- | -------------------- | ---------------- |
    | 数据安全 | 可能丢失最后一次快照 | 可配置为秒级同步 |
    | 恢复速度 | 快 | 慢（需重放命令） |
    | 文件大小 | 小（压缩二进制） | 大（文本命令） |

27. **数据恢复**

    - 重启时优先加载 AOF（数据更完整），无 AOF 则加载 RDB。

28. **Redis 内存淘汰机制**
    - **策略**：
      - `volatile-lru`：从过期键中淘汰最近最少使用。
      - `allkeys-lru`：全局淘汰最近最少使用。
      - `volatile-ttl`：淘汰即将过期的键。
      - `noeviction`：不淘汰，写操作返回错误（默认）。

---

### **五、微服务**

29. **微服务 vs 单体架构**  
    | **对比项** | 微服务 | 单体架构 |
    | ---------- | ------------------ | ------------------ |
    | 开发效率 | 独立开发部署（快） | 耦合高（慢） |
    | 可维护性 | 模块清晰（易维护） | 代码膨胀（难维护） |
    | 技术栈 | 多语言混合 | 统一技术栈 |
    | 容错 | 故障隔离（高可用） | 单点故障 |

30. **微服务通信**

    - **同步**：REST（HTTP）、gRPC（HTTP/2）。
    - **异步**：消息队列（Kafka、RabbitMQ）。

31. **Protobuf（Protocol Buffers）**
    - **定义**：二进制序列化协议（IDL 定义接口）。
    - **优势**：
      - 高效：体积小、编解码快（比 JSON 小 3~10 倍）。
      - 跨语言：自动生成多语言代码。
      - 版本兼容：字段可增删（通过编号标识）。

---

### **六、项目设计**

33. **线程池实现**

    - **核心组件**：
      1. 任务队列（阻塞队列）
      2. 工作线程集合
      3. 拒绝策略（如丢弃、抛异常）
    - **流程**：任务提交 → 队列满？→ 拒绝或入队 → 线程消费任务。

34. **RBAC（基于角色的访问控制）**

    - **模型**：用户 → 角色 → 权限（如管理员、普通用户）。
    - **表设计**：
      - `user`、`role`、`permission`
      - 关联表：`user_role`、`role_permission`

35. **Redis 与 MySQL 一致性**

    - **策略**：
      - 缓存失效：写 DB 后删缓存（延迟双删防脏读）。
      - 异步同步：通过消息队列更新缓存。

36. **Canal 伪装从库保证强一致性**

    - **原理**：
      1. Canal 解析 MySQL binlog → 2. 发送变更事件到 MQ → 3. 消费者更新 Redis。
    - **强一致性**：
      - 事务提交后同步发送 binlog（半同步复制）。
      - 消费者 ACK 机制确保 Redis 更新成功。

37. **实现 KVLru（带过期）**

---

### **总结高频考点**

- **索引**：B+树原理、失效场景、最左前缀
- **Redis**：跳表、持久化、缓存一致性
- **网络**：TCP 握手/挥手、HTTP/2 特性
- **并发**：死锁、线程池、协程优势

> 建议结合实践场景理解理论（如用 Wireshark 分析 TCP 握手，用 EXPLAIN 分析 SQL 索引），面试时清晰表述设计权衡（如选 LRU vs LFU）。
