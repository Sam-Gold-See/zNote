# MySQL

## 数据库概述

### 为什么要用数据库

- 持久化（persistence）：**把数据保存到可掉电式存储设备中以供之后使用**。大多数情况下，特别是企业级应用，**数据持久化意味着将内存中的数据保存到硬盘上加以固化**，而持久化的实现过程大多通过各种关系数据库来完成

- 持久化的主要作用是**将内存中的数据存储在关系型数据库中**，当然也可以存储在磁盘文件、XML 数据文件中

![数据与持久化](img/MySQL_1.png)

### 数据库与数据库管理系统

#### 数据库相关概念

| 术语                                               | 解释                                                                                                                                     |
| -------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| DB：数据库（Database）                             | 即存储数据的“仓库”，其本质是一个文件系统，它保存了一系列有组织的数据。                                                                   |
| DBMS：数据库管理系统（Database Management System） | 是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。 |
| SQL：结构化查询语言（Structured Query Language）   | 专门用来与数据库通讯的语言                                                                                                               |

#### 数据库与数据库管理系统的关系

数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为了保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。

![数据库与数据库管理系统的关系](img/MySQL_2.png)

### MySQL 简介

#### 概述

- MySQL 是一个 **开放源代码的关系型数据库管理系统**

- MySQL 是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。

- MySQL6.x 版本之后分为社区版和商业版。

- MySQL 是开源的，所以不需要支付额外的费用。

- MySQL 是可以定制的，采用了 GPL（GNU General Public License） 协议，你可以修改源码来开发自己的 MySQL 系统。

- MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。

- MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB ，64 位系统支持最大的表文件为 8TB 。

- MySQL 使用 标准的 SQL 数据语言 形式。

- MySQL 可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP 和 Ruby 等。

#### 关于 MySQL 8.0

MySQL 从 5.7 版本直接跳跃发布了 8.0 版本。MySQL 8 版本在功能上做了显著的改进与增强，开发者对 MySQL 的源代码进行了重构，最突出的一点是多 MySQL Optimizer 优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。

#### 为什么选择 MySQL

1. 开放源代码，使用成本低。
2. 性能卓越，服务稳定。
3. 软件体积小，使用简单，并且易于维护。
4. 历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。
5. 许多互联网公司在用，经过了时间的验证。

#### Oracle VS MySQL

- Oracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。

- MySQL 由于其**体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码**这一特点，使得很多互联网公司、中小型网站选择了 MySQL 作为网站数据库（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。

### RDBMS 与 非 RDBMS

关系型数据库是 DBMS 的主流，使用最多的 DBMS 依次是 Oracle、 MySQL、 SQL Server，这些都是关系型数据库（RDBMS）。

#### 关系型数据库(RDBMS)

##### 实质

- 这种类型的数据库是**最古老**的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的**二元关系**（即二维表格形式）。

- 关系型数据库以 **行(row)** 和 **列(column)** 的形式存储数据，以便于用户理解。这一系列的行和列被称为 **表(table)** ，一组表组成了一个**库(database)**。

- 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用 **关系模型** 来表示。关系型数据库，就是建立在 **关系模型** 基础上的数据库。

- SQL 就是关系型数据库的查询语言

##### 优点

- **复杂查询** 可以用 SQL 语句方便的在一个表以及多个表之间做非常复杂的数据查询

- **事务支持** 使得对于安全性能很高的数据访问要求得到实现

#### 非关系型数据库(非 RDBMS)

##### 介绍

**非关系型数据库**， 可看成传统关系型数据库的功能 **阉割版本** ，基于键值对存储数据，不需要经过 SQL 层的解析， **性能非常高** 。同时，通过减少不常用的功能，进一步提高了数据库的性能。

目前基本上大部分主流的非关系型数据库都是免费的

##### 类型

- **键值型数据库**

键值型数据库通过 **Key-Value** 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。

键值型数据库典型的使用场景是作为 **内存缓存** 。 **Redis** 是最流行的键值型数据库

![键值型数据库](img/MySQL_3.png)

- **文档型数据库**

此类数据库可存放并获取文档，可以是 XML、JSON 等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB 是最流行的文档型数据库。此外，还有 CouchDB 等。

- **搜索引擎数据库**

虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。

典型产品：Solr、Elasticsearch、Splunk 等

- **列式数据库**

列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase 等。

- **图形数据库**

图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。

图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。

典型产品：Neo4J、InfoGrid 等。

### 关系型数据库设计规则

- 关系型数据库的典型数据结构就是 **数据表** ，这些数据表的组成都是结构化的(Structured)

- 将数据放到表中，表再放到库中。

- 一个数据库中可以有多个表，每个表都有一个名字标记自己，表名具有唯一性

- 表具有一些特征，这些特征定义了数据在表中如何存储，类似 Java 中的 类

#### 表、记录、字段

- E-R（entity-relationship）模型中有三个主要概念：**实体集** 、 **属性** 、 **联系集**

- 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）

![E-R模型主要概念](img/MySQL_4.png)

> ORM 思想 (Object Relational Mapping)体现：
> 数据库中的一个表 <---> Java 或 Python 中的一个类
> 表中的一条数据 <---> 类中的一个对象（或实体）
> 表中的一个列 <----> 类中的一个字段、属性(field)

#### 表的关联关系

- 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。

- 四种：一对一关联、一对多关联、多对多关联、自我引用

##### 一对一关联（one-to-one）

- 在实际的开发中应用不多，因为一对一可以创建成一张表。

- 举例：设计 学生表 ：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、...

  - 拆为两个表：两个表的记录是一一对应关系。
  - **基础信息表** （常用信息）：学号、姓名、手机号码、班级、系别
  - **档案信息表** （不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、...

- 两种建表原则：

  - 外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。

  - 外键是主键：主表的主键和从表的主键，形成主外键关系。

##### 一对多关联（one-to-many）

- 常见实例场景： **客户表和订单表**， **分类表和商品表**， **部门表和员工表**

- 举例：

  - 员工表：编号、姓名、...、所属部门
  - 部门表：编号、名称、简介

- 一对多建表原则：在从表（多方）创建一个字段，字段作为外键指向主表（一方）的主键。

##### 多对多关联（many-to-many）

要表示多对多关系，必须创建第三个表，该表通常称为 **联接表** ，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。

- 举例 1：学生-课程

  - **学生信息表** ：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别...）
  - **课程信息表** ：一行代表一个课程的信息（课程编号、授课老师、简介...）
  - **选课信息表** ：一个学生可以选多门课，一门课可以被多个学生选择

- 举例 2：产品-订单

  “订单”表和“产品”表有一种多对多的关系，这种关系是通过与“订单明细”表建立两个一对多关系来定义的。一个订单可以有多个产品，每个产品可以出现在多个订单中。

  - **产品表** ：“产品”表中的每条记录表示一个产品。
  - **订单表** ：“订单”表中的每条记录表示一个订单。
  - **订单明细表** ：每个产品可以与“订单”表中的多条记录对应，即出现在多个订单中。一个订单可以与“产品”表中的多条记录对应，即包含多个产品。

##### 自我引用（self-reference）

![自我引用](img/MySQL_5.png)

自我引用是指一个表中包含了对自己（表）的引用。

## MySQL 环境搭配

### MySQL 的卸载

1. 停止 MySQL 服务：在任务管理器停止 MySQL 服务。

2. 卸载软件

3. 删除环境变量配置

### MySQL 的 4 大版本

- MySQL Community Server 社区版本，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户。
- MySQL Enterprise Edition 企业版本，需付费，不能在线下载，可以试用 30 天。提供了更多的功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户。
- MySQL Cluster 集群版，开源免费。用于架设集群服务器，可将几个 MySQL Server 封装成一个 Server。需要在社区版或企业版的基础上使用。
- MySQL Cluster CGE 高级集群版，需付费。

### MySQL 的启动、停止服务

使用**管理员身份**运行命令行，输入以下命令：

- 启动 MySQL 服务：`net start mysql`

- 停止 MySQL 服务：`net stop mysql`

## MySQL 的使用

### MySQL 的部分命令

1. 查看数据库列表：`show databases;`

> “information_schema”是 MySQL 系统自带的数据库，主要保存 MySQL 数据库服务器的系统信息，比如数据库的名称、数据表的名称、字段名称、存取权限、数据文件 所在的文件夹和系统使用的文件夹，等等

> “performance_schema”是 MySQL 系统自带的数据库，可以用来监控 MySQL 的各类性能指标。

> “sys”数据库是 MySQL 系统自带的数据库，主要作用是以一种更容易被理解的方式展示 MySQL 数据库服务器的各类性能指标，帮助系统管理员和开发人员监控 MySQL 的技术性能。

> “mysql”数据库保存了 MySQL 数据库服务器运行时需要的系统信息，比如数据文件夹、当前使用的字符集、约束检查信息，等等

2. 创建数据库：`create database 数据库名;`不能和已有的数据库重名

3. 使用自己的数据库：`use 数据库名;`

- 如果没有使用`use`语句，后面针对数据库的操作也没有加“数据名”的限定，则会报错

- 使用完`use`语句后，如果接下来的 SQL 都是针对同一个数据库操作的，那就不用重复 use 了，如果要针对另一个数据库操作，那么需要重新 use

4. 查看某个库的所有表格：`show tables;`

- 前面要先`use`指定的数据库，否则会报错

5. 创建新的表格：

```
create table 表格名 (
    字段名1 数据类型1,
    字段名2 数据类型2,
    字段名3 数据类型3
);
```

- 如果是最后一个字段，后面就不用加逗号，因为逗号的作用是分割每一个字段

6. 查看一个表的数据：`select * from 表格名;`

7. 添加一条记录：`insert into 表名称 values(值列表);`

8. 查看表的创建信息：`show create table 表名称\G`

9. 查看数据库的创建信息：`show create database 数据库名称\G`

10. 删除表：`drop table 表名称;`

11. 删除数据库：`drop database 数据库名称;`

12. 查看当前数据库的端口号：`select @@port;`

### MySQL 目录结构与源码

#### 主要目录结构

| MySQL 的目录结构                               | 说明                                   |
| ---------------------------------------------- | -------------------------------------- |
| /bin                                           | 所有 MySQL 的可执行文件，如：mysql.exe |
| MySQLInstanceConfig.exe                        | 数据库的配置向导，在安装时出现的内容   |
| /data                                          | 系统数据库所在的目录                   |
| my.inl                                         | MySQL 的主要配置文件                   |
| C:\Program Files\MySQL\MySQL Server 8.4\data\  | 用户创建的数据库所在的目录             |

#### MySQL 源代码获取

首先，进入 MySQL 下载界面。不要选择用默认的“Microsoft Windows”，而是要通过下拉栏，找到“Source Code”，在下面的操作系统版本里面， 选择 Windows（Architecture Independent），然后点击下载。

接下来，把下载下来的压缩文件解压，就得到了 MySQL 的源代码。

MySQL 是用 C++ 开发而成的。

mysql-8.0.22 目录下的各个子目录，包含了 MySQL 各部分组件的源代码：

![MySQL 源代码目录结构](img/MySQL_6.png)

- sql 子目录是 MySQL 核心代码；

- libmysql 子目录是客户端程序 API；

- mysql-test 子目录是测试工具；

- mysys 子目录是操作系统相关函数和辅助函数；

## 基本的 SELECT 语句

### SQL 概述

SQL(Structured Query Language，结构化查询语言)是使用关系模型的数据库应用语言，**与数据直接打交道**

SQL 有两个重要标准，分别是 SQL92 和 SQL99。分别代表了 92 年和 99 年颁布的 SQL 标准。

不同的数据生产厂商都支持 SQL 语句，但都有特有内容。

- SQL 规范（普通话）
  - MySQL 特有（方言）
  - Oracle 特有（方言）

#### SQL 分类

SQL 语言在功能上主要分为如下 3 大类：

- **DDL（Data Definition Language，数据定义语言）**，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构

  - 主要的语句关键字包括`CREATE`、`DROP`、`ALTER`等

- **DML（Data Manipulation Language，数据操纵语言）**，用于添加、删除、更新和查询数据库记录，并检查数据完整性

  - 主要的语句关键字包括`INSERT`、`DELETE`、`UPDATE`、`SELECT`等

  - **SELECT**是 SQL 语言的基础，最为重要。

- **DCL（Data Control Language，数据控制语言）**，用于定义数据库、表、字段、用户的访问权限和安全级别。

  - 主要的语句关键字包括`GRANT`、`REVOKE`、`COMMIT`、`ROLLBACK`、`SAVEPOINT`等

> 因为查询语句使用得非常频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。

> 还有单独将`COMMIT`、`ROLLBACK`取出来称为 TCL（Transaction Control Language，事务控制语言）。

### SQL 语言的规则与规范

#### 基本规则

- SQL 语句可以写在一行或者多行。为了提高可读性，各子句分行写，必要时候使用缩进

- 每条命令以`;`或`\g`或`\G`结束

- 关键字不能被缩写也不能分行

- 关于标点符号：

  - 必须保证所有的`()`、单引号、双引号是成对结束的

  - 必须使用英文状态下的半角输入方式

  - 字符串型和日期时间类型的数据可以使用`''`单引号表示

  - 列的别名，尽量使用`""`双引号，而且不建议省略`as`

#### SQL 大小写规范

- **MySQL** 在 Windows 环境下是大小写不敏感的

- **MySQL** 在 Linux 环境下是大小写敏感的

  - 数据库名、表名、表的别名、变量名是严格区分大小写的

  - 关键字、函数名、列名（或字段名）、列的别名（字段的别名）是忽略大小写的

- **推荐采用统一的书写规范**：

  - 数据库名、表名、表的别名、字段名、字段别名等都小写

  - SQL 关键字、函数名、绑定变量都大写

#### SQL 注释

```
单行注释：#注释文字(MySQL特有的方式)
单行注释：-- 注释文字(--后面必须包含一个空格。)
多行注释：/* 注释文字 */
```

#### 命名规则

- 数据库、表名不得超过 30 个字符，变量名限制为 29 个

- 必须只能包含 A–Z, a–z, 0–9, \_共 63 个字符

- 数据库名、表名、字段名等对象名中间不要包含空格

- 同一个 MySQL 软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在 SQL 语句中使用`（着重号）引起来

- 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了

#### 数据导入指令

启动 MySQL 命令行客户端，使用`source`指令录入以`.sql`结尾的文件路径：

```
mysql> SOURCE 文件名;
```

### 基本的 SELECT 语句

#### SELECT ... FROM

- 语法：`SELECT 标识选择哪些列 FROM 标识从哪个表中选择`

- 选择所有列：`SELECT * FROM 表名;`

  使用通配符`*`代表将所有列都选择，在生产环境不建议直接使用

- 选择特定列：`SELECT 列1, 列2, 列3 FROM 表名;`

#### 列的别名

- 重命名一个列

- 便于计算

- 紧跟列名，也可以**在列名和别名之间加入关键字 AS，别名使用双引号**，以便在别名中包含空格或特殊字符并区分大小写。

- AS 可以省略

- 别名建议简短，见名知意

```
SELECT 列名1 AS 列名1别名, 列名2 列名2别名
FROM 表名;
```

#### 去除重复行

默认情况查询会返回全部行，包括重复行。

在 SELECT 语句中使用关键字`DISTINCT`去除重复行

```
SELECT DISTINCT 列名 FROM 表名;
```

注意：

1. DISTINCT 需要放到所有列名的前面

2. DISTINCT 其实是对后面所有列名的组合进行去重

#### 空值参与运算

- 所有运算符或列值遇到 null 值，运算的结果都为 null

- 在 MySQL 中，空值不等于空字符串

#### 着重号

为了确保表中的字段、表名等没有和保留字、数据库系统或常用方法冲突，若相同，则在 SQL 语句中使用一对 ``（着重号）引起来。

#### 查询常数

SELECT 查询还可以对常数进行查询。在 SELECT 查询结果中增加一列固定的常数列，这列的
取值是我们指定的，而不是从数据表中动态取出的。

SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，如果想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。

```
SELECT id, `name`, 1 AS `rank`, 'CN' AS country FROM student;
```

### 显示表结构

使用 `DESCRIBE` （SQL 标准） 或 `DESC`（MySQL 特有） 命令，表示表结构：`DESCRIBE 表名;`

![MySQL 表结构](img/MySQL_7.png)

其中，各个字段的含义分别解释如下：

- Field：表示字段名称。

- Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。

- Null：表示该列是否可以存储 NULL 值。

- Key：表示该列是否已编制索引。PRI 表示该列是表主键的一部分；UNI 表示该列是 UNIQUE 索引的一部分；MUL 表示在列中某个给定值允许出现多次。

- Default：表示该列是否有默认值，如果有，那么值是多少。

- Extra：表示可以获取的与给定列有关的附加信息，例如 AUTO_INCREMENT 等

### 过滤数据

- 语法：`SELECT 列名 FROM 表名 WHERE 条件;`

  - 使用 WHERE 子句，将不满足条件的行过滤

  - **WHERE 子句紧随 FROM 子句**

## 运算符

### 算术运算符

算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（\*）、除（/）和取模（%）运算。

![MySQL 算术运算符](img/MySQL_8.png)

#### 加法与减法运算符

- 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；

- 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；

- 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；

- 在 Java 中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在 MySQL 中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按 0 计算。（补充：MySQL 中字符串拼接要使用字符串函数 CONCAT()实现）

#### 乘法与除法运算符

- 一个数乘以整数 1 和除以整数 1 后仍得原数；

- 一个数乘以浮点数 1 和除以浮点数 1 后变成浮点数，数值与原数相等；

- 一个数除以整数后，不管是否能除尽，结果都为一个浮点数；

- 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后 4 位；乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。在数学运算中，0 不能用作除数，在 MySQL 中，一个数除以 0 为 NULL。

### 比较运算符

比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回 1，比较的结果为假则返回 0，其他情况则返回 NULL。

比较运算符经常被用来作为 SELECT 查询语句的条件来使用，返回符合条件的结果记录

![MySQL 比较运算符](img/MySQL_9.png)

#### 等号运算符

- 等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回 1，不相等则返回
  0。

- 在使用等号运算符时，遵循如下规则：

  - 如果等号两边的值、字符串或表达式都为字符串，则 MySQL 会按照字符串进行比较，其比较的是每个字符串中字符的 ANSI 编码是否相等。

  - 如果等号两边的值都是整数，则 MySQL 会按照整数来比较两个值的大小。

  - 如果等号两边的值一个是整数，另一个是字符串，则 MySQL 会将字符串转化为数字进行比较。

  - 如果等号两边的值、字符串或表达式中有一个为 NULL，则比较结果为 NULL。

- 对比：SQL 中赋值符号使用 :=

#### 安全等于运算符

安全等于运算符`<=>`与等于运算符`=`的作用是相似的，**唯一的区别**是`<=>`可以用来对 NULL 进行判断。在两个操作数均为 NULL 时，其返回值为 1，而不为 NULL；当一个操作数为 NULL 时，其返回值为 0，而不为 NULL。

> 相当于限制返回数值，严格保证只会返回 1 或 0

#### 不等于运算符

不等于运算符(`!=`和`<>`)用于于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回 1，相等则返回 0。不等于运算符不能判断 NULL 值。如果两边的值有任意一个为 NULL，或两边都为 NULL，则结果为 NULL。

#### 非符号类型运算符

![MySQL 非符号类型运算符](img/MySQL_10.png)

- 空运算符：(`IS NULL`或`ISNULL`)判断一个值是否为 NULL，如果为 NULL 则返回 1，否则返回 0

- 非空运算符：(`IS NOT NULL`)判断一个值是否不为 NULL，如果不为 NULL 则返回 1，否则返回 0

- 最小值运算符：(`LEAST(value1, value2, value3,...)`)在有两个或多个参数时，返回最小值。当参数是整数或浮点数时，返回最小值；当参数为字符串，返回字母表中顺序最靠前的字符；当比较值列表中有 NULL 时，不能判断大小，返回 NULL。

- 最大值运算符：(`GREATEST(value1, value2, value3,...)`)在有两个或多个参数时，返回最大值。当参数是整数或浮点数时，返回最大值；当参数为字符串，返回字母表中顺序最靠后的字符；当比较值列表中有 NULL 时，不能判断大小，返回 NULL。

- BETWEEN AND 运算符：(`BETWEEN value1 AND value2`)判断值是否在一个范围内，如果在范围内则返回 1，否则返回 0。常用格式：`SELECT D FROM table_name WHERE C BETWEEN A AND B;`，当 C>=A 且 C<=B 时，返回 1，否则返回 0。

- IN 运算符：IN 运算符用于判断给定的一个值是否是 IN 列表中的一个值，如果是则返回 1，否则返回 0；如果给定值为 NULL，或者 IN 列表中存在 NULL，则结果为 NULL。

- LIKE 运算符：LIKE 运算符用于匹配字符串，通常用于模糊匹配，如果满足条件则返回 1，否则返回 0；如果给定的值或者匹配条件为 NULL，则返回结果为 NULL。

- REGEXP 运算符：REGEXP 运算符用来匹配字符串，语法格式为：`expr REGEXP 匹配条件`。如果 expr 满足匹配条件，返回 1；如果不满足，则返回 0。若 expr 或匹配条件任意一个为 NULL，则结果为 NULL。

REGEXP 运算符在进行匹配时，常用的有以下几种通配符：

1. `^`匹配以该字符后面的字符开头的字符串。

2. `$`匹配以该字符前面的字符结尾的字符串。

3. `.`匹配任何一个单字符。

4. `[...]`匹配在方括号内的任何字符。例如，`[abc]`匹配`a`或`b`或`c`。为了命名字符的范围，使用一个`-`。`[a-z]`匹配任何字母，而`[0-9]`匹配任何数字。

5. `_`匹配零个或多个在它前面的字符。例如，`x_`匹配任何数量的‘x’字符，`[0-9]_`匹配任何数量的数字，而`_`匹配任何数量的任何字符

### 逻辑运算符

逻辑运算符主要用来判断表达式的真假，在 MySQL 中，逻辑运算符的返回结果为 1、0 或者 NULL

![MySQL 逻辑运算符](img/MySQL_11.png)

1. **逻辑非运算符** 逻辑非(`NOT`或`!`)运算符表示当给定的值为 0 时返回 1；当给定的值为非 0 值时返回 0；当给定的值为 NULL 时，返回 NULL。

2. **逻辑与运算符** 逻辑与（`AND`或`&&`）运算符是当给定的所有值均为非 0 值，并且都不为 NULL 时，返回 1；当给定的一个值或者多个值为 0 时则返回 0；否则返回 NULL。

3. **逻辑或运算符** 逻辑或（`OR`或`||`）运算符是当给定的值都不为 NULL，并且任何一个值为非 0 值时，则返回 1，否则返回 0；当一个值为 NULL，并且另一个值为非 0 值时，返回 1，否则返回 NULL；当两个值都为 NULL 时，返回 NULL。

4. **逻辑异或运算符** 逻辑异或（XOR）运算符是当给定的值中任意一个值为 NULL 时，则返回 NULL；如果两个非 NULL 的值都是 0 或者都不等于 0 时，则返回 0；如果一个值为 0，另一个值不为 0 时，则返回 1。

### 位运算符

位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。

![MySQL 位运算符](img/MySQL_12.png)

1. **按位与运算符** 按位与（&）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为 1 时，则该位返回 1，否则返回 0

2. **按位或运算符** 按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为 1 时，则该位返回 1，否则返回 0。

3. **按位异或运算符** 按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回 1，否则返回 0。

4. **按位取反运算符** 按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将 1 变为 0，将 0 变为 1。

5. **按位右移运算符** 按位右移（>>）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用 0 补齐。

6. **按位左移运算符** 按位左移（<<）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用 0 补齐。

### 运算符的优先级

![MySQL 运算符优先级](img/MySQL_13.png)

数字编号越大，优先级越高，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使用`()`括起来的表达式的优先级最高。

## 排序与分页

### 排序数据

#### 排序规则

- 使用 `ORDER BY` 子句排序

  - **ASC(ascend)升序**

  - **DESC(descend)降序**

- **ORDER BY 子句在 SELECT 语句的结尾**

- 单列排序：`SELECT 列名 FROM 表名 ORDER BY 列名 (DESC|ASC);`

- 多列排序：`SELECT 列名1, 列名2, 列名3 FROM 表名 ORDER BY 列名1 (DESC|ASC), 列名2 (DESC|ASC), 列名3 (DESC|ASC);`

  - 可以使用不在 SELECT 列表中的列排序。

  - 在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。若第一列数据中的所有值都是唯一的，将不再对第二列排序

### 分页

- **分页原理**

  - 所谓分页显示就是将数据库的结果集，一段一段显示出来需要的条件

  - **MySQL 中使用 LIMIT 子句实现分页**

  - 格式：`LIMIT [位置偏移量,] 行数`，第一条记录的位置偏移量是 0，第二条记录的位置偏移量是 1，以此类推。

```
--前十条记录
SELECT * FROM 表名 LIMIT 10;
SELECT * FROM 表名 LIMIT 0, 10;
```

- 分页显示公式：**（当前页数-1）\*每页条数，每页条数**

`SELECT * FROM 表名 LIMIT (当前页数-1)*每页条数, 每页条数;`

- **LIMIT 子句在 SELECT 语句的结尾**

使用 LIMIT 可以约束返回结果的数量，**减少数据表的网络传输量**，也可以**提升查询效率**。

## 多表查询

多表查询，也称为关联查询，指两个或更多个表一起完成查询操作

前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。

### 多表查询分类

#### 等值连接

等值连接（等匹配）：当两个表的关联字段相等时，就称为等值连接。

语法：`SELECT 列名1, 列名2 FROM 表名1, 表名2 WHERE 表名1.关联字段 = 表名2.关联字段;`

主键必须保持唯一、非空性

**在多个表中有相同列的时候，必须在列明前加上表名前缀**

使用表的别名，在查询字段、过滤条件中只能使用别名不能使用原有表名

**连接 n 个表，至少要 n-1 个条件**

#### 内连接与外连接

- 内连接: 合并具有同一列的两个以上的表的行, **结果集中不包含一个表与另一个表不匹配的行**

- 外连接: 两个表在连接过程中除了返回满足连接条件的行以外**还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接**。没有匹配的行时, 结果表中相应的列为空(NULL)。

- 如果是左外连接，则连接条件中左边的表也称为 **主表** ，右边的表称为 **从表** 。

- 如果是右外连接，则连接条件中右边的表也称为 **主表** ，左边的表称为 **从表** 。

### SQL99 实现多表查询

#### 基本语法

使用`JOIN... ON`

```
SELECT 列名1, 列名2
FROM table1
  JOIN table2 ON table1 和 table2 的连接条件
    JOIN table3 ON table2 和 table3 的连接条件
```

- 语法说明：

  - **可以使用 ON 子句制定额外的连接条件**

  - 这个连接条件是与其它条件分开的。

  - **ON 子句使语句具有更高的易读性**

  - 关键字`JOIN`、`INNER JOIN`、`CROSS JOIN`的含义是一样的，都表示内连接

#### 外连接（OUTER JOIN）的实现

关于`LEFT OUTER JOIN`和`RIGHT OUTER JOIN`只存在于 SQL99 及之后的

##### 左外连接（LEFT OUTER JOIN）

语法：

```
SELECT 字段列表
FROM table1 LEFT JOIN table2
ON 关联条件
WHERE 条件
```

##### 右外连接（RIGHT OUTER JOIN）

语法：

```
SELECT 字段列表
FROM table1 RIGHT JOIN table2
ON 关联条件
WHERE 条件
```

###### 满外连接（FULL OUTER JOIN）

- 满外连接的结果=左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。

- SQL99 是支持满外连接的。使用`FULL JOIN` 或 `FULL OUTER JOIN` 来实现。

- 需要注意的是，MySQL 不支持`FULL JOIN`，但是可以用 `LEFT JOIN UNION RIGHT JOIN`代替

### UNION 的使用

**合并查询结果** 利用 UNION 关键字，可以给出多条 SELECT 语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个 SELECT 语句之间使用 UNION 或 UNION ALL 关键字分割

```
SELECT 字段列表 FROM table1
UNION [ALL]
SELECT 字段列表 FROM table2;
```

**UNION 操作符**

UNION 操作符返回两个查询的结果集的并集，去除重复记录

**UNION ALL 操作符**

UNION ALL 操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重.

> 注意：执行 UNION ALL 语句时所需要的资源比 UNION 语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用 UNION ALL 语句，以提高数据查询的效率。

### 7 中 SQL JOINS 的实现

![SQL JOINS](img/MySQL_14.png)

语法格式：
⋂
⋃

```
#中图：内连接 A ⋃ B
SELECT 字段列表
FROM 表1 JOIN 表2
ON 表1.关联字段 = 表2.关联字段
```

```
#左上图：左外连接 A ⋃ (A ⋂ B)
SELECT 字段列表
FROM 表1 LEFT JOIN 表2
ON 表1.关联字段 = 表2.关联字段
```

```
#右上图：右外连接 (A ⋂ B) ⋃ B
SELECT 字段列表
FROM 表1 RIGHT JOIN 表2
ON 表1.关联字段 = 表2.关联字段
```

```
#左中图：A - A ⋂ B
SELECT 字段列表
FROM 表1 LEFT JOIN 表2
ON 表1.关联字段 = 表2.关联字段
WHERE 表1.关联字段 IS NULL
```

```
#右中图：B - A ⋂ B
SELECT 字段列表
FROM 表1 RIGHT JOIN 表2
ON 表1.关联字段 = 表2.关联字段
WHERE 表2.关联字段 IS NULL
```

```
#左下图：A ⋃ B
SELECT 字段列表
FROM 表1 LEFT JOIN 表2
ON 表1.关联字段 = 表2.关联字段
WHERE 表2.关联字段 IS NULL

UNION

SELECT 字段列表
FROM 表2 RIGHT JOIN 表1
ON 表1.关联字段 = 表2.关联字段
WHERE 表1.关联字段 IS NULL
```

```
#右下图：A ⋃ B - A ⋂ B
SELECT 字段列表
FROM 表1 LEFT JOIN 表2
ON 表1.关联字段 = 表2.关联字段
WHERE 表2.关联字段 IS NULL

UNION

SELECT 字段列表
FROM 表1 RIGHT JOIN 表2
ON 表1.关联字段 = 表2.关联字段
WHERE 表1.关联字段 IS NULL
```

### SQL99 语法新特性

#### 自然连接

SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 **NATURAL JOIN** 用来表示自然连接。我们可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 **所有相同的字段** ，然后进行 **等值连接** 。

```
SELECT 字段列表
FROM 表1 NATURAL JOIN 表2
```

#### USING 连接

当我们进行连接的时候，SQL99 还支持使用 **USING** 指定数据表里的 同名字段 进行等值连接。但是只能配合 JOIN 一起使用。

```
SELECT 字段列表
FROM 表1 JOIN 表2
USING 字段名
```

USING 指定了具体的相同的字段名称，你需要在 USING 的括号 () 中填入要指定的同名字段。同时使用 **JOIN...USING** 可以简化 JOIN ON 的等值连接。

#### 表连接的约束方式

表连接的约束条件可以有三种方式：WHERE, ON, USING

- WHERE：适用于所有关联查询

- ON ：只能和 JOIN 一起使用，只能写关联条件。虽然关联条件可以并到 WHERE 中和其他条件一起写，但分开写可读性更好。

- USING：只能和 JOIN 一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等

## 单行函数

### 函数的理解

函数可以把我们经常使用的代码**封装**起来，在需要时候直接调用；既**提高了代码效率**，又**提高了可维护性**。在 SQL 中，可以使用函数对检索出来的数据进行函数操作。使用这些函数可以**提高用户对数据库的管理效率**。

函数分类为：**内置函数**和**自定义函数**，内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的

### DBMS 函数的差异

**DBMS 之间差异性很大，远大于同一个语言不同版本之间的差异性**。大部分 DBMS 会有自己特定的函数，这就意味着**采用 SQL 函数的代码可移植性是很差的**，因此在使用函数的时候要注意。

### MySQL 的内置函数及分类

MySQL 提供的内置函数从 **实现的功能角度** 可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取 MySQL 信息函数、聚合函数等。

将内置函数再分类，分为：**单行函数**、**聚合函数（分组函数）**

### 单行函数分类

- 操作数据对象

- 接收参数返回一个结果

- **只对一行进行变换**

- **每行返回一个结果**

- 可以嵌套

- 参数可以是一列或一个值

#### 数值函数

##### 基本函数

![MySQL 数值基本函数](img/MySQL_15.png)

##### 角度与弧度互换函数

![MySQL 角度与弧度互换函数](img/MySQL_16.png)

##### 三角函数

![MySQL 三角函数](img/MySQL_17.png)

##### 指数与对数

![MySQL 指数与对数函数](img/MySQL_18.png)

##### 进制间的转换

![MySQL 进制间的转换函数](img/MySQL_19.png)

#### 字符串函数

![MySQL 字符串函数](img/MySQL_20.png)

> MySQL 中，字符串的位置是从 1 开始的。

#### 日期和时间函数

##### 获取日期、时间

![MySQL 获取日期、时间函数](img/MySQL_21.png)

##### 日期与时间戳的转换

![MySQL 日期与时间戳的转换函数](img/MySQL_22.png)

##### 获取月份、星期、星期数、天数等函数

![MySQL 获取月份、星期、星期数、天数等函数](img/MySQL_23.png)

##### 日期的操作函数

![MySQL 日期的操作函数](img/MySQL_24.png)

##### 时间和秒钟转换的函数

![MySQL 时间和秒钟转换的函数](img/MySQL_25.png)

##### 计算日期和时间的函数

![MySQL 计算日期和时间的函数](img/MySQL_26.png)

##### 日期的格式化与解析

![MySQL 日期的格式化与解析函数](img/MySQL_27.png)

上述**非 GET_FORMAT**函数中 fmt 参数常用的格式符：

![MySQL 日期格式符](img/MySQL_28.png)

GET_FORMAT 函数中 data_type 和 format_type 参数常用的取值：

![MySQL GET_FORMAT函数参数](img/MySQL_29.png)

#### 流程控制函数

流程处理函数可以根据不同条件，执行不同的处理流程

![MySQL 流程控制函数](img/MySQL_30.png)

#### 加密与解密函数

加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防数据被他人窃取，这些函数在保证数据库安全时非常有用。

![MySQL 加密与解密函数](img/MySQL_31.png)

#### MySQL 信息函数

MySQL 中内置了一些可以查询 MySQL 信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作

![MySQL 信息函数](img/MySQL_32.png)

#### 其他函数

![MySQL 其他函数](img/MySQL_33.png)

## 聚合函数

### 聚合函数介绍

聚合函数是作用于一组数据，并对一组数据返回一个值

- 聚合函数类型

  - `AVG()`

  - `SUM()`

  - `MAX()`

  - `MIN()`

  - `COUNT()`

- 聚合函数语法：

```
SELECT [column,] group function(column), ...
FROM table
[WHERE condition]
[GROUP BY column]
[ORDER BY column]
```

- 聚合函数不能嵌套使用

#### AVG 和 SUM 函数

可以对**数值型数据**使用 AVG 和 SUM 函数。

```
SELECT AVG(column), SUM(column)
FROM table
```

#### MAX 和 MIN 函数

可以对**任意数据类型**使用 MAX 和 MIN 函数。

```
SELECT MAX(column), MIN(column)
FROM table
```

#### COUNT 函数

- `COUNT(*)` 返回表中记录总数，适用于**任意数据类型**

```
SELECT COUNT(*)
FROM table
WHERE condition;
```

- `COUNT(expr)` 返回**expr 不为空**的记录总数

```
SELECT COUNT(column)
FROM table
WHERE column IS NOT NULL;
```

### GROUP BY

#### 基本使用

可以使用 GROUP BY 子句将表中的数据分成若干组

```
SELECT column, group function(column)
FROM table
[HWERE condition]
[GROUP BY column]
[ORDER BY column];
```

> WHERE 一定放在 FROM 后面

在 SELECT 列表中，所有未包含在组函数中的列都应该包含在 GROUP BY 子句中。

```
SELECT column1, group function(column2)
FROM table
GROUP BY column1;
```

#### 使用多个分列

```
SELECT column1, column2, group function(column3)
FROM table
GROUP BY column1, column2;
```

#### GROUP BY 中使用 WITH ROLLUP

使用 `WITH ROLLUP` 关键字后，在所有查询出来的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量

```
SELECT column1, group function(column2)
FROM table
[WHERE condition]
GROUP BY column1 WITH ROLLUP;
```

> 当使用 ROLLUP 时，不能同时使用 ORDER BY 子句进行结果排序，即 ROLLUP 和 ORDER BY 是相互排斥的。

### HAVING

#### 基本使用

过滤分组：**HAVING** 子句

1. 行已经被分组。

2. 使用聚合函数。

3. 满足 HAVING 子句中条件的分组将被显示。

4. HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。

```
SELECT column1, group function(column2)
FROM table
[WHERE condition]
[GROUP BY column1]
[HAVING condition]
[ORDER BY column];
```

**不能在 WHERE 子句中使用的聚合函数**

#### WHERE 和 HAVING 的对比

- 区别 1：WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING 必须要于 GROUP BY 子句一起使用，可以把分组计算的函数和分组字段作为筛选条件。

- 区别 2：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。

|        | 优点                         | 缺点                                   |
| ------ | ---------------------------- | -------------------------------------- |
| WHERE  | 先筛选数据再关联，执行效率高 | 不能使用分组中的计算函数进行筛选       |
| HAVING | 可以使用分组的计算函数       | 在最后的结果集中进行筛选，执行效率较低 |

### SELECT 执行过程

#### 查询的结构

```
#方式1：

SELECT ...,....,...
FROM ...,...,....
WHERE 多表的连接条件
AND 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC
LIMIT ...,...

#方式2：
SELECT ...,....,...
FROM ... JOIN ...
ON 多表的连接条件
JOIN ...
ON ...
WHERE 不包含组函数的过滤条件
AND/OR 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC
LIMIT ...,...

#其中：
#（1）from：从哪些表中筛选
#（2）on：关联多表查询时，去除笛卡尔积
#（3）where：从表中筛选的条件
#（4）group by：分组依据
#（5）having：在统计结果中再次筛选
#（6）order by：排序
#（7）limit：分页
```

#### SELECT 执行顺序

1. **关键字的顺序不能颠倒**

```
SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...
```

2. **SELECT 语句的执行顺序**

```
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT 的字段 -> DISTINCT -> ORDER BY -> LIMIT
```

#### SQL 的执行原理

![SQL 执行原理1](img/MySQL_34.png)

![SQL 执行原理2](img/MySQL_35.png)

## 子查询

子查询指一个查询语句嵌套在另一个查询语句内部的查询

SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较

### 子查询的基本使用

- 基本语法结构：

```
SELECT 字段列表
FROM 表名
WHERE 条件
  (SELECT 字段列表
  FROM 表名);
```

- 子查询（内查询）在主查询之前一次执行完成

- 子查询的结果被主查询（外查询）使用

- **注意事项**

  - 子查询要包含在括号内

  - 将子查询放在比较条件的右侧

  - 单行操作符对应单行子查询，多行操作符对应多行子查询

### 子查询的分类

- 分类方式 1：

  - 按照内查询的结果返回一条还是多条记录，将子查询分为**单行子查询**、**多行子查询**

- 分类方式 2：

  - 按照内查询是否被多次执行，将子查询划分为**相关（关联）子查询**、**不相关（非关联）子查询**

### 单行子查询

**单行比较操作符**

| 操作符 | 含义                     |
| ------ | ------------------------ |
| =      | equal to                 |
| >      | greater than             |
| >=     | greater than or equal to |
| <      | less than                |
| <=     | less than or equal to    |
| <>     | not equal to             |

### 多行子查询

- 也称为集合比较子查询

- 内查询返回多行

- 使用多行比较操作符

**多行比较操作符**

| 操作符 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| IN     | 等于列表中的**任意一个**                                     |
| ANY    | 需要和单行比较操作符一起使用，和子查询返回的**某一个**值比较 |
| ALL    | 需要和单行比较操作符一起使用，和子查询返回的**所有**值比较   |

### 相关子查询

如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 **关联子查询** 。

相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询

## 创建和管理表

### 一条数据存储的过程

**存储数据是处理数据的第一步**

#### 完整的数据存储过程

完整的数据存储过程包括：

1. 创建数据库

2. 确认字段

3. 创建数据表

4. 插入数据

![数据存储过程](img/MySQL_36.png)

从系统的架构层次上来看，MySQL 数据库系统从大到小依次是 **数据库服务器**、**数据库**、**数据表**、**数据表的行与列**

#### 标识符命名规则

- 数据库名、表名不得超过 30 个字符，变量名限制为 29 个

- 必须只能包含 A–Z, a–z, 0–9, `_`共 63 个字符

- 数据库名、表名、字段名等对象名中间不要包含空格

- 同一个 MySQL 软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名

- 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在 SQL 语句中使用`（着重号）引起来

- 保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了

#### 数据类型

| 类型             | 类型举例                                                                                                        |
| ---------------- | --------------------------------------------------------------------------------------------------------------- |
| 整数类型         | TINYINT、SMALLINT、MEDIUMINT、INT(或 INTEGER)、BIGINT                                                           |
| 浮点类型         | FLOAT、DOUBLE                                                                                                   |
| 定点数类型       | DECIMAL                                                                                                         |
| 位类型           | BIT                                                                                                             |
| 日期时间类型     | YEAR、TIME、DATE、DATETIME、TIMESTAMP                                                                           |
| 文本字符串类型   | CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT                                                             |
| 枚举类型         | ENUM                                                                                                            |
| 集合类型         | SET                                                                                                             |
| 二进制字符串类型 | BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB                                                         |
| JSON 类型        | JSON 对象、JSON 数组                                                                                            |
| 空间数据类型     | 单值：GEOMETRY、POINT、LINESTRING、POLYGON；集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION |

常用数据类型介绍：

| 类型             | 类型举例                                                                                                        |
| ---------------- | --------------------------------------------------------------------------------------------------------------- |
| 整数类型         | TINYINT、SMALLINT、MEDIUMINT、INT(或 INTEGER)、BIGINT                                                           |
| 浮点类型         | FLOAT、DOUBLE                                                                                                   |
| 定点数类型       | DECIMAL                                                                                                         |
| 位类型           | BIT                                                                                                             |
| 日期时间类型     | YEAR、TIME、DATE、DATETIME、TIMESTAMP                                                                           |
| 文本字符串类型   | CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT                                                             |
| 枚举类型         | ENUM                                                                                                            |
| 集合类型         | SET                                                                                                             |
| 二进制字符串类型 | BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB                                                         |
| JSON 类型        | JSON 对象、JSON 数组                                                                                            |
| 空间数据类型     | 单值：GEOMETRY、POINT、LINESTRING、POLYGON；集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION |

### 创建和管理数据库

#### 创建数据库

```
# 创建数据库
CREATE DATABASE 数据库名;

# 创建数据库并指定字符集
CREATE DATABASE 数据库名 CHARACTER SET 字符集;

# 判断数据库是否已经存在，不存在则创建数据库（推荐）
CREATE DATABASE IF NOT EXISTS 数据库名;
```

> DATABASE 不能改名，可视化工具提供的改名是通过新建表、将所有表复制到新库在删除旧库实现的

#### 使用数据库

- 查看当前所有的数据库：`SHOW DATABASES;`

- 查看当前正在使用的数据库：`SELECT DATABASE();`

- 查看指定库下所有的表：`SHOW TABLES FROM 数据库名;`

- 查看数据库的创建信息：`SHOW CREATE DATABASE 数据库名;`

- 使用/切换数据库：`USE 数据库名;`

> 要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上`数据库名.`

#### 修改数据库

- 更改数据库字符集：`ALTER DATABASE 数据库名 CHARACTER SET 字符集;`

#### 删除数据库

- 删除数据库：`DROP DATABASE IF EXISTS 数据库名;`

### 创建表

#### 创建方式 1

- **必须具备**：

  - CREATE TABLE 权限

  - 存储空间

- **语法格式**：

```
CREATE TABLE [IF NOT EXISTS] 表名 (
  字段名 数据类型 [完整性约束条件] [默认值],
  字段名 数据类型 [完整性约束条件] [默认值],
  字段名 数据类型 [完整性约束条件] [默认值],
  ...
  [表约束条件]
);
```

- **必须指定**：

  - 表名

  - 列名（字段名），数据类型，**长度**

- **可选指定**:

  - 约束条件

  - 默认值

#### 创建方式 2

- 使用 AS subquery 选项，**将创建表和插入数据结合起来**

- 指定的列和子查询中的列要一一对应

- 通过列名和默认值定义列

#### 查看数据表结构

在 MySQL 中创建好数据表之后，可以查看数据表的结构。MySQL 支持使用 DESCRIBE/DESC 语句查看数据表结构，也支持使用 **SHOW CREATE TABLE** 语句查看数据表结构。

**语法格式如下**：`SHOW CREATE TABLE 表名\G`

使用 SHOW CREATE TABLE 语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。

### 修改表

修改表指的是修改数据库中已经存在的数据表的结构

**使用 ALTER TABLE 语句修改表结构**：

- 向已有的表中添加列

- 修改现有表中的列

- 删除已有的表中的列

- 重命名现有表中的列

#### 追加一个列

`ALTER TABLE 表名 ADD [COLUMN] 字段名 字段类型 [FIRST|AFTER 字段名]`

#### 修改一个列

- 可以修改列的数据类型，长度、默认值和位置

- 修改字段数据类型、长度、默认值、位置的语法格式

`ALTER TABLE 表名 MODIFY [COLUMN] 字段名 字段类型 [DEFAULT 默认值] [FIRST|AFTER 字段名];`

#### 重命名一个列

`ALTER TABLE 表名 CHANGE [COLUMN] 列名 新列名 新数据类型;`

#### 删除一个列

`ALTER TABLE 表名 DROP [COLUMN] 字段名;`

### 重命名表

- 方式一：使用 RENAME

```
RENAME TABLE 旧表名 TO 新表名;
```

- 方式二：

```
ALTER TABLE 旧表名 RENAME [TO] 新表名;
```

### 删除表

- 在 MySQL 中，当一张数据表 **没有与其他任何数据表形成关联关系** 时，可以直接删除该表。

- 数据和结构都被删除。

- 所有正在运行的相关事务被提交

- 所有相关索引被删除

- 语法格式：

`DROP TABLE [IF EXISTS] 表名1 [, 表名2,...];`

### 清空表

`TRUNCATE TABLE 表名;`

TURNCATE 语句**不能回滚**，而使用 DELETE 语句则可以回滚。

## 数据处理之增删改

### 插入数据

#### 方式一：VALUES 子句

使用这种语法一次只能向表中插入**一条**数据

- 字符和日期型数据应包含在单引号中。

```
# 为表的所有字段按默认顺序插入数据
INSERT INTO 表名 VALUES (值1, 值2,...);
# 为表的指定字段插入数据
INSERT INTO 表名 (字段1, 字段2,...) VALUES (值1, 值2,...);
# 同时插入多条数据
INSERT INTO 表名
VALUES
(值1, 值2,...),
(值1, 值2,...),
...
(值1, 值2,...)
```

使用 INSERT 同时插入多条记录时， MySQL 会返回一些在执行单行插入时没有的额外信息，这些信息的含义如下：

- Records: 表明插入的记录条数。

- Duplicates：表明插入时被忽略的记录，可能是这些记录包含了重复的主键值。

- Warnings：表明有问题的数据值

> 一个同时插入多行记录的 INSERT 语句等同于多个当行插入的 INSERT 语句，但是多行的 INSERT 语句在处理过程中 **效率更高** 。因为 MySQL 执行单条 INSERT 语句插入多行数据比使用多条 INSERT 语句快，所以在插入多条记录时最好选择使用单条 INSERT 语句的方式插入。

#### 方式二：SELECT 子句

INSERT 还可以将 SELECT 语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条 INSERT 语句和一条 SELECT 语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。

```
INSERT INTO 表名
(tar_column1[,tar_column2,...])
SELECT
(src_column1[,src_column2,...])
FROM 源表名
[WHERE condition]
```

- 在 INSERT 语句中加入子查询

- **不必书写 VALUES 子句**

- 子查询中的值列表应与 INSERT 语句中的列名对应

### 更新数据

```
UPDATE 表名
SET 字段名1=新值1, 字段名2=新值2,...
[WHERE 条件];
```

- 可以一次更新**多条**数据

- 如果需要回滚数据

- 使用**WHERE**子句指定需要更新的数据

```
UPDATE 表名
SET 字段名1=值1
WHERE 字段名2=值2;
```

- 如果省略 WHERE 子句，则表中所有数据都会被更新

### 删除数据

- 使用 DELETE 语句从表中删除数据：`DELETE FROM 表 [WHERE 条件];`

### MySQL8 新特性：计算列

在 MySQL 8.0 版本中，CREATE TABLE 和 ALTER TABLE 语句都支持计算列

```
CREATE TABLE 表名 (
  id INT,
  a INT,
  b INT,
  c INT GENERATED ALWAYS AS (a+b) VIRTUAL
);
```

## MySQL 数据类型精讲

### MySQL 中的数据类型

| 类型             | 类型举例                                                                                                                    |
| ---------------- | --------------------------------------------------------------------------------------------------------------------------- |
| 整数类型         | TINYINT、SMALLINT、MEDIUMINT、INT(或 INTEGER)、BIGINT                                                                       |
| 浮点类型         | FLOAT、DOUBLE                                                                                                               |
| 定点数类型       | DECIMAL                                                                                                                     |
| 位类型           | BIT                                                                                                                         |
| 日期时间类型     | YEAR、TIME、DATE、DATETIME、TIMESTAMP                                                                                       |
| 文本字符串类型   | CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT                                                                         |
| 枚举类型         | ENUM                                                                                                                        |
| 集合类型         | SET                                                                                                                         |
| 二进制字符串类型 | BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB                                                                     |
| JSON 类型        | JSON 对象、JSON 数组                                                                                                        |
| 空间数据类型     | 单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；<br>集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION |

常见数据类型的属性：

| MySQL 关键字       | 含义                     |
| ------------------ | ------------------------ |
| NULL               | 数据列可包含 NULL 值     |
| NOT NULL           | 数据列不允许包含 NULL 值 |
| DEFAULT            | 默认值                   |
| PRIMARY KEY        | 主键                     |
| AUTO_INCREMENT     | 自动递增，适用于整数类型 |
| UNSIGNED           | 无符号                   |
| CHARACTER SET name | 指定一个字符集           |

### 整数类型

#### 分类

整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT(INTGER)、BIGINT。

#### 可选属性

**整数类型的可选属性有三个**：

##### M

**M**：表示显示宽度，M 的取值范围是（0,255）

- 当数据宽度小于 M 时，在数字前面需要用字符填满宽度，该功能需要使用`ZEROFILL`，表示用'0'填充空白。

- 当数据宽度大于 M 时，还是按照类型的实际宽度进行保存，即**显示宽度与类型可以存储的值范围无关**，从 MySQL 8.0.17 开始，整数数据类型**不推荐使用显示宽度属性**

##### UNSIGNED

**UNSIGNED**：表示无符号整数，即不允许负数。所有的整数类型都有该可选属性，最小取值为 0，

int 类型默认显示宽度为 11，unsigned int 类型默认显示宽度为 10。

##### ZEROFILL

**ZEROFILL**：0 填充，若果某列是 ZEROFILL，那么 MySQL 会自动为当前列添加 UNSIGNED 属性，如果制定了 ZEROFILL 只是表示不够 M 位时，用 0 在左边填充；若超 M 位，只要不超过数据存储范围。

#### 适用场景

- **TINYINT** ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。

- **SMALLINT** ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。

- **MEDIUMINT** ：用于较大整数的计算，比如车站每日的客流量等。

- **INT**、**INTEGER** ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。

- **BIGINT** ：只有当处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。

#### 如何选择

- 在评估用哪种整数类型的时候，需要考虑 **存储空间** 和 **可靠性** 的平衡问题：一方面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起 **系统错误** ，影响可靠性。

- 举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围 65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。

- 要注意的是，在实际工作中，**系统故障产生的成本远远超过增加几个字段存储空间所产生的成本**。因此，首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。

### 浮点类型

#### 分类

浮点数和定点数类型的特点是可以 **处理小数** 。浮点数和定点数的使用场景，更广。 MySQL 支持的浮点数类型，分别是 **FLOAT**、**DOUBLE**、**REAL**。

- FLOAT 表示单精度浮点数

- DOUBLE 表示双精度浮点数

- REAL 默认就是 DOUBLE

MySQL 存储浮点数的格式为：**符号（S）**、**尾数（M）**和**阶码（E）**。因此无论有没有符号，MySQL 的浮点数都会存储表示符号部分。

#### 精度说明

对于浮点类型，在 MySQL 中单精度值使用 4 个字节，双精度使用 8 个字节

精度误差来源于二进制存储的问题，对于尾数非 0 或 5 的小数，就无法使用一个二进制数来精确表示，因此**浮点数时不准确的，我们要避免使用`=`来判断两个数是否相等**

同时，在对于精度要求更高的场景，使用定点数类型`DECIMAL`，来代替浮点数

### 定点数类型

#### 介绍

| 数据类型                 | 字节数   | 含义                   |
| ------------------------ | -------- | ---------------------- |
| DECIMAL(M,D),DEC,NUMERIC | M+2 字节 | 有效范围由 M 和 D 决定 |

使用 DECIMAL(M,D) 类型表示高精度小数，其中，M 是精度，D 是标度，0<=M<=65，0<=D<=30，D < M

DECIMAL(M,D) 的最大取值范围与 DOUBLE 类型一样，但是有效的数据范围是由 M 和 D 决定的。DECIMAL 的存储空间并不是固定的，由精度值 M 决定，总共占用的存储空间为 M+2 字节。

定点数在 MySQL 中，以 **字符串** 形式存储，这就决定了它一定是精度的

当 DECIMAl 类型不指定精度和标度时，其默认为 DECIMAL(10,0)，当数据精度超出了定点数类型的精度范围时，则 MySQL 会进行四舍五入处理。

### 位类型：BIT

| 二进制字符串类型 | 长度 | 长度范围 | 占用空间 |
| ---------------- | ---- | -------- | -------- |
| BIT(M)           | M    | 1-64     | (M+7)/8  |

BIT 类型，如果没有指定(M)，默认是 1 位。这个 1 位，表示只能存 1 位的二进制值。这里(M)是表示二进制的位数，位数最小值为 1，最大值为 64。

### 日期时间类型

#### 分类

- YEAR 类型通常用来表示年

- DATE 类型通常用来表示年、月、日

- TIME 类型通常用来表示时、分、秒

- DATETIME 类型通常用来表示年、月、日、时、分、秒

- TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒

#### YEAR 类型

- **定义**：YEAR 类型用来表示年份，占用 1 个字节的存储空间。

- **存储格式**：

  - 4 位字符串或数字格式：YYYY，最小值为 1901，最大值为 2155。

  - 2 位字符串格式：最小值为 00，最大值为 99。

    - 01 至 69 表示 2001 至 2069。

    - 70 至 99 表示 1970 至 1999。

    - 0 或 00 表示 0000 年。

    - '0'表示 2000 年。

- **注意**：从 MySQL 5.5.27 开始，不推荐使用 2 位格式的 YEAR。从 MySQL 8.0.19 开始，不推荐使用指定显示宽度的 YEAR(4)。

#### DATE 类型

- **定义**：DATE 类型表示日期，格式为 YYYY-MM-DD，占用 3 个字节的存储空间。

- **存储范围**：最小值为 1000-01-01，最大值为 9999-12-03。

- **插入格式**：

  - YYYY-MM-DD 或 YYYYMMDD 格式的字符串。

  - YY-MM-DD 或 YYMMDD 格式的字符串，两位年份规则同 YEAR 类型。

- **函数**：可以使用 CURRENT_DATE()或 NOW()插入当前系统日期。

#### TIME 类型

- **定义**：TIME 类型表示时间，格式为 **HH:MM:SS**，占用 3 个字节的存储空间。

- **插入格式**：

  - 带冒号的字符串，如'HH:MM:SS'。

  - 不带冒号的字符串或数字，如'HHMMSS'或 HHMMSS。

  - 使用函数 CURRENT_TIME()或 NOW()插入当前系统时间。

#### DATETIME 类型

- **定义**：DATETIME 类型表示日期和时间，格式为 **YYYY-MM-DD HH:MM:SS**，占用 8 个字节的存储空间。

- **存储范围**：最小值为 1000-01-01 00:00:00，最大值为 9999-12-03
  23:59:59。

- 使用 **CURRENT_DARE()** 或者 **NOW()** 函数，会插入当前系统的日期。

- **插入格式**：

  - YYYY-MM-DD HH:MM:SS 或 YYYYMMDDHHMMSS 格式的字符串。

  - YY-MM-DD HH:MM:SS 或 YYMMDDHHMMSS 格式的字符串，两位年份规则同 YEAR 类型。

- **函数**：可以使用 CURRENT_TIMESTAMP()或 NOW()插入当前系统日期和时间。

#### TIMESTAMP 类型

- **定义**：TIMESTAMP 类型表示日期和时间，格式为 YYYY-MM-DD HH:MM:SS，占用 4 个字节的存储空间。

- **存储范围**：1970-01-01 00:00:01 UTC 至 2038-01-19 03:14:07 UTC。

- **特点**：

  - 存储时进行时区转换，查询时转换回当前时区。

  - 两位数值年份规则同 YEAR 类型。

- **函数**：可以使用 CURRENT_TIMESTAMP()或 NOW()插入当前系统日期和时间。

#### TIMESTAMP 与 DATETIME 的区别

- TIMESTAMP 存储空间更小，表示的日期时间范围也更小。

- 底层存储方式不同，TIMESTAMP 存储的是距离 1970-1-1 0:0:0 的毫秒值。

- 日期比较或计算时，TIMESTAMP 更方便。

- TIMESTAMP 与时区有关，DATETIME 则反映插入时的时区。

#### 开发经验

- **推荐使用**：DATETIME 类型，因为它包括完整的日期和时间信息，取值范围最大。

- **存储时间戳**：对于注册时间、商品发布时间等，建议使用时间戳，便于计算。

### 字符串类型

在 MySQL 中，文本字符串总体上分为 **CHAR** 、 **VARCHAR** 、 **TINYTEXT** 、 **TEXT** 、 **MEDIUMTEXT** 、
**LONGTEXT** 、 **ENUM** 、 **SET** 等类型

| 文本字符串类型 | 值 的 长 度 | 长 度 范 围          | 占用的存储空间      |
| -------------- | ----------- | -------------------- | ------------------- |
| CHAR(M)        | M           | 0 <= M <= 255        | M 个字节            |
| VARCHAR(M)     | M           | 0 <= M <= 65535      | M+1 个字节          |
| TINYTEXT       | L           | 0 <= L <= 255        | L+2 个字节          |
| TEXT           | L           | 0 <= L <= 65535      | L+2 个字节          |
| MEDIUMTEXT     | L           | 0 <= L <= 16777215   | L+3 个字节          |
| LONGTEXT       | L           | 0 <= L <= 4294967295 | L+4 个字节          |
| ENUM           | L           | 1 <= L <= 65535      | 1 或 2 个字节       |
| SET            | L           | 0 <= L <= 64         | 1,2,3,4 或 8 个字节 |

#### CHAR 与 VARCHAR 类型

| 字符串(文本)类型 | 特点     | 长度 | 长度范围    | 占用的存储空间     |
| ---------------- | -------- | ---- | ----------- | ------------------ |
| CHAR(M)          | 固定长度 | M    | 0<=M<=255   | M 个字节           |
| VARCHAR(M)       | 可变长度 | M    | 0<=M<=65535 | (实际长度+1)个字节 |

**CHAR 类型**

- CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是 1 个字符。

- 如果保存时，数据的实际长度比 CHAR 类型声明的长度小，则会在 **右侧填充** 空格以达到指定的长度。当 MySQL 检索 CHAR 类型的数据时，CHAR 类型的字段会去除尾部的空格。

- 定义 CHAR 类型字段时，声明的字段长度即为 CHAR 类型字段所占的存储空间的字节数。

**VARCHAR 类型**

- VARCHAR(M) 定义时， 必须指定 长度 M，否则报错。

- MySQL4.0 版本以下，varchar(20)：指的是 20 字节，如果存放 UTF8 汉字时，只能存 6 个（每个汉字 3 字节） ；MySQL5.0 版本以上，varchar(20)：指的是 20 字符。

- 检索 VARCHAR 类型的字段数据时，会保留数据尾部的空格。VARCHAR 类型的字段所占用的存储空间 s 为字符串实际长度加 1 个字节。

**CHAR 和 VARCHAR 的比较**

| 类型       | 特点     | 空间上       | 时间上 | 适用场景             |
| ---------- | -------- | ------------ | ------ | -------------------- |
| CHAR(M)    | 固定长度 | 浪费存储空间 | 效率高 | 存储不大，速度要求高 |
| VARCHAR(M) | 可变长度 | 节省存储空间 | 效率低 | 非 CHAR 的情况       |

情况 1：存储很短的信息。比如门牌号码 101，201……这样很短的信息应该用 char，因为 varchar 还要占个 byte 用于存储信息长度，本来打算节约存储的，结果得不偿失。

情况 2：固定长度的。比如使用 uuid 作为主键，那用 char 应该更合适。因为他固定长度，varchar 动态根据长度的特性就消失了，而且还要占个长度信息。

情况 3：十分频繁改变的 column。因为 varchar 每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于 char 来说是不需要的。

情况 4：具体存储引擎中的情况：

- MyISAM 数据存储引擎和数据列：MyISAM 数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使 数据检索更快 ，用空间换时间。

- MEMORY 存储引擎和数据列：MEMORY 数据表目前都使用固定长度的数据行存储，因此无论使用 CHAR 或 VARCHAR 列都没有关系，两者都是作为 CHAR 类型处理的。

- InnoDB 存储引擎，建议使用 NARCHAR 类型。因为对于 InnoDB 数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素是数据行使用的存储总量，由于 char 平均占用的空间多于 varchar，所以除了简短并且固定长度的，其他考虑 varchar。这样节省空间，对磁盘 I/O 和数据存储总量比较好。

#### TEXT 类型

在向 TEXT 类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和 VARCHAR 类型相同。

每种 TEXT 类型保存的数据长度和所占用的存储空间不同，如下：

| 文本字符串类型 | 特点               | 长度 | 长度范围                           | 占用的存储空间 |
| -------------- | ------------------ | ---- | ---------------------------------- | -------------- |
| TINYTEXT       | 小文本、可变长度   | L    | 0 <= L <= 255                      | L + 2 个字节   |
| TEXT           | 文本、可变长度     | L    | 0 <= L <= 65535                    | L + 2 个字节   |
| MEDIUMTEXT     | 中等文本、可变长度 | L    | 0 <= L <= 16777215                 | L + 3 个字节   |
| LONGTEXT       | 大文本、可变长度   | L    | 0 <= L <= 4294967295（相当于 4GB） | L + 4 个字节   |

**由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键。**

### ENUM 类型

枚举类型，ENUM 类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM 类型只允许从成员中选取单个值，不能一次选取多个值。

| 文本字符串类型 | 长度 | 长度范围       | 占用的存储空间 |
| -------------- | ---- | -------------- | -------------- |
| ENUM           | L    | 1 <= L <=65535 | 1 或 2 个字节  |

当 ENUM 类型包含 1 ～ 255 个成员时，需要 1 个字节的存储空间；

当 ENUM 类型包含 256 ～ 65535 个成员时，需要 2 个字节的存储空间。

ENUM 类型的成员个数的上限为 65535 个。

### SET 类型

SET 表示一个字符串对象，可以包含 0 个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取取值范围内的 0 个或多个值。

当 SET 类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：

| 成员个数范围（L 表示实际成员个数） | 占用的存储空间 |
| ---------------------------------- | -------------- |
| 1 <= L <= 8                        | 1 个字节       |
| 9 <= L <= 16                       | 2 个字节       |
| 17 <= L <= 24                      | 3 个字节       |
| 25 <= L <= 32                      | 4 个字节       |
| 33 <= L <= 64                      | 8 个字节       |

SET 类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET 类型在选取成员时，可以一次选择多个成员，这一点与 ENUM 类型不同。

### 二进制字符串类型

MySQL 中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。

MySQL 中支持的二进制字符串类型主要包括 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 类型。

#### BINARY 和 VARBINARY 类型

BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，只是它们存储的是二进制字符串。

BINARY (M)为固定长度的二进制字符串，M 表示最多能存储的字节数，取值范围是 0~255 个字符。如果未指定(M)，表示只能存储 **1 个字节** 。例如 BINARY (8)，表示最多能存储 8 个字节，如果字段值不足(M)个字节，将在右边填充'\0'以补齐指定长度。
VARBINARY (M)为可变长度的二进制字符串，M 表示最多能存储的字节数，总字节数不能超过行的字节长度限制 65535，另外还要考虑额外字节开销，VARBINARY 类型的数据除了存储数据本身外，还需要 1 或 2 个字节来存储数据的字节数。VARBINARY 类型 **必须指定(M)** ，否则报错。

| 二进制字符串类型 | 特点     | 值的长度         | 占用空间   |
| ---------------- | -------- | ---------------- | ---------- |
| BINARY(M)        | 固定长度 | M（0<=M<=255）   | M 个字节   |
| VARBINARY(M)     | 可变长度 | M（0<=M<=65535） | M+1 个字节 |

#### BLOB 类型

BLOB 是一个 **二进制大对象** ，可以容纳可变数量的数据。

MySQL 中的 BLOB 类型包括 TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 4 种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如图片、音频和视频等。

需要注意的是，在实际工作中，往往不会在 MySQL 数据库中使用 BLOB 类型存储大对象数据，通常会将图片、音频和视频文件存储到 **服务器的磁盘上** ，并将图片、音频和视频的访问路径存储到 MySQL 中。

| 二进制字符串类型 | 值的长度 | 长度范围                       | 占用空间   |
| ---------------- | -------- | ------------------------------ | ---------- |
| TINYBLOB         | L        | 0<=L<=255                      | L+1 个字节 |
| BLOB             | L        | 0<=L<=65535（相当于 64KB）     | L+2 个字节 |
| MEDIUMBLOB       | L        | 0<=L<=16777215（相当于 16MB）  | L+3 个字节 |
| LONGBLOB         | L        | 0<=L<=4294967295（相当于 4GB） | L+4 个字节 |

### JOSN 类型

JSON（JavaScript Object Notation）是一种轻量级的 **数据交换格式** 。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。**JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。**

JSON 类型可以进行自动验证的 JSON 文档和优化的存储结构，使得在 MySQL 中存储和读取 JOSN 类型的数据更加方便高效。创建数据表，表中包含一个 JSON 类型的字段 js

当需要检索 JSON 类型的字段中数据的某个具体值，可以使用`->`和`->>`

### 空间类型

MySQL 空间类型扩展支持地理特征的生成、存储和分析。MySQL 中使用 **Geometry**（几何） 来表示所有地理特征。Geometry 指一个点或点的
集合，代表世界上任何具有位置的事物。

## 约束

### 约束概述

约束是表级的强制规定。

可以在**创建表时规定约束（通过 CREATE TABLE 语句）**，或者在**表创建之后通过 ALTER TABLE 语句添加约束**。

#### 约束作用

数据完整性（Data Integrity）：是指数据的精确性和可靠性。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。

为了保证数据的完整性，SQL 规范以约束的方式对**表数据进行额外的条件限制**：

- **实体完整性（Entity Integrity）** ：例如，同一个表中，不能存在两条完全相同无法区分的记录

- **域完整性（Domain Integrity）** ：例如：年龄范围 0-120，性别范围“男/女”

- **引用完整性（Referential Integrity）**：例如：员工所在部门，在部门表中要能找到这个部门

- **用户自定义完整性（User-defined Integrity）** ：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的 5 倍

#### 约束分类

- **根据约束数据列的限制**：

  - **单列约束**：每个约束只约束一列

  - **多列约束**：每个约束可约束多列数据

- **根据约束的作用范围**：

  - **列级约束**：只能作用在一个列上，跟在列的定义后面

  - **表级约束**：可以作用在多个列上，不与列一起，而是单独定义

| 位置       | 支持的约束类型 | 是否可以起约束名           |
| ---------- | -------------- | -------------------------- | -------------------- |
| 列级约束： | 列的后面       | 语法都支持，但外键没有效果 | 不可以               |
| 表级约束： | 所有列的下面   | 默认和非空不支持，其他支持 | 可以（主键没有效果） |

- **根据约束起的作用**：

  - **NOT NULL 非空约束**：规定某个字段不能为空

  - **UNIQUE 唯一约束**：规定某个字段在整个表中是唯一

  - **PRIMARY KEY 主键约束**：主键必须非空且唯一

  - **FOREIGN KEY 外键约束**

  - **CHECK 检查约束**

  - **DEFAULT 默认值约束**

- 查看某个表已有的约束

```
#information_schema数据库名（系统库）
#table_constraints表名称（专门存储各个表的约束）
SELECT * FROM information_schema.table_constraints
WHERE table_name = '表名称';
```

### 非空约束

**作用**：限定某个字段/某列值不允许为空

**关键字**：NOT NULL

**特点**：

- 默认，所有类型的值都可以是 NULLL，包括 INT、FLOAT

- 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空

- 一个表可以有很多列都分别限定了非空

- 空字符串''不等于 NULL，0 也不等于 NULL

**语法**：

```
#建表时添加
CREATE TABLE 表名 (
  字段名  数据类型  NOT NULL,
);

#建表后添加
ALTER TABLE 表名
MODIFY 字段名  数据类型  NOT NULL;

#删除非空约束
ALTER TABLE 表名
MODIFY 字段名  数据类型;
```

### 唯一性约束

**作用**：用来限制某个字段/某列的值不能重复

**关键字**：UNIQUE

**特点**：

- 同一个表可以有多个唯一约束

- 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。

- 唯一性约束允许列值为空。

- 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同

- **MYSQL 会给唯一约束的列上默认创建一个唯一索引**

**语法**：

```
#建表时添加
CREATE TABLE 表名 (
  字段名  数据类型  UNIQUE,
  字段名  数据类型  UNIQUE KEY,
  [constraint 约束名] UNIQUE KEY
);

#建表后添加
ALTER TABLE 表名
ADD UNIQUE KEY (字段名);

ALTER TABLE 表名
MODIFY 字段名  数据类型  UNIQUE;

#删除唯一约束
ALTER TABLE 表名
DROP INDEX 索引名;
```

> 可以通过 **show index from 表名;** 查看表的索引

- 添加唯一性约束的列上也会自动创建唯一索引

- 删除唯一约束只能通过删除唯一索引的方式删除

- 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样

- 如果创建唯一约束未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名

### 主键约束 (PRIMARY KEY)

**作用**：用来唯一标识表中的一行记录

**关键字**：PRIMARY KEY

**特点**：

- 主键约束相当于唯一约束 + 非空约束的组合，主键约束列不允许重复，也不允许出现空值

- 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建

- 主键约束对应着表中的一列或者多列（复合主键）

- 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复

- MySQL 的主键名总是 PRIMARY，就算自己命名了主键约束名也没用

- 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了

- 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性

**语法**：

```
#建表时添加
CREATE TABLE 表名 (
  字段名  数据类型  PRIMARY KEY, #列级模式
  字段名  数据类型，
  字段名  数据类型，
  [constraint 约束名] PRIMARY KEY(字段名) #表级模式
);
#建表后添加
ALTER TABLE 表名
ADD PRIMARY KEY(字段列表);
#删除主键约束
ALTER TABLE 表名
DROP PRIMARY KEY;
```

- 添加主键约束时，字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键

### 外键约束 (FOREIGN KEY)

**作用**：限定某个表的某个字段的引用完整性

**关键字**：FOREIGN KEY

**主表和从表/父表和子表**：

- 主表（父表）：被引用的表，被参考的表

- 从表（子表）：引用别人的表，参考别人的表

**特点**：

- 从表的外键列，必须引用/参考主表的主键或唯一约束的列

- 在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如 student_ibfk_1;），也可以指定外键约束名

- 创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表

- 删表时，先删从表（或先删除外键约束），再删除主表

- 当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据

- 在“从表”中指定外键约束，并且一个表可以建立多个外键约束

- 从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can't create
  table'database.tablename'(errno: 150)”。

- 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是外键的约束
  名。（根据外键查询效率很高）

- 删除外键约束后，必须手动删除对应的索引
  **语法**：

```
#建表时添加
CREATE TABLE 主表名称 (
  字段1  数据类型  PRIMARY KEY,
  字段2  数据类型
);
CREATE TABLE 从表名称 (
  字段1  数据类型  PRIMARY KEY,
  字段2  数据类型，
  [CONSTRAINT <外键约束名称>] FOREIGN KEY(从表的某个字段) REFERENCES 主表名(被参考字段)
);
#建表后添加
ALTER TABLE 从表名
ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx];
```

- 添加外键约束时，主表必须先创建成功，然后才能创建从表，指定外键成功

- 删除表时，先删除从表，再删除主表

- 从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致

- 可以指定外键约束的等级，例如 CASCADE, SET NULL, NO ACTION, RESTRICT 等

### 检查约束 (CHECK)

**作用**：检查某个字段的值是否符号 xx 要求，一般指的是值的范围

**关键字**：CHECK

**说明**：MySQL 5.7 不支持

**语法**：

```
#建表时添加
CREATE TABLE 表名 (
  字段名  数据类型  CHECK(约束条件),
);
#建表后添加
ALTER TABLE 表名
MODIFY 字段名  数据类型  CHECK(约束条件);
```

### 默认值约束 (DEFAULT)

**作用**：给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值

**关键字**：DEFAULT

**语法**：

```
#建表时添加
CREATE TABLE 表名 (
  字段名  数据类型  DEFAULT 默认值，
);
#建表后添加
ALTER TABLE 表名
MODIFY 字段名  数据类型  DEFAULT 默认值；
#删除默认值约束
ALTER TABLE 表名
MODIFY 字段名  数据类型；
```

- 默认值约束一般不在唯一键和主键列上加

## 视图

### 常见的数据库对象

| 对象                | 描述                                                                                                 |
| ------------------- | ---------------------------------------------------------------------------------------------------- |
| 表(TABLE)           | 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录                                   |
| 数据字典            | 就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看 |
| 约束(CONSTRAINT)    | 执行数据校验的规则，用于保证数据完整性的规则                                                         |
| 视图(VIEW)          | 一个或者多个数据表里的数据的逻辑显示，视图并不存储数据                                               |
| 索引(INDEX)         | 用于提高查询性能，相当于书的目录                                                                     |
| 存储过程(PROCEDURE) | 用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境                         |
| 存储函数(FUNCTION)  | 用于完成一次特定的计算，具有一个返回值                                                               |
| 触发器(TRIGGER)     | 相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理                           |

### 视图概述

视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。

### 视图的理解

- 视图是一种**虚拟表**，本身是**不具有数据**的，占用很少的内存空间，它是 SQL 中的一个重要概念

- **视图建立在已有表的基础上**，视图赖以建立的这些表称为**基表**

![用户、视图、数据表的关系](img/MySQL_37.png)

- 视图的创建和删除只影响视图本身，不影响相应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化

- 向视图提供数据内容的语句为 SELECT 语句，可以将视图理解为**存储起来的 SELECT 语句**

  - 在数据库中，视图不会保存数据据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。

- 视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。

### 创建视图

- **在 CREATE VIEW 语句中嵌入子查询**

```
CREATE [OR REPLACE]
[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
VIEW 视图名称 [(字段列表)]
AS 查询语句
[WITH [CASCADED | LOCAL] CHECK OPTION]
```

- 精简版

```
CREATE VIEW 视图名称
AS 查询语句
```

### 查看视图

- 查看数据库的表对象、视图对象

```
SHOW TABLES;
```

- 查看视图的结构

```
DESC / DESCRIBE 视图名称;
```

- 查看视图的属性信息：

```
SHOW TABLE STATUS LIKE '视图名称'\G
```

- 查看视图的详细定义信息：

```
SHOW CREATE VIEW 视图名称;
```

## 存储过程和函数

### 存储过程概述

**含义**：存储过程的思想很简单，就是一组经过**预先编译**的 SQL 语句的封装

执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行

**好处**：

1. 简化操作，提高了 SQL 语句的重用性，减少了开发程序员的压力。

2. 减少操作过程中的失误，提高效率

3. 减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发送给服务器）

4. 减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性。

和视图、函数的对比：

它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是 **虚拟表** ，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以 直接操作底层数据表 ，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。

一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是 **没有返回值** 的。

**分类**：

存储过程的参数类型可以是 IN、OUT 和 INOUT

1. 没有参数（无参数无返回）

2. 仅仅带 IN 类型（有参数无返回）

3. 仅仅带 OUT 类型（无参数有返回）

4. 既带 IN 又带 OUT 类型（有参数有返回）

5. 带 INOUT 类型（有参数有返回）

### 创建存储过程

语法：

```
CREATE PROCEDURE 存储过程名称(IN|OUT|INOUT 参数名 数据类型,...)
[characteristic]
BEGIN
  存储过程体
END
```

说明：

1. 参数前面的符号的意思

- IN ：当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类， 默认就是 IN ，表示输入参数。

- OUT ：当前参数为输出参数，也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。

- INOUT ：当前参数既可以为输入参数，也可以为输出参数。

2. 形参类型可以是 MySQL 数据库中的任意类型。

3. 存储过程体中可以有多 SQL 语句，如果仅仅一条 SQL 语句，可以省略 BEGIN 和 END。

### 调用存储过程

**调用格式**：

存储过程有多重调用方法，存储过程必须使用 CALL 语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，则需要制定数据库名称

```
CALL 存储过程名称(参数列表)
```

**格式**：

1. 调用 IN 模式的参数：

```
CALL 存储过程名(参数值1,参数值2,...)
```

2. 调用 OUT 模式的参数：

```
SET @变量名;
CALL 存储过程名(@变量名);
SELECT @变量名;
```

3. 调用 INOUT 模式的参数：

```
SET @变量名=参数值;
CALL 存储过程名(@变量名);
SELECT @变量名;
```

## 变量、流程控制与游标

### 变量

在 MySQL 中，变量分为系统变量和用户自定义变量。

**系统变量**

- **分类**: 全局系统变量（作用于所有会话）和会话系统变量（作用于当前会话）

- **查看**: `SHOW VARIABLES` 或 `SHOW [GLOBAL|SESSION] VARIABLES LIKE '%pattern%'`

- **修改**:

  - 修改配置文件（重启生效）

  - 使用 `SET [GLOBAL|SESSION] 变量名 = 值`

**用户变量**

- **分类**: 会话用户变量和局部变量

- **定义**: `SET @变量名 = 值` 或 `SELECT @变量名 := 表达式 [FROM 等子句]`

- **局部变量**: 在 `BEGIN ... END` 语句块中有效，使用 `DECLARE 变量名 类型 [DEFAULT 值]`

**对比**

| 类型         | 作用域                | 定义位置             | 语法                      |
| ------------ | --------------------- | -------------------- | ------------------------- |
| 会话用户变量 | 当前会话              | 会话的任何地方       | 加@符号，不用指定类型     |
| 局部变量     | 定义它的 BEGIN END 中 | BEGIN END 的第一句话 | 一般不用加@，需要指定类型 |

### 定义条件与处理程序

**案例分析**

存储过程执行 SQL 语句出错时，会中断执行。定义条件和处理程序可以避免这种情况。

**定义条件**

使用 `DECLARE 错误名称 CONDITION FOR 错误码` 定义错误名称和错误类型。

**定义处理程序**

使用 `DECLARE 处理方式 HANDLER FOR 错误类型 处理语句` 定义处理程序，处理方式有 CONTINUE、EXIT、UNDO。

**案例解决**

在存储过程中定义处理程序，捕获错误并执行相应操作，例如设置变量值。

### 流程控制

流程控制语句用于控制存储过程中 SQL 语句的执行顺序。

**IF 语句**

根据条件执行不同的操作，语法格式：

```
IF 表达式1 THEN 操作1
[ELSEIF 表达式2 THEN 操作2]……
[ELSE 操作N]
END IF
```

**CASE 语句**

根据条件执行不同的操作，有两种语法格式：

- 类似于 switch

- 类似于多重 if

**循环结构**

- **LOOP**: 无条件循环，使用 `LEAVE` 语句退出。

- **WHILE**: 条件循环，先判断后执行。

- **REPEAT**: 条件循环，先执行后判断。

**跳转语句**

- **LEAVE**: 跳出循环或程序体。

- **ITERATE**: 重新开始循环。

### 游标

游标用于逐条读取结果集中的数据。

**使用步骤**

1. 声明游标：`DECLARE cursor_name CURSOR FOR select_statement;`

2. 打开游标：`OPEN cursor_name;`

3. 使用游标：`FETCH cursor_name INTO var_name [, var_name] ...;`

4. 关闭游标：`CLOSE cursor_name;`

**举例**

创建存储过程，使用游标累加薪资最高的几个员工的薪资值，直到总和达到指定值。

**小结**

游标提供了灵活的操作方式，但也可能带来性能问题，建议及时关闭游标。

## 触发器

### 创建触发器语法

```
CREATE TRIGGER 触发器名称
{BEFORE|AFTER} {INSERT|UPDATE|DELETE} ON 表名
FOR EACH ROW
触发器执行的语句块;
```
